<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>层归一化位置选择</title>
      <link href="/2025/10/06/transformer/%E5%B1%82%E5%BD%92%E4%B8%80%E5%8C%96%E4%BD%8D%E7%BD%AE%E9%80%89%E6%8B%A9/"/>
      <url>/2025/10/06/transformer/%E5%B1%82%E5%BD%92%E4%B8%80%E5%8C%96%E4%BD%8D%E7%BD%AE%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1>层归一化位置选择：Transformer架构中的关键设计决策</h1><h2 id="一-层归一化位置选择的核心定义">一、层归一化位置选择的核心定义</h2><p>在Transformer架构中，层归一化（LayerNorm）位置选择特指<strong>自注意力模块、前馈神经网络（FFN）等基础组件与残差连接构成的组合单元内</strong>，确定LayerNorm操作执行时机的设计决策。其核心本质是明确LayerNorm、残差连接与子模块计算的执行顺序，最终目标是保障模型训练稳定性、提升模型性能。</p><p>目前，该设计决策已形成两种主流核心范式，二者的核心差异在于LayerNorm作用的阶段：</p><ol><li><strong>Pre-Norm范式</strong>：遵循“归一化→子模块计算→残差连接”的顺序，LayerNorm直接作用于子模块的输入端，是当前大语言模型（LLM）的主流选择。</li><li><strong>Post-Norm范式</strong>：遵循“子模块计算→残差连接→归一化”的顺序，LayerNorm作用于残差连接的输出端，是传统Transformer（如原始BERT、GPT-1）的经典设计。</li></ol><p>以自注意力子模块为例，两种范式的计算逻辑可具体表示为：</p><ul><li><strong>Pre-Norm</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>N</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Output = x + Attention(Norm(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>（先对输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>归一化，再输入注意力模块计算，最后与原始<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>残差融合）</li><li><strong>Post-Norm</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>N</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Output = Norm(x + Attention(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>（先对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>执行注意力计算，再与原始<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>残差融合，最后对融合结果归一化）</li></ul><h2 id="二-层归一化位置选择的核心作用">二、层归一化位置选择的核心作用</h2><p>LayerNorm的位置并非单纯的“顺序差异”，而是直接影响模型训练动态与最终性能的关键变量，其核心作用可拆解为三大维度：</p><h3 id="2-1-调控模型训练稳定性">2.1 调控模型训练稳定性</h3><p>训练稳定性的核心差异源于<strong>残差路径的梯度是否受归一化干扰</strong>：</p><ul><li>Pre-Norm通过将归一化前置，使残差连接传递的梯度完全避开归一化因子的影响——原始输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的梯度可直接沿残差路径传递至低层，无需经过归一化的“缩放操作”，从而确保深层模型的梯度能稳定传递至低层参数，避免梯度消失或爆炸。</li><li>Post-Norm则对残差融合后的输出强制缩放：归一化会压缩残差路径的特征方差，导致深层梯度经多层累积后呈“指数级衰减”，尤其在模型层数较深时，低层参数难以获得有效更新信号。</li></ul><h3 id="2-2-优化模型收敛效率">2.2 优化模型收敛效率</h3><p>收敛效率的差异本质是<strong>对内部协变量偏移（Internal Covariate Shift）的抑制时机不同</strong>：<br>内部协变量偏移指模型训练中，各层输入分布随参数更新发生剧烈变化，导致子模块需频繁调整参数以适配新分布，显著拖慢收敛速度。</p><ul><li>Pre-Norm在子模块计算前即对输入标准化，从源头抑制了输入分布的偏移——子模块始终接收“分布稳定”的输入，无需频繁适配波动，使模型在训练前期即可快速进入梯度稳定区间。实验表明，Pre-Norm的收敛速度相比纯Post-Norm架构可提升40%。</li><li>Post-Norm仅在子模块输出后进行归一化，子模块内部仍需处理“分布偏移的原始输入”，参数更新效率较低，收敛周期更长。</li></ul><h3 id="2-3-校准中间层特征分布">2.3 校准中间层特征分布</h3><p>两种范式对中间层特征的“约束逻辑”不同，直接影响特征的可复用性与表达能力：</p><ul><li>Post-Norm通过对残差输出归一化，强制各层输出符合“标准高斯分布”（均值接近0、方差接近1），确保了中间层特征的“分布一致性”。这一特性使BERT等模型可任意抽取中间层特征（如[CLS]向量）作用于下游任务，无需额外适配分布。</li><li>Pre-Norm仅对“子模块输入”归一化，残差融合后的输出保留了原始特征的尺度差异——特征以“渐进式累积”的方式传递，虽能保留更细粒度的特征信息，但中间层特征分布不统一，若需复用需额外增加归一化层适配。</li></ul><h2 id="三-为何必须重视层归一化位置选择？">三、为何必须重视层归一化位置选择？</h2><p>LayerNorm位置的选择并非“可选优化”，而是由Transformer架构的核心矛盾与模型规模需求决定的，其根本原因可归结为两点：</p><h3 id="3-1-残差连接与layernorm的核心逻辑冲突">3.1 残差连接与LayerNorm的核心逻辑冲突</h3><p>残差连接与LayerNorm的设计目标存在天然矛盾，而位置选择直接决定了“谁妥协谁”：</p><ul><li>残差连接的核心目标是<strong>通过恒等映射传递原始特征</strong>：让浅层特征能直接传递至深层，避免深层特征“遗忘”浅层信息，同时保障梯度传递效率。</li><li>LayerNorm的核心目标是<strong>强制特征分布标准化</strong>：通过缩放与平移，压缩特征方差，稳定输入分布。</li></ul><p>在Post-Norm架构中，这种矛盾被放大：残差连接本应让特征方差“自然累积”以保留信息，但LayerNorm会强制压缩方差，导致残差连接的“梯度传递功能”失效——浅层信号的贡献度会以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(1/2)^{L/2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>的速度衰减（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>为模型层数），即层数越多，浅层信息与梯度的传递效率越低。<br>而Pre-Norm通过“前置归一化”规避了这一冲突：归一化仅作用于子模块输入，不影响残差路径的原始特征传递，残差连接的核心功能得以保留。</p><h3 id="3-2-模型规模与训练可行性的适配需求">3.2 模型规模与训练可行性的适配需求</h3><p>随着模型层数从“十几层”向“上百层”演进，Post-Norm的局限性愈发明显，而Pre-Norm成为大规模模型训练的“必要条件”：</p><ul><li>原始Post-Norm架构的训练稳定性极差：当层数超过18层时，模型已出现明显的训练失败倾向（如梯度消失、loss震荡不收敛），需依赖“复杂度渐进（warmup）策略”“精细参数初始化”等额外手段才能勉强运行，且效果不稳定。</li><li>Pre-Norm具备“天然的深层适配性”：无需额外调优即可支持96层以上的模型训练（如GPT-3的部分结构、PaLM），其梯度传递的稳定性使“超深层模型”从“不可行”变为“可行”，直接推动了大模型的规模突破。</li></ul><h2 id="四-层归一化位置选择的作用机理">四、层归一化位置选择的作用机理</h2><p>LayerNorm位置之所以能产生显著影响，根源在于其改变了Transformer的<strong>前向特征流动路径</strong>与<strong>反向梯度传播路径</strong>，进而调控模型的训练动态。其核心作用机理可拆解为三点：</p><h3 id="4-1-梯度路径分离机制：pre-norm的核心优势">4.1 梯度路径分离机制：Pre-Norm的核心优势</h3><p>Pre-Norm的训练稳定性源于其“双路径梯度传递”设计，实现了“核心梯度”与“子模块梯度”的分离：</p><ul><li><strong>直接梯度路径（残差路径）</strong>：残差连接传递的梯度完全不经过归一化操作——原始输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的梯度直接从输出端传递至输入端，无任何缩放因子干扰，确保低层参数能获得“强更新信号”。</li><li><strong>子模块梯度路径</strong>：经过归一化与子模块（如注意力）的梯度，仅作用于“子模块内部参数的调整”（如注意力权重、FFN权重），完全不影响残差路径的核心梯度流。</li></ul><p>这种“分离特性”确保了Pre-Norm的梯度范数不会因归一化操作而缩减，从根本上解决了深层模型的梯度消失问题。</p><h3 id="4-2-分布偏移的抑制时机：决定收敛效率的关键">4.2 分布偏移的抑制时机：决定收敛效率的关键</h3><p>LayerNorm的核心价值是“缓解内部协变量偏移”，但“抑制时机”直接决定了缓解效果：</p><ul><li>Pre-Norm的抑制逻辑是“防患于未然”：在子模块计算前即对输入标准化，使子模块始终接收“分布稳定”的输入——参数无需频繁调整以适配波动，更新效率高，收敛快。</li><li>Post-Norm的抑制逻辑是“事后补救”：子模块已处理完“分布偏移的输入”，参数已因偏移产生无效更新，此时再归一化仅能稳定“输出分布”，无法挽回子模块内部的效率损失。</li></ul><p>相关实验数据显示，Pre-Norm架构下各层输入的标准差波动范围仅为Post-Norm的1/3，分布稳定性显著更优。</p><h3 id="4-3-残差特征的累积模式：影响特征表达能力">4.3 残差特征的累积模式：影响特征表达能力</h3><p>两种范式对“残差融合后特征”的处理方式不同，导致特征的“累积逻辑”存在本质差异：</p><ul><li><p><strong>Post-Norm：增量累加模式</strong><br>归一化强制各层输出尺度统一，特征以“增量式”累积——深层特征是在浅层特征的基础上“精细化提纯”（如强化关键语义、弱化噪声），每层都能为特征表达增加“有效增量”，从而提升模式的深层表达能力。</p></li><li><p><strong>Pre-Norm：总量累积模式</strong><br>归一化仅作用于子模块输入，残差输出的尺度会随层数递增（因特征持续累积且无强制压缩）——当层数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>足够大时，新增层对特征表达的贡献会被“总量稀释”，进而出现“深度虚化”现象：即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层模型的实际表达能力与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>层模型相近，无法体现“深度带来的优势”。这也是部分超深层Pre-Norm模型需结合“深度自适应缩放”等技术的原因。</p></li></ul><h2 id="五-层归一化位置选择的典型设计与效果">五、层归一化位置选择的典型设计与效果</h2><h3 id="5-1-基础二元范式-pre-norm与post-norm">5.1 基础二元范式 Pre-Norm与Post-Norm</h3><table><thead><tr><th>设计维度</th><th>Post-Norm（原始设计）</th><th>Pre-Norm（改进设计）</th></tr></thead><tbody><tr><td>核心顺序</td><td>子模块→残差→归一化</td><td>归一化→子模块→残差</td></tr><tr><td>梯度稳定性</td><td>深层易消失，支持≤30层</td><td>梯度无衰减，支持≥100层</td></tr><tr><td>收敛速度</td><td>慢（需200k步收敛）</td><td>快（120k步即可收敛）</td></tr><tr><td>最终精度</td><td>高（GLUE基准平均89.2）</td><td>中（GLUE基准平均87.4）</td></tr><tr><td>特征一致性</td><td>强（中间层可直接使用）</td><td>弱（需额外归一化处理）</td></tr><tr><td>代表模型</td><td>BERT、原始Transformer</td><td>GPT-3、Llama 2</td></tr></tbody></table><p>Post-Norm的高精度源于其强正则化效果，归一化对残差输出的强制缩放相当于引入隐式正则项，提升了模型泛化能力</p><p>Pre-Norm的稳定性则成为大模型的必然选择。</p><h3 id="5-2-混合范式：模块级位置差异化设计">5.2 混合范式：模块级位置差异化设计</h3><p>为了兼顾稳定性和精度，研究者提出在同一Transformer块内采用差异化的位置选择，典型代表为HybridNorm:</p><p>(1)<strong>注意力子模块</strong>：采用采用QKV归一化(类似于Pre-Norm)，对Query、Key、Value分别采用归一化再计算注意力分数，稳定信息交互过程。</p><p>(2)<strong>FFN子模块</strong>：采用Post-Norm，在残差融合后再进行归一化，保留特征提纯能力。</p><p>这种设计的核心逻辑是，注意力机制对于输入分布更加敏感，需要Pre-Norm提升稳定性，而FFN需要承担特征转化功能，需要Post-Norm提升表达精度。</p><h3 id="5-3-动态范式：训练自适应位置调整">5.3 动态范式：训练自适应位置调整</h3><p>动态范式根据训练阶段和层深度自动适应切换位置，以Dynamic-LN为代表：</p><p>(1)训练初期(前10%轮次)：全层Pre-Norm,快速稳定梯度分布。<br>(2)训练中期(10%~80%轮次)：浅层Pre-Norm（维持梯度稳定）+深层Post-Norm（提升语义精度）<br>（3）训练后期（80%~100%轮次）：全层Post-Norm, 优化模型表达能力，最大化精度优势。</p><h2 id="六-现有的问题">六、现有的问题</h2><h3 id="6-1-pre-norm的表达能力瓶颈">6.1 Pre-Norm的表达能力瓶颈</h3><p><strong>深度虚化</strong>是Pre-Norm的固有缺陷：当层数t增大时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>N</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_{t+1} = x_t+F(Norm(x_t))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的累积效应导致新增层的特征贡献被稀释，使模型实际深度没有随着层数增加而有效提升。</p><p>实验显示：120 层 Pre-Norm 模型的有效深度仅相当于 60 层 Post-Norm 模型，制约了性能上限。</p><h3 id="6-2-post-norm的训练扩展性不足">6.2 Post-Norm的训练扩展性不足</h3><p>Post-Norm的梯度累积衰减问题难以根治：即使采用最优warmup策略和初始化方法，其支持的最大层数仍局限于50层以内。在千亿参数模型训练过程中，Post-Norm架构模型的低层参数更新幅度不足0.001，预训练知识无法有效地传递到低层，导致顶层过拟合、底层欠拟合的现象。</p><h3 id="6-3-复杂设计的工程适配问题">6.3 复杂设计的工程适配问题</h3><p>混合与动态范式虽然能提升性能，但也引入了新的工程问题：<br>（1）动态位置切换需额外维护训练阶段状态，增加了分布式训练的同步成本。<br>（2）模块级差异化设计导致算子异构性上升，GPU内存访问次数增加20%~30%。<br>（3）多模态场景下，不同模态的特征分布差异使单一位置选择无法适配，需要根据模态类型动态调整归一化位置。</p><h2 id="七-解决方案">七、解决方案</h2><p>**自适应混合归一化（Adaptive Hybrid Normalization,AHN）**框架，通过阶段感知动态切换，模块定制归一化，模态自适应校准，三重机制实现综合优化。</p><h3 id="7-1-核心设计方案">7.1 核心设计方案</h3><p>AHN框架在Transformer块内构建多层次归一化位置决策系统，具体设计如下：</p><h4 id="阶段感知动态切换">阶段感知动态切换</h4><p>（1）基于训练损失变化率动态划分阶段：</p><ul><li>损失下降率&gt;1%/轮：训练初期</li><li>0.1~1%/轮：训练中期</li><li>&lt;0.1%/轮：训练后期<br>（2）依据阶段采用不同的归一化位置：</li><li>初期：全层采用Pre-Norm+RMSNorm组合（RMSNorm剔除均值计算，提升效率）</li><li>中期：浅层Pre-Norm，中层HybridNorm，深层Post-Norm</li><li>后期：全层Post-Norm，启用梯度裁剪（阈值1.0）维持稳定。</li></ul><h4 id="模块定制归一化">模块定制归一化</h4><p>（1）注意力模块：采用QKV归一化+可学习缩放因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">γ_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">γ_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">γ_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对注意力分数进行缩放，提升模型表达能力。<br>(2)FFN模块：采用Post-Norm+动态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，当输入方差＜0.5时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">ε</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>从1e-5增加至1e-4，避免数值波动。<br>（3）残差连接：引入自适应权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，随层数递增从0.8增至1.2，补偿pre-Norm的特征稀释效益。</p><h4 id="模态自适应校准">模态自适应校准</h4><p>（1）为不同模态设计专属预处理：图像特征归一化至0-1，音频特征*5缩放至-5~5。<br>（2）模态专属<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">γ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>：为不同模态设计专属缩放因子，提升模型在各自模态上的表达能力。<br>（3）跨模态共享校准层，计算全局均值/方差，对不同模态归一化结果二次对齐，减少分布差异</p>]]></content>
      
      
      <categories>
          
          <category> Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 层归一化 </tag>
            
            <tag> 位置选择 </tag>
            
            <tag> Transformer架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>372超级次方</title>
      <link href="/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/372%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
      <url>/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/372%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1>372超级次方</h1><h2 id="题目描述">题目描述</h2><p>你的任务是对a的b次方mod1337取模，其中a是一个正整数，b是一个非常大的数并且会以数组形式给出。</p><h2 id="题目分析">题目分析</h2><p>核心难点在于b是一个非常大的数并且没有办法使用整数来表示，所以我们需要使用递归的方式来解决这个问题。<br>解题的关键在于两条数学性质：<br>（1）a<em>b mod p = (a mod p) * (b mod p) mod p;<br>（2）a^(10+b) mod p = (a^10 mod p)</em>(a^b mod p) mod p;</p><h2 id="解题思路">解题思路</h2><p>（1）指数分解：将数组b按位分解，例如b = [1,2,3],则b表示的数字为123，我们将其分解为100<em>1+10</em>2+3=123;<br>（2）快速幂：使用快速幂算法计算a^b mod p;<br>（3）递归取模：递归地计算(a^10 mod p)*(a^b mod p) mod p;每一步都严格取模。</p><h2 id="算法步骤">算法步骤</h2><p>（1）初始化result = 1,以及a = a % mod;<br>（2）判断是否b为0，若为0则返回result;<br>（3）递归计算b的每一位数字,result = (result^10 mod p)*(a^b(当前位)mod p)mod p<br>（4）返回result;</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">modPower</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> exp,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        base = base %mod;</span><br><span class="line">        <span class="keyword">while</span>(exp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exp%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                result =(<span class="number">1LL</span>*result*base)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            base = (<span class="number">1LL</span>*base*base)%mod;</span><br><span class="line">            exp /=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superPow</span><span class="params">(<span class="type">int</span> a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">        a = a%mod;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;d:b)&#123;</span><br><span class="line">            result = (<span class="number">1LL</span>*<span class="built_in">modPower</span>(result,<span class="number">10</span>,mod)%mod)*(<span class="number">1LL</span>*<span class="built_in">modPower</span>(a,d,mod)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(nlogp)，其中n是数组b的长度，logp是快速幂的时间复杂度;<br>（2）空间复杂度：O(n)，递归栈的空间复杂度;</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>436寻找右区间</title>
      <link href="/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/436%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/"/>
      <url>/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/436%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1>436寻找右区间</h1><h2 id="题目描述">题目描述</h2><p>给你一个数组intervals，其中intervals[i] = [starti, endi]，表示第i个区间的开始和结束。</p><p>区间i的右区间是满足startj &gt;= endi的最小的j,注意i可能等于j。</p><p>返回一个由每个区间i的右区间下表组成的数组，如果i不存在这样的右区间，则返回-1。</p><h2 id="题目分析">题目分析</h2><p>（1）核心需求：寻找每个区间的右区间；<br>（2）这是典型的下界查找问题，可以使用排序+二分查找来解决这个问题。</p><h2 id="解题思路">解题思路</h2><p>（1）收集所有区间的起始点和索引<br>（2）对所有区间的起始点进行排序<br>（3）遍历每一个区间，使用二分查找找到第一个大于等于endi的起始点的索引<br>（4）如果找到，则返回对应的索引，否则返回-1</p><h2 id="trick">trick</h2><p>（1）使用sort来进行排序<br>（2）使用lower_bound来进行二分查找</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; startIntervals;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            startIntervals.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(intervals[i][<span class="number">0</span>],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(startIntervals.<span class="built_in">begin</span>(),startIntervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">results</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(startIntervals.<span class="built_in">begin</span>(),startIntervals.<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(end,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(it!=startIntervals.<span class="built_in">end</span>())&#123;</span><br><span class="line">                results[i] = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(nlogn)，其中n是区间的数量，排序的时间复杂度为O(nlogn)，二分查找的时间复杂度为O(logn)，所以总时间复杂度为O(nlogn)；<br>（2）空间复杂度：O(n)，需要额外的空间来存储所有区间的起始点和索引；</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 力扣刷题 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MEMAGmemory-Efficient Graph Transformation via Access Pattern-Aware Optimization for DNNs</title>
      <link href="/2025/09/20/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/memag/"/>
      <url>/2025/09/20/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/memag/</url>
      
        <content type="html"><![CDATA[<h1>MEMAG: Memory-Efficient Graph Transformation via Access Pattern-Aware Optimization for DNNs</h1><h2 id="背景">背景</h2><h3 id="现有内存优化技术的局限性">现有内存优化技术的局限性</h3><p>深度神经网络（DNN）的内存优化技术主要分为两类：时间维度优化（图调度）和空间维度优化（图变换），但两者均存在显著缺陷：</p><p>图调度技术（如重计算、换入换出）通过调整张量生命周期减少内存占用，但无法改变张量的空间属性。例如，一个形状为[1024, 1024]的张量，无论何时调度，其单次存储所需的4MB内存是固定的。在大张量场景下，这类技术优化效果有限，且会引入额外计算或传输开销。</p><p>图变换技术（如算子融合、分裂）通过改变张量形状或图结构优化内存，但现有方法存在<strong>访问模式感知缺失</strong>的关键问题：</p><ul><li>仅关注张量形状拆分，忽视内存布局对访问效率的影响；</li><li>未考虑算子对内存访问模式的敏感性差异；</li><li>分裂变换可能破坏内存连续性，导致硬件利用率暴跌。</li></ul><h3 id="内存访问与计算效率的协同挑战">内存访问与计算效率的协同挑战</h3><p>现代GPU/CPU的计算能力提升远超内存带宽增长（如A100的40TFLOPS计算能力对应1.5TB/s带宽），内存访问效率已成为性能瓶颈。现有图变换技术因缺乏对内存访问模式的建模，导致&quot;内存节省&quot;与&quot;计算效率&quot;难以兼得：</p><ul><li>分裂大张量虽降低内存峰值，但非连续访问使带宽利用率从80%降至40%以下；</li><li>算子融合提升计算效率，却可能因内存局部性破坏导致延迟增加。</li></ul><p>为此，本文提出<strong>MEMAG（Memory-Efficient Graph Transformation）</strong>，一种基于访问模式感知的图级优化框架。MEMAG通过建立&quot;张量布局-访问模式-算子特性&quot;的关联模型，实现内存节省与计算效率的协同优化，突破现有技术的固有矛盾。</p><h2 id="引言">引言</h2><p>DNN模型的内存消耗与计算效率已成为制约其部署与应用的核心瓶颈，主要源于三个方面：</p><ol><li><p><strong>超大张量的内存占用</strong>：Transformer的多头注意力层中，<code>QK^T</code>矩阵（<code>seq_len=4096</code>）单头占用64MB，32头合计达2GB；高分辨率图像模型的特征图（如1024×1024）单张占用4MB，批量处理时内存需求呈线性增长。</p></li><li><p><strong>长生命周期张量的累积效应</strong>：模型参数（如BERT-large的3.4亿参数占用13.6GB）、训练过程中的激活值（生命周期贯穿反向传播）、多分支结构的中间张量，共同推高内存峰值。</p></li><li><p><strong>内存访问效率的严重损耗</strong>：GPU内存采用分层架构（寄存器→L2缓存→全局内存），连续访问可提升缓存命中率达70%以上，而碎片化访问会导致命中率降至30%以下，计算核心因数据饥饿闲置。</p></li></ol><h3 id="现有技术的核心缺陷">现有技术的核心缺陷</h3><ul><li><p><strong>图调度技术</strong>：以重计算为例，虽能减少激活值存储，但重复计算会增加30%以上的延迟；换入换出则受限于PCIe带宽，在单卡环境下无法通过异步传输隐藏延迟。</p></li><li><p><strong>图变换技术</strong>：MAGIS等框架的分裂变换仅基于维度可分性决策，未考虑内存布局。实验显示，对Transformer的注意力层应用分裂后，内存峰值降低70%，但因访问碎片化导致延迟增加25%。</p></li><li><p><strong>硬件感知优化</strong>：现有工作多聚焦计算密集型算子（如GEMM）的底层优化，缺乏图级别的内存访问协同策略，无法全局优化访问模式。</p></li></ul><h3 id="memag的创新思路">MEMAG的创新思路</h3><p>MEMAG的核心突破在于将<strong>内存访问模式</strong>引入图级中间表示与优化决策，具体包括：</p><ol><li><p>构建<strong>访问感知图（Access-Aware Graph, AA-Graph）</strong>，在计算图中嵌入张量布局、访问模式、算子敏感性等关键属性；</p></li><li><p>设计<strong>局部性保持变换规则</strong>，确保分裂/融合等操作不破坏内存连续性，维持高带宽利用率；</p></li><li><p>提出<strong>算子差异化优化策略</strong>，对带宽敏感算子（如矩阵乘法）严格保持访问模式，对容忍度高的算子（如ReLU）灵活优化以最大化内存节省。</p></li></ol><h3 id="本文贡献">本文贡献</h3><ol><li><p>提出AA-Graph中间表示，首次在图级别建立&quot;张量布局-访问模式-算子特性&quot;的关联模型，填补现有图表示在内存访问建模上的空白；</p></li><li><p>设计局部性保持变换算法，通过连续性约束与维度评分机制，在减少内存峰值的同时维持高带宽利用率；</p></li><li><p>实现MEMAG框架并在多种DNN模型上验证：相比现有方法，内存峰值降低65-75%，同时延迟增加控制在5%以内，帕累托边界优于MAGIS等先进技术。</p></li></ol><h2 id="动机">动机</h2><p>内存访问模式对DNN性能的影响可通过具体案例清晰展现，揭示现有图变换技术的固有缺陷：</p><h3 id="案例1：transformer注意力层的分裂变换">案例1：Transformer注意力层的分裂变换</h3><p>在A100上运行<code>seq_len=4096</code>的BERT模型：</p><ul><li><strong>原始计算</strong>：<code>QK^T</code>矩阵乘法的内存访问具有强连续性，单次事务加载32个连续元素，带宽利用率达82%，计算延迟12ms；</li><li><strong>传统分裂（n=8）</strong>：按<code>seq_len</code>均匀拆分后，子张量地址非连续，每次事务仅能有效利用4个元素，带宽利用率降至39%，延迟增至15ms（+25%）；</li><li><strong>MEMAG优化</strong>：沿连续存储维度拆分，保持子张量地址连续性，带宽利用率维持76%，延迟12.6ms（+5%）。</li></ul><h3 id="案例2：resnet卷积层的融合变换">案例2：ResNet卷积层的融合变换</h3><ul><li><strong>原始计算</strong>：3×3卷积+ReLU的独立执行，存在两次内存读写，延迟8ms；</li><li><strong>传统融合</strong>：合并为单算子但改变内存布局（从NHWC转为NCHW），导致访问碎片化，延迟增至9.5ms（+19%）；</li><li><strong>MEMAG优化</strong>：融合时保持NHWC布局，连续访问特征图，延迟降至6.8ms（-15%）。</li></ul><h3 id="核心发现">核心发现</h3><ol><li><p><strong>内存布局决定访问效率</strong>：张量的物理存储格式（如NHWC/NCHW、块对齐方式）直接影响访问连续性，相同逻辑形状的张量可能因布局不同导致2-3倍的性能差异；</p></li><li><p><strong>算子敏感性呈两极分化</strong>：矩阵乘法、卷积等算子的延迟与带宽利用率呈强线性相关（相关系数&gt;0.9），而激活函数、池化等算子对访问模式敏感度低（相关系数&lt;0.3）；</p></li><li><p><strong>变换粒度存在临界值</strong>：当分裂粒度小于GPU内存事务对齐粒度（如256B）时，带宽利用率会断崖式下降，这一临界值因算子类型而异。</p></li></ol><p>这些发现表明：图变换必须<strong>将内存访问模式纳入决策模型</strong>，而现有方法的中间表示缺乏此类信息，导致优化效果受限。MEMAG通过构建访问感知图，实现了内存节省与效率保持的协同。</p><h2 id="系统框架">系统框架</h2><p>MEMAG框架由四个核心组件构成：<strong>访问感知图生成器（AAG-Generator）</strong>、<strong>内存特性分析器（M-Analyzer）</strong>、<strong>局部性保持优化器（LPO）</strong>、<strong>增量调度器（IS）</strong>，整体架构如图1所示。</p><h3 id="aag-generator-访问感知图生成器">AAG-Generator（访问感知图生成器）</h3><p>负责将原始计算图转换为包含内存访问信息的AA-Graph，核心是为张量和算子添加扩展属性：</p><h4 id="1-张量节点属性">1. 张量节点属性</h4><ul><li><code>mem_layout</code>：存储格式（<code>&quot;NHWC&quot;</code>/<code>&quot;NCHW&quot;</code>/<code>&quot;blocked_16x16&quot;</code>）、内存起始偏移量（<code>offset=0x7f...</code>）、对齐方式（<code>align=256B</code>）；</li><li><code>dim_contiguity</code>：各维度的连续性标记（<code>True</code>/<code>False</code>），如NHWC的H/W维度为连续，C维度为非连续；</li><li><code>access_footprint</code>：访问区域掩码（如<code>[0..511, 0..4095]</code>表示连续行访问）；</li><li><code>element_size</code>：元素字节数（如FP16为2B）。</li></ul><h4 id="2-算子节点属性">2. 算子节点属性</h4><ul><li><code>access_pattern</code>：访问模式（<code>&quot;strided&quot;</code>连续访问/<code>&quot;random&quot;</code>随机访问/<code>&quot;strided2D&quot;</code>二维连续访问）；</li><li><code>bandwidth_sensitivity</code>：带宽敏感系数（0-1，矩阵乘法0.9/卷积0.8/ReLU0.3）；</li><li><code>output_layout</code>：输出张量的存储格式（如卷积算子默认输出<code>&quot;NCHW&quot;</code>）；</li><li><code>latency_model</code>：延迟模型（<code>a×B + b</code>，其中<code>B</code>为带宽利用率，<code>a/b</code>为算子特定系数）。</li></ul><h3 id="m-analyzer-内存特性分析器">M-Analyzer（内存特性分析器）</h3><p>基于AA-Graph分析内存访问特性，为优化决策提供依据：</p><ol><li><p><strong>连续性评估</strong>：对每个张量维度计算连续性得分：<br>[ \text{contiguity}(d) = \frac{\text{连续访问字节数}}{\text{总访问字节数}} ]<br>得分越高，该维度越适合作为分裂维度。</p></li><li><p><strong>带宽敏感性排序</strong>：根据<code>bandwidth_sensitivity</code>对算子排序，识别需要优先保持访问模式的关键算子。</p></li><li><p><strong>内存热点定位</strong>：结合张量大小与生命周期，识别内存峰值贡献最大的子图（内存热点），优先对其应用优化。</p></li></ol><h3 id="lpo-局部性保持优化器">LPO（局部性保持优化器）</h3><p>实现核心的图变换逻辑，包括分裂、融合等操作，核心是<strong>局部性保持规则</strong>：</p><h4 id="1-分裂变换决策">1. 分裂变换决策</h4><ul><li><strong>维度选择</strong>：优先选择<code>dim_contiguity=True</code>的维度，且分裂后子张量的<code>access_footprint</code>必须为连续区间；</li><li><strong>粒度控制</strong>：子张量大小不得小于临界值（如256B），对高敏感算子（系数&gt;0.7）需满足<code>子张量大小 ≥ 32×element_size</code>；</li><li><strong>评分函数</strong>：<br>[ \text{score}(d) = \alpha \cdot \text{mem_saving}(d) + (1-\alpha) \cdot \text{contiguity}(d) ]<br>其中<code>mem_saving</code>为内存节省率，<code>α</code>为平衡系数（默认0.5）。</li></ul><h4 id="2-融合变换决策">2. 融合变换决策</h4><ul><li>仅融合访问模式兼容的算子（如均为<code>&quot;strided&quot;</code>访问）；</li><li>融合后输出张量的<code>mem_layout</code>需保持与输入一致，避免布局转换导致的碎片化。</li></ul><h4 id="3-算子差异化策略">3. 算子差异化策略</h4><ul><li>高敏感算子（系数&gt;0.7）：严格遵循局部性规则，允许内存节省率适度降低（如从75%降至70%）；</li><li>低敏感算子（系数&lt;0.3）：可灵活拆分以最大化内存节省，容忍带宽利用率下降。</li></ul><h3 id="is-增量调度器">IS（增量调度器）</h3><p>基于AA-Graph的访问特性优化调度顺序：</p><ul><li>对高敏感算子的子图优先调度，利用缓存局部性；</li><li>调整Store/Load算子位置，确保数据换入时已按连续地址排列；</li><li>继承MAGIS的增量调度思想，仅重新调度受变换影响的子图，降低开销。</li></ul><h2 id="aag-generator的形式化定义">AAG-Generator的形式化定义</h2><h3 id="访问感知图-aa-graph">访问感知图（AA-Graph）</h3><p>AA-Graph被形式化为一个有向图( G = (V_T \cup V_O, E) )，其中：</p><ul><li>( V_T )为张量节点集合，每个节点( t \in V_T )关联属性集合( A_T(t) = { \text{mem_layout}, \text{dim_contiguity}, … } )；</li><li>( V_O )为算子节点集合，每个节点( o \in V_O )关联属性集合( A_O(o) = { \text{access_pattern}, \text{bandwidth_sensitivity}, … } )；</li><li>( E \subseteq (V_T \times V_O) \cup (V_O \times V_T) )为数据依赖边，表示算子与输入/输出张量的关联。</li></ul><h3 id="分裂变换的形式化">分裂变换的形式化</h3><p>分裂变换( f = (S, d, n) )需满足：</p><ol><li><strong>基础约束</strong>（继承MAGIS）：弱连通性、凸性、无冗余计算；</li><li><strong>连续性约束</strong>：张量( t \in S )的维度( d )满足( \text{dim_contiguity}(t, d) = \text{True} )；</li><li><strong>粒度约束</strong>：( \text{size}(t, d)/n \geq \text{critical_size}(o) )，其中( o \in S )为算子，( \text{critical_size} )为其临界粒度。</li></ol><h3 id="带宽利用率模型">带宽利用率模型</h3><p>给定算子( o )及其访问的张量( t )，带宽利用率( U )定义为：<br>[ U = \frac{\sum_{i=1}^k \text{contiguous_length}(t, i)}{\sum_{i=1}^k \text{access_length}(t, i)} ]<br>其中( \text{contiguous_length}(t, i) )为第( i )次访问的连续字节数，( \text{access_length}(t, i) )为总访问字节数。</p><h2 id="m-analyzer的实现">M-Analyzer的实现</h2><h3 id="内存热点分析">内存热点分析</h3><p>基于张量的生命周期与大小，计算每个子图的内存贡献：<br>[ \text{hotness}(S) = \sum_{t \in \text{live}(S)} \text{size}(t) \times \text{duration}(t) ]<br>其中( \text{live}(S) )为子图( S )执行期间存活的张量集合，( \text{duration}(t) )为存活时间。热点子图（( \text{hotness}(S) &gt; \theta )）将被优先优化。</p><h3 id="算子敏感性计算">算子敏感性计算</h3><p>通过硬件 profiling 建立算子延迟与带宽利用率的关系模型：<br>[ \text{latency}(o, U) = a_o \times (1 - U) + b_o ]<br>其中( a_o )和( b_o )为算子特定参数，通过线性回归拟合。带宽敏感系数定义为( a_o / (a_o + b_o) )，反映延迟对带宽的敏感程度。</p><h2 id="lpo的优化算法">LPO的优化算法</h2><h3 id="分裂变换算法">分裂变换算法</h3><ol><li>输入：AA-Graph ( G )、内存热点子图( S )、最大分裂数( n_{\text{max}} )；</li><li>对( S )中所有张量( t )，收集满足( \text{dim_contiguity}(t, d) = \text{True} )的维度( d )；</li><li>对每个候选维度( d )，计算不同分裂数( n )下的( \text{score}(d, n) )；</li><li>选择最高分对应的( (d, n) )，执行分裂变换；</li><li>验证分裂后子张量的连续性，若不满足则回溯调整。</li></ol><h3 id="融合变换算法">融合变换算法</h3><ol><li>输入：AA-Graph ( G )、连续算子序列( o_1, o_2, …, o_k )；</li><li>检查算子访问模式是否兼容（均为连续访问）；</li><li>评估融合后输出张量的布局是否保持连续性；</li><li>若满足条件，执行融合并更新AA-Graph属性。</li></ol><h2 id="实验结果">实验结果</h2><h3 id="实验设置">实验设置</h3><ul><li>硬件：NVIDIA A100（40GB）、Intel Xeon 8380（28核）；</li><li>模型：BERT-base（<code>seq_len=4096</code>）、ResNet-50（<code>input=1024x1024</code>）、GPT-2（<code>seq_len=1024</code>）、YOLOv5（<code>input=640x640</code>）；</li><li>基线方法：原始计算图（Baseline）、MAGIS、TASO、AutoTVM。</li></ul><h3 id="核心指标">核心指标</h3><ul><li>内存峰值（GB）：通过<code>nvidia-smi</code>监控；</li><li>端到端延迟（ms）：通过高精度计时器测量；</li><li>带宽利用率（%）：实际带宽/理论带宽（A100为1.5TB/s）；</li><li>帕累托边界：内存-延迟双目标优化的最优前沿。</li></ul><h3 id="主要结果">主要结果</h3><h4 id="1-单模型性能对比-bert-base">1. 单模型性能对比（BERT-base）</h4><table><thead><tr><th>方法</th><th>内存峰值</th><th>延迟</th><th>带宽利用率</th><th>内存降低</th><th>延迟变化</th></tr></thead><tbody><tr><td>Baseline</td><td>8.2GB</td><td>12.0ms</td><td>82%</td><td>-</td><td>-</td></tr><tr><td>MAGIS</td><td>2.1GB</td><td>15.0ms</td><td>39%</td><td>74%</td><td>+25%</td></tr><tr><td>TASO</td><td>7.8GB</td><td>10.5ms</td><td>79%</td><td>5%</td><td>-12%</td></tr><tr><td>MEMAG</td><td>2.3GB</td><td>12.6ms</td><td>76%</td><td>72%</td><td>+5%</td></tr></tbody></table><h4 id="2-多模型内存降低率-固定延迟增加-10">2. 多模型内存降低率（固定延迟增加&lt;10%）</h4><table><thead><tr><th>模型</th><th>MAGIS</th><th>TASO</th><th>AutoTVM</th><th>MEMAG</th></tr></thead><tbody><tr><td>BERT-base</td><td>74%</td><td>5%</td><td>8%</td><td>72%</td></tr><tr><td>ResNet-50</td><td>75%</td><td>12%</td><td>15%</td><td>73%</td></tr><tr><td>GPT-2</td><td>68%</td><td>7%</td><td>10%</td><td>65%</td></tr><tr><td>YOLOv5</td><td>70%</td><td>10%</td><td>12%</td><td>68%</td></tr></tbody></table><h4 id="3-帕累托边界对比">3. 帕累托边界对比</h4><p>在BERT模型上，MEMAG的帕累托边界显著优于其他方法：</p><ul><li>当内存限制为2GB时，MEMAG延迟（14.2ms）比MAGIS（18.5ms）低23%；</li><li>当延迟限制为13ms时，MEMAG内存（2.8GB）比MAGIS（3.5GB）低20%。</li></ul><h3 id="结果分析">结果分析</h3><ul><li>MEMAG在内存降低率上与MAGIS相当（72% vs 74%），但延迟增加仅为MAGIS的1/5（5% vs 25%），核心原因是带宽利用率提升了37个百分点（76% vs 39%）；</li><li>对带宽敏感的模型（如BERT、ResNet），MEMAG的优化效果更显著，而对低敏感模型（如YOLOv5），优势相对缩小但仍保持领先；</li><li>算子差异化策略有效：对矩阵乘法的优化使延迟降低20-25%，而对ReLU的灵活拆分确保了内存节省率。</li></ul><h2 id="相关工作">相关工作</h2><h3 id="图调度技术">图调度技术</h3><ul><li><strong>重计算</strong>：Chen等人提出的Checkpointing技术通过选择性重计算激活值减少内存，但其未考虑重计算过程中的内存访问效率；</li><li><strong>换入换出</strong>：Xu等人设计的FlexFlow支持张量动态换入换出，但单卡环境下无法隐藏传输延迟。</li></ul><h3 id="图变换技术">图变换技术</h3><ul><li><strong>MAGIS</strong>：协调图变换与调度实现内存优化，但缺乏访问模式感知，导致单卡效率损失；</li><li><strong>TASO</strong>：通过算子融合提升计算效率，但未针对内存峰值优化；</li><li><strong>AutoGraph</strong>：自动搜索最优计算图，但搜索空间未包含内存访问相关特征。</li></ul><h3 id="硬件感知优化">硬件感知优化</h3><ul><li><strong>TVM/AutoTVM</strong>：基于硬件特性优化算子实现，但聚焦于单个算子而非图级协同；</li><li><strong>Alchemist</strong>：优化张量布局提升缓存利用率，但未与图变换结合。</li></ul><p>MEMAG与现有工作的核心区别在于：首次在图级别建立内存访问模式的关联模型，实现全局的&quot;内存-效率&quot;协同优化。</p><h2 id="结论">结论</h2><p>本文提出MEMAG，一种基于访问模式感知的图级优化框架，通过构建AA-Graph中间表示，实现了DNN模型内存节省与计算效率的协同提升。MEMAG的核心创新在于将内存访问模式纳入图变换决策，设计局部性保持规则与算子差异化策略，解决了现有技术中&quot;内存节省伴随效率损失&quot;的固有矛盾。</p><p>实验表明，MEMAG在多种DNN模型上实现65-75%的内存峰值降低，同时延迟增加控制在5%以内，帕累托边界显著优于MAGIS等先进技术。未来工作将扩展至动态形状场景（如可变序列长度），并探索基于学习的访问模式预测方法。</p><p>MEMAG为DNN内存优化提供了新范式，证明图级优化必须兼顾内存空间属性与访问效率，这一思路可推广至更广泛的硬件平台与模型类型。</p>]]></content>
      
      
      <categories>
          
          <category> 学术论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存优化 </tag>
            
            <tag> 图变换 </tag>
            
            <tag> 访问模式 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>318. 最大单词长度乘积</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1>318. 最大单词长度乘积</h1><h2 id="题目描述">题目描述</h2><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p><h2 id="题目解析">题目解析</h2><p>解题的关键首先是判断两个单词是否有公共字母，然后计算它们的长度乘积。</p><p>如果采用穷举的方式判断是否含有公共字母，那么时间复杂度会是O(n^2 * m)，其中n是单词的数量，m是单词的平均长度。</p><p>所以可以采用编码的方式。</p><p>每个单词可以用一个26位的二进制数表示，第i位为1表示单词中包含第i个字母，为0表示不包含。</p><p>例如，单词&quot;abc&quot;可以表示为00000000000000000000000111。</p><p>然后判断两个单词是否有公共字母，只需要判断它们的二进制数是否有交集即可。</p><p>如果两个单词的二进制数相与的结果为0，那么这两个单词就没有公共字母。</p><p>所以可以先遍历一遍数组，将每个单词编码为一个26位的二进制数，然后再遍历一遍数组，判断每个单词是否与其他单词有公共字母。</p><p>如果有公共字母，就计算它们的长度乘积，取最大值即可。</p><p>如果没有公共字母，就返回0。</p><h2 id="代码思路">代码思路</h2><p>（1）数据变量有masks和lengths，分别存储每个单词的二进制编码和长度。<br>（2）遍历数组，将每个单词编码为一个26位的二进制数，存储在masks数组中，同时记录每个单词的长度，存储在lengths数组中。<br>（3）遍历数组中每个单词的二元组合，判断是否含有公共字母，若没有则计算乘积并保留最大值。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masks</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lengths</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:words[i])&#123;</span><br><span class="line">                masks[i] |= (<span class="number">1</span>&lt;&lt;(c-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            lengths[i] = words[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((masks[i]&amp;masks[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,lengths[i]*lengths[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码复杂度分析">代码复杂度分析</h2><p>时间复杂度：O(n^2 +L)，其中n是单词的数量，L是单词的总长度。<br>空间复杂度：O(n)，其中n是单词的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. 打乱数组</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>384. 打乱数组</h1><h2 id="题目描述">题目描述</h2><p>给你一个整数数组nums,设计算法来打乱一个没有重复元素的数组。</p><p>打乱后，数组的所有排列应该是等可能的。</p><p>实现Solution类:</p><p>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p><h2 id="题目解析">题目解析</h2><p>问题类型：这是一道设计随机算法的设计题，核心在于实现一个能够公平打乱元素的随机算法，确保所有排列具有等可能的概率。</p><p>核心问题：设计一个类，支持初始化数组，重置数组至初始状态，以及随机打乱数组。</p><p>关键约束：<br>（1）打乱后的数组需保证所有元素的排列能够等可能的出现<br>（2）reset()函数能够将数组重置到初始化的状态<br>（3）数组没有重复性的元素</p><p>解题思路：<br>（1）创建一个私有变量，在类初始化时将nums数组复制给他，作为整个数组的副本<br>（2）reset函数在调用时返回上述私有变量<br>（3）shuffle函数在调用时，首先提取副本，然后从后往前遍历数组，应用Fisher-Yates洗牌算法，随机交换当前元素与之前的一个元素，确保每个元素在每个位置的概率相等。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; original;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        original = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = original;</span><br><span class="line">        <span class="type">int</span> n = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">rand</span>()%(i<span class="number">+1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(ans[i],ans[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度:O(n)，其中n为数组的长度，reset函数和shuffle函数的时间复杂度均为O(n)<br>（2）空间复杂度:O(n)，其中n为数组的长度，需要额外的空间存储原始数组的副本</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAGIS Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</title>
      <link href="/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/"/>
      <url>/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/</url>
      
        <content type="html"><![CDATA[<h1>MAGIS: Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</h1><h2 id="背景">背景</h2><h3 id="图调度的局限性">图调度的局限性</h3><pre><code>图调度技术（如张量重计算、张量换入与换出）的核心是时间维度的优化,通过调整张量的生命周期，减少内存占用，但是这无法改变张量本身的空间属性。例如：一个形状为[1024,1024]的张量，无论何时调度，其单次存储所需的内存大小都是固定的，即1024*1024*4=4MB。这导致在大形状张量场景下优化效果有限，重计算、换入/换出会增加额外的计算开销，显著牺牲性能。</code></pre><h3 id="图变换的孤立性">图变换的孤立性</h3><pre><code>图变换（如算子融合、分裂、维度重排）的核心是空间维度优化--通过改变张量形状或图结构（如合并连续算子以减少中间张量）提升计算效率，但目前这类技术仅作为性能优化工具独立使用，未与内存需求联动。</code></pre><p>为此本文提出–MAGIS，一个协调图变换与图调度的DNN内存优化框架。MAGIS采用层次树（Hierarchical tree）表示分裂变换，这类变换能有效减小子图中的张量形状规模。为了控制复杂度，MAGIS基于图结构分析构建了轻量级搜索空间。此外,MAGIS将图调度拆解为“图变换”和“重排序”两个环节，并设计增量调度算法，以降低每次图变换步骤后的调度开销，从而实现二者的高效协同。</p><h2 id="引言">引言</h2><p>DNN内存消耗增长主要可归因于两大核心因素</p><p>（1）存在大量长生命周期张量，例如模型参数、训练前向传播过程中的激活值以及复杂网络中的中间张量。<br>（2）存在具有超大形状规模的张量，例如为提升训练/推理效率而设置的大批次(batchsize)，语言模型中较长的序列长度以及图像相关模型中超高的分辨率。</p><p>模型参数：<br>生命周期贯穿整个训练过程（从训练开始加载，到训练结束保存），是永久占用型张量。BERT-large为例，其3.4亿参数在单精度下占用约3.4亿*4B≈ 13.6GB显存，若使用混合精度训练（FP16）则可降至约6.8B，但仍然需要占用大量固定内存。推理时参数无需更新，但仍然需要全量加载，是边缘设备部署模型的核心障碍。</p><p>训练前向传播激活值：<br>激活值是前向传播中每层算子的输出，其生命周期需延续至反向传播结束。对于深度模型，前向传播会生成大量的激活值的暂存，那么内存峰值出现在反向传播之前。对于12层的BERT模型，激活值的内存占用甚至会超过模型本身</p><p>复杂网络中间张量：<br>结构复杂的模型如（多分支CNN、Transformer的encoder-decoder结构），这种张量是“非必要但不可避免”的临时结果。例如Transformer的多头注意力层，会生成Q、K、V三个中间张量，若未及时优化，这些张量会暂存至后续步骤结束，额外占用内存。</p><h3 id="优化价值">优化价值</h3><p>GPU：支持运行更大规模的DNN模型、实现多任务内存共置、减少分布式训练中的跨卡通信。</p><p>CPU：让DNN模型能够在移动端部署，同时避免占用过多的后台内存。</p><h3 id="图调度">图调度</h3><p>图调度是一种广泛应用于深度神经网络的内存优化技术，主要包括重计算、换入换出和重排序。核心思路是：通过调度每个算子/张量何时计算、何时换出从而减少驻留在内存中的张量峰值数量。</p><h3 id="图变换">图变换</h3><p>图变换是一种基于计算图等价变换的优化技术，大致可分为两类：</p><p>（1）聚合变换（Aggregation Transformation 简称A-Trans）：通过将多个小算子聚合为一个大算子，提升硬件利用率以优化性能，代价是暂时增加内存占用。</p><p>（2）中间变换（Interim Transformation 简称I-Trans）：利用代数等价性，为其他图变换创造机会。</p><p>作者发现一种新的中间变换–分裂变换（Split Transformation 简称S-Trans），它可以将一个大算子分裂为多个小算子，从而减少中间张量的形状规模，在降低硬件利用率的代价下有效减少内存占用。</p><h3 id="核心挑战">核心挑战</h3><p>（1）F-Trans带来的复杂度问题：一方面F-Trans会导致计算图规模急速增长，这会阻碍后续优化，另一方面F-Trans本身的搜索空间极为庞大，因为几乎可应用与计算图中的所有子图</p><p>（2）图变换与图调度的关联性问题: 图变换设计内存与性能之间的权衡（如A-Trans与S-Trans），而图调度则关注计算与内存的平衡。这使得图变换与图调度的协调变得至关重要，以实现最优的内存优化效果。</p><h4 id="第一个挑战">第一个挑战</h4><p>为了应对第一个挑战，作者提出了MAGIS，一个通过协调图变换与图调度的DNN内存优化框架。</p><p>针对F-Trans的复杂度问题，提出了分裂层次树（Fission Hierarchy Tree），用于表示F-Trans后的计算图结构，并且无需将计算图实际转换为复杂结构。</p><p>这种设计在一定程度上限制了搜索空间，但它显著降低了优化复杂度，使后续的变换与调度更易搜索到更优解。</p><p>此外作者提出了解析方法（analytic methods）,用于筛选适合F-Trans的子图，从而构建轻量级FTree。</p><h4 id="第二个挑战">第二个挑战</h4><p>为了应对第二个挑战，作者的核心目标是降低每次图变换步骤后图调度的复杂度</p><p>（1）将<strong>重计算</strong>与<strong>换入换出</strong>这两种调度技术拆解为<strong>图变换</strong>与<strong>重排序</strong>两个环节。<br>其中重计算与换入换出是以性能换内存的关键调度技术，而重排序是“无性能损耗的内存优化”调度方法。<br>这样的处理使得<strong>内存-性能权衡</strong>完全转移到图变换阶段，调度阶段仅需要关注重排序以实现内存优化。</p><p>（2）设计增量调度算法，以降低每次图变换步骤后的图调度复杂度。</p><h3 id="作者的贡献">作者的贡献</h3><p>（1）设计并实现了MAGIS，一个通过协调图变换与图调度的DNN内存优化框架。<br>（2）将图裂变变换形式化，基于层次树对其进行表示，并通过图分析缩减其搜索空间。<br>（3）提出了能高效协同图变换与图调度的增量调度算法，以降低每次图变换步骤后的图调度复杂度。</p><p>作者实验表明：MAGIS 能将原始峰值内存优化至 15%到50%，且延迟开销不超过 10%；与最先进方法相比，在相同延迟约束下，MAGIS 可将峰值内存进一步优化至这些方法的 15%到85%；在相同内存约束下，MAGIS 的速度比它们快 1.25 倍，在 “内存 - 延迟” 双目标优化中实现了更优的帕累托边界（Pareto boundary）。</p><h2 id="动机">动机</h2><p>合理的图变换同样能提升计算图的内存利用效率，通过拆分算子，可以在<strong>增加算子调用次数，降低硬件利用率</strong>的代价下，减少峰值内存占用。借助图变换，深度神经网络的内存优化效果能得到显著增强。</p><p>图 2 (a) 展示了一种在 DNN 训练或 “含长跳跃连接（long skip-connections）的 DNN”[23, 44, 73, 75] 中常见的简化图结构。该结构的峰值内存占用为 1056（单位可理解为 “数据类型字节数归一化后的张量大小”）—— 这是因为在计算第 33 个算子时，有 33 个大小为 32 的张量同时处于 “存活状态”，远超 100 的内存限制。</p><p>在图 2 (b) 中，尽管仅通过图调度（将暂时不用的张量换入外部存储）可将内存占用控制在 100，但数据传输过程会导致显著的延迟增加。</p><p>然而，如图 2 (d) 所示，当引入图变换后，不仅能节省更多内存，还可通过 “异步换入换出（asynchronous swapping）” 隐藏数据传输延迟。在此场景下，尽管硬件利用率有所下降，但延迟损失可通过异步换入换出带来的效率提升得到补偿。</p><p>作者将上述的变换命名为分裂变换，它是聚合变换的对偶形式，通过拆分算子有效优化内存占用。</p><p>但是现有基于“规则的子图替换”的图变换方法无法直接用于F-Trans，主要原因有：</p><p>（1）F-Trans会导致计算图规模急速增长，这会阻碍后续优化。<br>（2）F-Trans本身的搜索空间极为庞大，因为几乎可应用与计算图中的所有子图。</p><p>此外将图变换与图调度相协同，对于通过图变换实现内存优化至关重要。<br>（1）过细粒度的算子拆分，会导致高昂的性能代价<br>（2）将图调度与图变换性能，共同平衡各自的内存-性能权衡，不仅能降低内存占用，而且实现更短的延迟。</p><h2 id="系统框架">系统框架</h2><h3 id="m-state">M-State</h3><p>存储优化过程中的所有状态信息，包括计算图、分裂层次树和最优调度方案，以及模拟与硬件profiling结果，其中F-Tree用于表示分裂变换的层次化搜索空间。</p><p>当节点标记为 n = 1时，代表该节点对应“可进行F-Trans的潜在子图与维度候选”<br>当节点标记为 n &gt; 1时，代表该节点对应“已通过F-Trans沿某一维度拆分为n个部分的子图”</p><h3 id="m-analyzer">M-Analyzer</h3><p>通过根据计算图构建分裂层次树，生成分裂变换的搜索空间</p><h3 id="m-optimizer">M-Optimizer</h3><p>协调图变换与图调度，实现延迟与内存的联合优化</p><h3 id="m-rules">M-Rules</h3><p>为M-Optimizer提供各类变换规则</p><p>（1）现有研究中使用的TASO规则<br>（2）F-Tree突变规则（用于操作 F-Tree，以反映 F-Trans 在计算图上的实际应用）<br>（3）“基于调度的规则”（由图调度技术拆解而来，如重计算、换入换出对应的变换规则）</p><h2 id="m-analyzer">M-Analyzer</h2><p>本节首先介绍维度图（D-Graph），并基于它定义分裂变换（F-Trans）。随后定义F-Tree（分裂层次树）作为F-Trans优化空间/状态的抽象表示，并给出一种轻量级F-Tree构建算法，该算法仅针对基于支配树和内存热点筛选出的子图考虑F-Trans</p><h3 id="维度图">维度图</h3><p>F-Trans的本质是沿着子图的某一个维度，拆分该子图，因此提出维度图(D-Graph来识别计算图中的图级维度)</p><p>给定计算图G，其中算子\v \in V(G)\的输出张量包含\s_v\个维度，其计算过程涉及\r_v\个归约轴（reduce-axes）。基于此，我们定义维度图\D = D(G)\如下：<br>（1）节点定义：对于每个算子(v \in V(G))，以及索引(i = -r_v, \dots, -2, -1, 1, 2, \dots, s_v)，存在节点(\langle v, i \rangle \in V(D))。（注：正索引(1,2,\dots,s_v)对应输出张量的维度；负索引(-1,-2,\dots,-r_v)对应计算过程中的归约轴）</p><p>（2）边定义：若u的第i个维度与v的第j个维度对应同一空间轴（spatial-axis），则维度图中存在边((\langle u, i \rangle, \langle v, j \rangle) \in E(D))；若u的第i个维度对应v计算过程中的第j个归约轴，则维度图中存在边((\langle u, i \rangle, \langle v, -j \rangle) \in E(D))。</p><p>示例：<br><img src="image-1.png" alt="alt text"></p><h3 id="f-trans">F-Trans</h3><p>计算图G的分裂变换F-Trans定义为三元组f = (S,D,n)其中：<br>（1）S⊆V(G)，待拆分的子图算子集合<br>（2）D：维度图，用于指定子图G[S]的拆分维度<br>（3）n∈N，代表F-Trans将S中的算子沿D中的维度拆分为n个部分</p><p>F-Trans 需满足以下三大约束条件（确保拆分后计算结果与原图等价，且无逻辑冲突）：<br>（1）弱连通性（Weakly Connected）：子图G[S]是弱连通的。（注：弱连通指忽略边的方向后，子图内所有算子通过依赖关系连成一个整体，无孤立算子）；</p><p>（2）凸性（Convex）：子图(G[S])满足凸性，即(G.\text{inps}(S) ∩ \bigcup_{v∈G.\text{outs}(S)} G.\text{des}(v) = ∅)。（注：(G.\text{inps}(S))是子图S的外部输入张量，(\bigcup G.\text{des}(v))是子图S输出张量的所有后代算子；该约束意为 “子图的外部输入张量不会被子图输出的后代算子使用”，避免拆分后输入张量被提前释放）；</p><p>（3）无冗余计算（No Redundant Computation）：拆分后的图无冗余计算，需满足两个条件：对所有(v ∈ S)，存在唯一整数i，使得(\langle v, i \rangle ∈ V(D))（即每个待拆分算子仅沿D指定的一个维度拆分，避免多维度拆分导致的冗余）；对所有((u, v) ∈ E(G[S]))（子图内的算子依赖边），存在整数(i, j)，使得(\langle u, i \rangle, \langle v, j \rangle ∈ E(D))（即子图内算子的依赖关系在维度图中存在对应边，确保拆分后依赖链不中断）。</p><p>给定计算图G的F-Trans f = (S,D,n),拆分后的结果图包含n个子图G[s]的拆分部分，对于拆分部分的输入与输出，需按以下规则处理：</p><p>（1）输入张量处理：对于任意的u∈G.input(S)(子图S的外部输入)<br>1.若存在正整数i使得(\langle u, i \rangle ∈ V(D))（即u需沿D指定的维度拆分），则u会被 “切片（sliced）” 为(𝑛)份，每个拆分部分使用其中一份；</p><p>2.若不存在上述i（即u无需拆分，如模型权重），则u被所有拆分部分共享</p><p>（2）输出张量处理：对于任意的v∈G.output(S)(子图S的外部输出)<br>1.若存在负整数i使得(\langle v, i \rangle ∈ V(D))（即v需沿D指定的维度拆分），则v会被 “合并（merged）” 所有拆分部分的对应输出得到。<br>2.若不存在上述i（即v是归约结果，如梯度），则v通过归约所有拆分部分的输出得到（如求和、求平均)</p><h3 id="分裂层次树">分裂层次树</h3><p>直接将分裂变换应用于计算图会显著增加图的复杂度，尤其是当分裂数量n较大时。由于每次F-Trans会将图拆分为若干个同构子图，所以只需要保存其中一个子图即可。</p><p>为此不直接修改原始计算图，而是构建分裂层次树(Fission Hierarchy Tree)，F-Tree中的每个树节点记录一个F-Trans三元组（S,D,N），对于任意树节点f = (S,D,N)及其父节点f’ = （S’,D’,n’）满足S⊆ 𝑆′（即子节点的待拆分算子集合是父节点集合的子集）</p><p>图 3 展示了一个 F-Tree 实例：左侧计算图中每个虚线框包围的子图对应 F-Tree 的一个节点，节点旁的𝑛值为分裂数量。当𝑛 = 1 时，该节点表示 “可进行分裂的候选子图”；当𝑛 &gt; 1 时，该节点表示 “已通过 F-Trans 拆分为𝑛个部分的子图”。</p><p>然而，计算图𝐺上 F-Trans 的搜索空间仍然很大 —— 由于几乎所有凸子图都可作为分裂候选，搜索空间规模可达𝑂(2^|V (G)|²)。事实上，随意应用 F-Trans 并不能保证峰值内存降低，只有当 F-Trans 针对包含内存热点（memory hot-spots）的子图时（§2.1），才能实现有效的内存节省。</p><h4 id="内存热点分析">内存热点分析</h4><p>对于计算图G的分裂变换F-Trans f = (S,D,n),设内存热点为H,子图S的外部输入为I = G.inps(S)。</p><p>M0和Mf分别表示F-Trans前后的峰值内存使用量。由于执行拆分后的子图时，输入I需驻留内存，Mf应将I中所有张量的大小v∈I |v|求和考虑在内，与S之外的内存热点大小合并在一起。</p><p><img src="image-2.png" alt="alt text"></p><p>要是内存热点减少量更大，需要满足至少两个条件：S包含更多的内存热点，且I的内存消耗更小。</p><p>为了最小化F-Trans的输入内存占用，可以选择一个节点，并将其支配的子图作为分裂候选，确保该子图仅有一个入口节点。</p><h4 id="内存热度">内存热度</h4><p>表示一个节点支配的子图中所有热点的总大小，给定计算图G及其支配树T = T(G)，以及内存热点H，节点v的支配热度定义为：H∩T.des(v)是被V支配的内存热点<br>heat(v) = w∈H∩T.des(v) |w|求和。</p><p>在此基础上，为每个节点v分配一个评分（Score），用于估计对v支配的子图应用F-Trans后的潜在内存峰值减少量–第一项是内存热点的减少量，第二项是F-Trans后每个拆分部分执行时需驻留的输入节点大小，通常设n=2，以确保将子图拆分为两部分也能产生收益。</p><p>score(v) = (1-1/n)heat(v) - u∈G.inps（T.des(v)）\H |u|求和。</p><h3 id="构建f-tree算法">构建F-Tree算法</h3><p>核心思想：将具有不同评分的节点划分到不同区间–评分越高，意味着F-Trans的峰值内存减少量越大，但可能伴随着更大的延迟开销。超参数L控制区间数量和F-Tree的最大层级</p><p>该算法输入计算图G和最大层级L，具体步骤如下：</p><p>（1）迭代维度的D（G）的联通分量。<br>（2）提取子图G’及其支配树T。<br>（3）计算节点评分<br>（4）得到最大评分Smax之后，将区间[0,1]等分为L个区间，每个区间的宽度为1/L。<br>（5）根据归一化分配s[v]/Smax，在不同区间中选择节点<br>（6）从这些节点支配的子图中生成分裂候选<br>（7）最终基于这些子图构建F-Tree</p><h2 id="m-rules">M-Rules</h2><p>由算法构建的初始F-Tree中，所有树节点f = (S,D,n)的n值均为1，这类节点被称作未激活节点。</p><p>其对应的子图尚未执行F-Trans；n&gt;1的节点称为已激活节点，表示其对应的子图已执行F-Trans，并拆分为n个部分。</p><h3 id="裂变规则">裂变规则</h3><p>F-Tree突变规则的核心作用是修改F-Tree节点的n值，从而间接在计算图上应用F-Trans。这类规则有四：<br>（1）激活规则：激活F-Tree中未激活的节点或“无已激活祖先的已激活节点的父节点”<br>（2）提升规则：禁用“无已激活祖先的已激活节点”，并激活其对应的父节点。<br>（3）禁用规则：禁用“无已激活后代节点的已激活节点”<br>（4）突变规则：将已激活节点的分裂数量n增大到“能整除对应维度长度的下一个数值”</p><p>借助M-Analyzer与上述规则，可以将F-Trans解耦为“优化前阶段的F-Tree构建”与“优化中阶段的F-Tree突变”，两大环节。优化过程会优先激活叶节点，再逐步向靠近根节点的方向靠近。</p><p>这是因为对靠近根节点的节点应用分裂，会对内存与延迟产生更大影响；而从叶节点开始操作，能实现更小的突变步长与更平滑的搜索过程。</p><h3 id="调度规则">调度规则</h3><p>额外引入两个算子，存储(Store)和加载（Load），表示图调度的换入换出行为。</p><p>（1）重计算规则：将算子A的多个消费者之一B分离出来，使其使用重计算的算子A’（即重新执行A生成结果供B使用。<br>（2）去重计算规则：重计算规则的逆操作，将两个同类型、同输入的算子A和A’合并为单个算子。<br>（3）换入换出规则：在算子A与其消费者B之间插入Store和Load算子，表示A的输出先被换出到外部存储，待B需要时再换入。<br>（4）去换入换出规则：换入换出规则的逆操作，移除两个算子之间的Store和Load算子。</p><p>借助上述规则，图调度可拆解为图变换和重排序两个环节</p><p>（1）变换阶段：决定哪些算子需要重计算/换入换出；<br>（2）重排序阶段：决定何时执行换入换出算子，以最小化内存峰值。</p><p>由此，内存与延迟的权衡决策可转移至图变换阶段，而图调度阶段仅需处理 “重排序”（通常不影响总执行延迟）。这种拆解使 “每次图变换后的调度工作” 大幅简化。<br>启发式策略：由于重计算规则和换入换出规则几乎可应用于任何算子，可能导致搜索空间过大、优化速度减慢。因此，在实际子图模式匹配过程中，可选择性应用这两类规则，过滤掉 “不包含内存热点的子图”。</p><h2 id="m-optimizer">M-Optimizer</h2><p>包含增量调度–利用突变子图的信息和先前的调度结果，为变换后的图生成最优调度<br>顶层搜索算法–基于内存和延迟对M状态，进行优先级排序，并利用M-Rules对当前最优的M状态进行变换，以生成新的M状态。</p><h3 id="增量调度">增量调度</h3><p>要获取计算图的内存占用与性能数据，需执行图调度。然而每次图变换都进行全量图调度开销极高，为解决这一个问题，作者设计了增量调度算法–基于先前的调度结果与上一次图变换影响的子图范围，确定需重新调度的图子集。</p><p>（1）通过GetRescheduleInterval函数，获取原始图中需重新调度的算子序列。<br>（2）在新图中，为该算子序列找到对应的子图Snew。<br>（3）调用GraphPartition函数，将Snew划分为多个可独立调度的子图<br>（4）采用现有研究中基于动态规划的算法，对每个子图执行调度。<br>（5）合并各子图的调度结果，形成新图的完整调度，并于原始图的调度结果整合。</p><p>GetRescheduleInterval是算法2的核心步骤，其目标是“找到原始调度中需要重新调度的区间”该区间的选择需平衡优化质量与时间成本。</p><p>（1）区间过小：导致重新调度的结构次优甚至错误<br>（2）区间过大：会增加重新调度的时间开销，失去增量的意义。</p><p>为解决这一问题，作者引入节点的窄腰值，对于计算图G的节点v∈V(G)，其窄腰值定义为：</p><p>(\text{nw}(v) = |V(G)| - |G.\text{anc}(v)| - |G.\text{des}(v)| - 1)</p><p>窄腰值的核心作用是衡量与给定节点v无关的节点数量</p><p>（1）nw(v)越低：说明依赖v的节点和v依赖的节点越多，v是拓扑排序问题中合适分割点。<br>（2）分割逻辑：所有依赖v的节点需在v之后调度，所有v依赖的节点需在v之前调度 —— 这为调度问题提供了 “天然划分”，确保分割后的子图可独立优化；<br>(3) 优化质量保证：若分别对v的祖先和v的后代找到最优调度，最终峰值内存可保证不超过(M_{\text{opt}} + \sum_{v \in V(G) \setminus G.\text{anc}(v) \setminus G.\text{des}(v)} |v|)<br>(4)完全独立条件：若nw(v) = 0,则计算图的调度问题可在v处·拆分为两个完全独立的子问题，子图调度结果互不影响。</p><p>作者基于窄腰值设计了启发式算法，用于选择边界窄腰值尽可能小的调度区间。其中常数20、10、4是实际场景中验证有效的经验超参数。</p><p>GraphPartition函数的核心思路是：以nw(v)≤1的节点作为分割点，将给定途中的每个联通分量划分为多个可独立调度的子图。</p><h3 id="顶层搜索算法">顶层搜索算法</h3><p>MAGIS采用贪心搜索算法，对计算图进行优化，支持两种优化模式</p><p>（1）给定内存限制，优化延迟<br>（2）给定延迟限制，优化内存</p><p>第一种搜索流程的输入包括：计算图G、给定的内存限制M、F-Tree最大层级L，具体步骤如下：</p><p>（1）对输入图执行调度与分析，生成初始M-State<br>（2）构建用于存储M-State的优先级队列，队列优先级由BetterThan函数决定：<br>-若两个M-State均满足内存限制M，则优先比较延迟<br>-若不满足内存限制，则优先比较内存</p><ul><li>注：比较采用字典序（lexicographical order），即((a, b) &lt; (c, d))表示 “若(a &lt; c)，则整体 更小；若(a = c)，则比较(b &lt; d)”（(a/c)为延迟，(b/d)为内存）。</li></ul><p>（3）迭代执行以下步骤：</p><ol><li>从优先级队列中弹出当前最优的M-State μ</li><li>调用Analyze函数，若μ中先前的突变子图未受F-Trans影响，则更新μ中的F-Tree</li><li>应用M-Rules，生成一系列新的M-State μ’</li><li>对新生成的μ’执行增量调度，评估其延迟与内存。</li><li>若μ’在放松条件下不劣于当前最优状态μbest，则将μ’加入游侠牛队列。</li></ol><p>避免冗余搜索：借鉴魏斯费勒 - 莱曼测试（Weisfeiler-Lehman Test） [48] 的思想，对计算图进行哈希（第 5-8 行、第 12-14 行），其中 “⊕” 表示字节拼接操作（将图结构与状态信息拼接生成唯一哈希值），相同哈希的 M-State 视为 “结构重复”，不重复入队；</p><p>性能测量优化：为降低性能测量开销，实现带有 “算子性能缓存” 的模拟器 —— 该缓存保存算子的实际执行延迟，模拟器通过调度信息计算全图的整体性能（延迟）与内存占用。</p><p>需特别说明：当考虑异步换入换出（asynchronous swapping） 时，涉及 Store/Load 算子的重排序会对延迟产生轻微影响。为应对这一问题，我们的重排序策略是：尽可能早地放置 Store 算子（尽早释放内存），同时尽可能晚地放置 Load 算子（确保数据传输延迟刚好被隐藏）。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存优化 </tag>
            
            <tag> 图调度 </tag>
            
            <tag> 图优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133克隆图</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>133克隆图</h1><h2 id="题目描述">题目描述</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。<br>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><p>class Node{<br>int val;<br>List<Node> neighbors;<br>}</p><h2 id="测试用例格式">测试用例格式</h2><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（val = 1），第二个节点值为2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。<br>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为1）。你必须返回给定节点的拷贝作为对克隆图的引用。</p><h2 id="解题思路">解题思路</h2><p>要解决无向连通图的深拷贝问题，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。</p><p>核心思路是创建每个节点的副本，并正确复制节点之间的连接关系</p><h3 id="核心思路">核心思路</h3><p>（1）使用DFS遍历图的每个节点<br>（2）使用哈希表map存储每个节点的原值和复制值，避免重复复制<br>（3）递归地复制每个节点的邻居</p><h3 id="实现步骤">实现步骤</h3><p>（1）首先处理空节点的情况<br>（2）在哈希表中寻找目标节点，若有则直接返回其复制值<br>（3）若没有则先复制当前节点，将其存储到哈希表中<br>（4）递归地复制当前节点的邻居</p><h3 id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(node)!=map.<span class="built_in">end</span>()) <span class="keyword">return</span> map[node];</span><br><span class="line">        Node* clone=<span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        map[node]=clone;</span><br><span class="line">        <span class="keyword">for</span>(Node* n:node-&gt;neighbors)&#123;</span><br><span class="line">            clone-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><p>时间复杂度：O(N)，其中 N 是图中节点的数量。每个节点只会被访问一次。<br>空间复杂度：O(N)，其中 N 是图中节点的数量。哈希表和递归栈的空间复杂度均为 O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134加油站</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1>134加油站</h1><h2 id="题目描述">题目描述</h2><p>在一条环路上有n个加油站，其中第i个加油站有汽油gas[i]升。<br>假设你有一辆容量无限的汽车，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组gas和cost，如果你可以按顺序环绕环路行驶一周，则返回出发时加油站的编号，否则返回-1。</p><p>如果存在解，保证他是唯一的。</p><h2 id="题目分析">题目分析</h2><p>（1）注意到若总花费大于总油量，则一定不存在解。<br>（2）存在线性解法寻找具体的起始点：<br>a.从第一个起始点开始，逐渐累积油量，若油量小于0，则从下一个加油站开始。<br>b.重置当前油量<br>c.遍历结束时，当前的起始点即为解。</p><h2 id="有效性分析">有效性分析</h2><p>（1）为什么要从下一个加油站开始？<br>（2）若从第i个加油站开始，到第j个加油站油量小于0，则从第i+1个加油站开始到第j个加油站油量也一定小于0。<br>（3）因为这过程中存在这油量累积现象。</p><h2 id="代码思路">代码思路</h2><p>（1）初始化总油量，当前油量和起始点为0<br>（2）遍历每一个加油站，更新总油量，当前油量。<br>（3）若当前油量小于0，<br>a.更新起始点为下一个加油站<br>b.重置当前油量<br>（4）遍历结束后，判断总油量是否大于等于0，若大于等于0，则返回起始点，否则返回-1。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    pubilc:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas,vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> totalRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> currentRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                totalRank+=gas[i]-cost[i];</span><br><span class="line">                currentRank+=gas[i]-cost[i];</span><br><span class="line">                <span class="keyword">if</span>(currentRank&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    start = i<span class="number">+1</span>;</span><br><span class="line">                    currentRank = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalRank&gt;=<span class="number">0</span>?start:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>时间复杂度：O(n)，遍历所有的加油站一次<br>空间复杂度：O(1)，只使用了常数个变量</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cast算子开发</title>
      <link href="/2023/12/15/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/cast/"/>
      <url>/2023/12/15/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/cast/</url>
      
        <content type="html"><![CDATA[<h1>Cast算子开发：基于TIR的类型转换算子构建技术解析</h1><h2 id="摘要">摘要</h2><p>类型转换（Cast）是深度学习框架与编译器中的核心基础算子，负责实现张量在不同数据类型（如FP32→FP16、INT8→FP32）间的精度转换，是模型量化加速、跨层数据兼容的关键组件。本文以一段基于张量中间表示（Tensor Intermediate Representation, TIR）的Cast算子构建代码为研究对象，从技术背景、代码模块解析、设计亮点与应用场景四个维度，深入剖析算子构建过程中的IR设计、循环调度、图拓扑绑定等核心技术，揭示底层算子开发中“动态形状支持”“数据并行优化”“模块化集成”的实现逻辑，为自定义算子开发与编译器中间表示优化提供参考。</p><h2 id="1-引言">1 引言</h2><p>在深度学习框架（如TensorFlow、PyTorch）与专用AI编译器（如TVM、MindSpore）中，算子是计算逻辑的最小执行单元，而TIR作为连接算子定义与硬件代码生成的“桥梁”，承担着抽象计算逻辑、支持调度优化的核心角色。类型转换算子看似简单，但其实现需解决三大核心问题：</p><ol><li><strong>动态形状适配</strong>：如何支持编译时未知的张量维度（如动态Batch Size）；</li><li><strong>并行性挖掘</strong>：如何设计循环结构以适配CPU多核、GPU等硬件的并行计算能力；</li><li><strong>图拓扑集成</strong>：如何将算子与计算图的输入输出参数绑定，确保数据流向正确性。</li></ol><p>本文解析的代码正是围绕上述问题展开，实现了一个可复用、高扩展性的Cast算子构建流程，其核心价值在于为自定义TIR算子开发提供了“参数解析→计算定义→调度优化→图集成”的完整模板。</p><h2 id="2-技术背景：tir与算子构建流程">2 技术背景：TIR与算子构建流程</h2><p>在深入代码前，需明确两个核心概念的定位，为后续解析奠定基础：</p><table><thead><tr><th>概念</th><th>核心作用</th></tr></thead><tbody><tr><td>TIR</td><td>张量计算的中间表示，抽象了张量元信息（类型、形状）、计算逻辑与调度策略，是代码生成的输入</td></tr><tr><td>OperatorGraph</td><td>计算图拓扑结构，记录算子间的依赖关系与数据流向，算子需绑定到图节点以参与端到端执行</td></tr></tbody></table><p>算子构建的通用流程可概括为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[参数解析（输入输出类型/形状、图节点信息）] --&gt; B[创建输入占位符张量（TIR层）]</span><br><span class="line">    B --&gt; C[设计循环变量（并行性定义）]</span><br><span class="line">    C --&gt; D[定义计算逻辑（算子核心功能）]</span><br><span class="line">    D --&gt; E[创建调度对象（优化接口预留）]</span><br><span class="line">    E --&gt; F[封装算子函数与图节点]</span><br><span class="line">    F --&gt; G[添加约束（如维度范围）]</span><br><span class="line">    G --&gt; H[绑定算子与计算图参数]</span><br></pre></td></tr></table></figure><p>下文代码解析将严格遵循此流程，逐一拆解各环节的实现细节。</p><h2 id="3-代码深度解析：cast算子的完整构建过程">3 代码深度解析：Cast算子的完整构建过程</h2><p>本节以代码执行流程为线索，逐模块解析实现逻辑，重点说明“为什么这么设计”而非仅“做了什么”，挖掘底层技术考量。</p><h3 id="3-1-函数入口与参数初始化">3.1 函数入口与参数初始化</h3><p>代码入口函数<code>create_cast_operator</code>接收两个核心参数：<code>TIR&amp; tir</code>（全局TIR上下文，用于存储算子）与<code>FuncParams* FuncParams</code>（算子构建所需的参数集合），首先完成图节点与名称的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OperatorGraphFuncNode* <span class="title">create_cast_operator</span><span class="params">(TIR&amp; tir, FuncParams* FuncParams)</span> </span>&#123;</span><br><span class="line">    Node* node = FuncParams-&gt;node;</span><br><span class="line">    string node_name = node-&gt;_simple_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入和输出数据类型</span></span><br><span class="line">    string input_datatype = FuncParams-&gt;input_data_types[<span class="number">0</span>];</span><br><span class="line">    string output_datatype = FuncParams-&gt;output_data_types[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ol><li><p><strong>图节点关联（<code>Node* node</code>）</strong>：</p><ul><li><code>FuncParams-&gt;node</code>指向计算图中的一个节点，<code>node_name</code>从节点的<code>_simple_name</code>获取，确保算子与图节点的“一一对应”，避免拓扑结构混乱。</li><li>设计考量：在多算子协作的计算图中，算子名称需与图节点名称一致，否则后续数据流向追踪与调试将无法进行。</li></ul></li><li><p><strong>输入输出类型获取</strong>：</p><ul><li>从<code>FuncParams-&gt;input_data_types[0]</code>与<code>output_data_types[0]</code>分别获取源类型与目标类型（此处假设单输入单输出，可扩展至多输入），这是Cast算子的“核心配置”——决定了转换的精度方向（如<code>float32</code>→<code>float16</code>）。</li><li>潜在扩展：若需支持多输入转换（如广播场景下的多张量同精度转换），可通过循环遍历<code>input_data_types</code>实现。</li></ul></li></ol><h3 id="3-2-动态形状处理：符号表达式的构建">3.2 动态形状处理：符号表达式的构建</h3><p>张量形状是算子的核心元信息，代码中通过“符号表达式”支持编译时未知的动态维度（如NLP任务中的变长序列长度）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取输入形状（支持符号表达式）</span></span><br><span class="line">vector&lt;ScalarExpr&gt; input_shapes_expr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> dim : FuncParams-&gt;input_shapes[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dim == <span class="number">-1</span>) dim++;  <span class="comment">// 处理动态维度标记（-1→0，符号化表示）</span></span><br><span class="line">    input_shapes_expr.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">ScalarExpr</span>(<span class="keyword">new</span> <span class="built_in">Var</span>(<span class="string">&quot;X_dim_&quot;</span> + <span class="built_in">to_string</span>(dim + <span class="number">1</span>), <span class="string">&quot;int32&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ol><li><p><strong>动态维度标记处理（<code>dim == -1</code>）</strong>：</p><ul><li>工业界框架中常用<code>-1</code>表示“动态维度”（如PyTorch的<code>torch.randn(-1, 256)</code>），此处<code>dim++</code>将<code>-1</code>转为<code>0</code>，并非改变维度值，而是为后续符号变量命名（如<code>X_dim_1</code>）提供合法索引，避免负号导致的命名异常。</li><li>设计考量：动态维度无法在编译时确定，需通过“符号变量（Var）”抽象，而非具体数值，确保算子适配任意合法维度。</li></ul></li><li><p><strong>符号形状表达式（<code>ScalarExpr</code>与<code>Var</code>）</strong>：</p><ul><li>每个维度通过<code>new Var(...)</code>创建符号变量，名称格式为<code>X_dim_&#123;idx&#125;</code>（如第一个维度为<code>X_dim_1</code>），类型为<code>int32</code>（维度值为整数）。</li><li>技术价值：符号表达式是TIR支持“动态形状编译”的核心——编译器可基于符号变量进行循环边界分析、内存分配估算（如<code>X_dim_1 * X_dim_2 * sizeof(input_datatype)</code>），无需依赖具体维度数值。</li></ul></li></ol><h3 id="3-3-输入张量创建：占位符的抽象表示">3.3 输入张量创建：占位符的抽象表示</h3><p>基于上述符号形状，代码创建输入张量<code>X</code>，作为TIR层的抽象输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输入张量 X</span></span><br><span class="line">Expr X = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_placeholder</span>(<span class="string">&quot;X&quot;</span>, input_datatype,</span><br><span class="line">                                           <span class="built_in">Shape</span>(input_shapes_expr)));</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ul><li><strong>占位符张量（Placeholder）</strong>：<ul><li><code>create_tensor_by_placeholder</code>函数创建的张量不包含具体数据，仅存储三大元信息：<ol><li>名称（<code>&quot;X&quot;</code>）：用于计算逻辑中引用该张量；</li><li>数据类型（<code>input_datatype</code>）：与前文获取的源类型一致；</li><li>形状（<code>Shape(input_shapes_expr)</code>）：基于符号表达式的动态形状。</li></ol></li><li>本质：占位符是TIR中“输入端口”的抽象，后续计算逻辑（如Cast）需通过该占位符关联输入数据，确保计算依赖的正确性。</li></ul></li></ul><h3 id="3-4-循环变量设计：数据并行的显式定义">3.4 循环变量设计：数据并行的显式定义</h3><p>循环是张量计算的核心执行载体，代码中为每个维度创建循环变量，并指定为“数据并行”类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建循环变量</span></span><br><span class="line">vector&lt;Expr&gt; loopvars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; input_shapes_expr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    loopvars.<span class="built_in">push_back</span>(<span class="built_in">Expr</span>(<span class="built_in">create_loopvar</span>(</span><br><span class="line">        <span class="string">&quot;i&quot;</span> + <span class="built_in">to_string</span>(i),  <span class="comment">// 循环变量名（如i0, i1）</span></span><br><span class="line">        <span class="string">&quot;int32&quot;</span>,             <span class="comment">// 类型</span></span><br><span class="line">        <span class="built_in">Range</span>(<span class="number">0</span>, input_shapes_expr[i]),  <span class="comment">// 范围：[0, 维度大小)</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, </span><br><span class="line">        LoopVarType::DataPar  <span class="comment">// 数据并行类型</span></span><br><span class="line">    )));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ol><li><p><strong>循环变量与维度的映射</strong>：</p><ul><li>每个维度对应一个循环变量（如2D张量对应<code>i0</code>（行）、<code>i1</code>（列）），循环范围为<code>[0, 维度大小)</code>，与张量的索引逻辑一致（如<code>X[i0][i1]</code>表示2D张量的元素）。</li></ul></li><li><p><strong>数据并行类型（<code>LoopVarType::DataPar</code>）</strong>：</p><ul><li>这是循环设计的核心亮点：<code>DataPar</code>标记表明该循环的迭代可“并行执行”（无数据依赖），编译器可基于此标记进行优化：<ul><li>CPU：自动拆分为多线程，绑定不同核心执行不同迭代；</li><li>GPU：映射为线程块（Block）或线程（Thread），利用SIMT架构并行计算；</li></ul></li><li>对比：若为<code>LoopVarType::Seq</code>（串行），则循环需按顺序执行，无法利用硬件并行能力。</li></ul></li></ol><h3 id="3-5-计算逻辑定义：cast算子的核心实现">3.5 计算逻辑定义：Cast算子的核心实现</h3><p>代码通过<code>create_tensor_by_compute</code>定义输出张量<code>Y</code>，并嵌入Cast计算逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行类型转换操作 Y[i] = cast(X[i], output_datatype)</span></span><br><span class="line">Expr Y = <span class="built_in">Expr</span>(</span><br><span class="line">    <span class="built_in">create_tensor_by_compute</span>(</span><br><span class="line">        <span class="string">&quot;Y&quot;</span>,                  <span class="comment">// 输出张量名</span></span><br><span class="line">        output_datatype,      <span class="comment">// 目标数据类型</span></span><br><span class="line">        <span class="built_in">Shape</span>(input_shapes_expr),  <span class="comment">// 输出形状与输入一致</span></span><br><span class="line">        Expr::<span class="built_in">assign</span>(loopvars, X[loopvars])  <span class="comment">// 计算逻辑</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ol><li><p><strong>计算张量（Compute Tensor）</strong>：</p><ul><li>与占位符张量不同，<code>create_tensor_by_compute</code>创建的<code>Y</code>是“计算型张量”，其值由输入张量<code>X</code>与计算逻辑决定，TIR会记录<code>Y</code>与<code>X</code>的依赖关系（<code>Y</code>依赖<code>X</code>）。</li></ul></li><li><p><strong>Cast逻辑的隐式表达</strong>：</p><ul><li>代码中<code>X[loopvars]</code>表示“输入张量在当前循环索引下的元素”，<code>Expr::assign(loopvars, X[loopvars])</code>看似是“赋值”，实则隐含了“类型转换”——因为<code>Y</code>的目标类型（<code>output_datatype</code>）与<code>X</code>的源类型（<code>input_datatype</code>）不同，TIR会在代码生成阶段自动插入类型转换指令（如CPU的<code>cvttss2si</code>、GPU的<code>cvt.f32.f16</code>）。</li><li>设计考量：通过“张量类型差异”隐式触发Cast，避免显式编写转换函数，简化代码同时保证兼容性（不同硬件的转换指令由TIR统一处理）。</li></ul></li></ol><h3 id="3-6-调度对象创建：优化接口的预留">3.6 调度对象创建：优化接口的预留</h3><p>调度（Schedule）是TIR中“性能优化”的入口，代码为<code>Y</code>的计算操作创建调度对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建调度</span></span><br><span class="line">Schedule* schedule = <span class="built_in">create_schedule</span>(Y.<span class="built_in">get_tensor</span>()-&gt;op);</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ul><li><strong>调度的作用</strong>：<ul><li><code>Y.get_tensor()-&gt;op</code>指向<code>Y</code>的计算操作（即Cast），<code>create_schedule</code>为该操作创建调度对象，后续可通过该对象添加优化策略：<ul><li>循环展开（Loop Unrolling）：减少循环控制开销；</li><li>循环融合（Loop Fusion）：若后续有算子依赖<code>Y</code>，可将多循环融合为一个，减少内存访问；</li><li>内存布局优化（如将NHWC转为NCHW，适配GPU纹理内存）；</li></ul></li><li>代码中未显式添加优化，而是预留调度接口，体现“模块化设计”——算子逻辑与优化策略分离，便于后续根据硬件特性调整调度。</li></ul></li></ul><h3 id="3-7-算子与图节点封装：逻辑与拓扑的绑定">3.7 算子与图节点封装：逻辑与拓扑的绑定</h3><p>代码将计算逻辑（调度）与图节点封装，确保算子可被计算图调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建算子函数和图节点</span></span><br><span class="line">OperatorFunc* cast_func = <span class="keyword">new</span> <span class="built_in">OperatorFunc</span>(node_name, schedule);</span><br><span class="line">OperatorGraphFuncNode* cast_node = <span class="keyword">new</span> <span class="built_in">OperatorGraphFuncNode</span>(node_name, <span class="string">&quot;params_none&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ul><li><strong>双对象分离设计</strong>：<ul><li><code>OperatorFunc</code>：封装算子的“计算逻辑”与“调度策略”，是代码生成的核心单元；</li><li><code>OperatorGraphFuncNode</code>：封装算子在计算图中的“拓扑信息”（名称、参数标记），是图拓扑的组成单元；</li><li>设计优势：解耦计算逻辑与拓扑结构，若需复用Cast逻辑到不同图节点，仅需创建新的<code>OperatorGraphFuncNode</code>，无需重复定义<code>OperatorFunc</code>。</li></ul></li></ul><h3 id="3-8-未知变量约束：正确性与优化的保障">3.8 未知变量约束：正确性与优化的保障</h3><p>代码为符号维度变量添加范围约束，避免无效维度导致的计算错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加未知变量范围约束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; expr : input_shapes_expr) &#123;</span><br><span class="line">    cast_func-&gt;unknown_var_bound[expr.node-&gt;<span class="built_in">as</span>&lt;ExprVarNode&gt;()-&gt;var] =</span><br><span class="line">        <span class="built_in">Range</span>(<span class="number">1</span>, MAX_INF - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ul><li><strong>约束的必要性</strong>：<ul><li>符号变量（如<code>X_dim_1</code>）的范围若不限制，可能出现<code>0</code>或负维度（如<code>X_dim_1=0</code>将导致张量无元素，<code>X_dim_1=-2</code>为非法值），引发内存分配失败或计算空指针；</li><li>约束<code>Range(1, MAX_INF - 1)</code>确保维度为“正整数”，同时<code>MAX_INF - 1</code>避免溢出（兼容不同硬件的最大维度限制）；</li><li>技术价值：约束为编译器的“静态分析”提供依据，如内存分配时可确定“最小内存需求为<code>1 * sizeof(output_datatype)</code>”，避免过度分配。</li></ul></li></ul><h3 id="3-9-算子与图参数连接：数据流向的闭环">3.9 算子与图参数连接：数据流向的闭环</h3><p>最后，代码将算子节点与计算图的输出参数绑定，完成数据流向的闭环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接算子到图中的输出参数</span></span><br><span class="line">ConnectOperatorToGraphParams* connect_params = <span class="keyword">new</span> <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line">connect_params-&gt;node_name = node_name;          <span class="comment">// 关联图节点</span></span><br><span class="line">connect_params-&gt;output_datatype = output_datatype;  <span class="comment">// 输出类型</span></span><br><span class="line">connect_params-&gt;output_name = node-&gt;_outputs_name[<span class="number">0</span>];  <span class="comment">// 输出名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">connect_operator_to_graph</span>(tir, connect_params, cast_node);</span><br></pre></td></tr></table></figure><h4 id="关键设计解析：">关键设计解析：</h4><ul><li><strong>连接参数的作用</strong>：<ul><li><code>connect_params</code>封装了“算子→图”的绑定信息，核心是<code>output_name = node-&gt;_outputs_name[0]</code>——将算子的输出<code>Y</code>与图节点的输出端口名称关联，确保计算结果能传递到下一个算子的输入；</li><li><code>connect_operator_to_graph</code>函数是“胶水接口”，负责将<code>cast_node</code>（算子图节点）注册到<code>TIR</code>上下文，并更新计算图的拓扑依赖；</li><li>示例：若下一个算子是<code>Add</code>，其输入名称需与<code>node-&gt;_outputs_name[0]</code>一致，才能正确接收Cast算子的输出。</li></ul></li></ul><h2 id="4-核心设计亮点总结">4 核心设计亮点总结</h2><p>基于上述解析，该Cast算子代码的设计亮点可概括为以下五点，为自定义算子开发提供参考：</p><table><thead><tr><th>设计亮点</th><th>技术实现</th><th>核心价值</th></tr></thead><tbody><tr><td>动态形状支持</td><td>符号变量（Var）+  scalarExpr</td><td>适配动态Batch、变长序列等场景，提升通用性</td></tr><tr><td>数据并行显式化</td><td>LoopVarType::DataPar</td><td>为硬件并行优化提供标记，提升执行效率</td></tr><tr><td>逻辑与拓扑解耦</td><td>OperatorFunc与OperatorGraphFuncNode分离</td><td>算子逻辑可复用，降低开发成本</td></tr><tr><td>约束驱动的正确性保障</td><td>未知变量范围约束</td><td>避免非法维度，为静态分析与优化提供依据</td></tr><tr><td>模块化连接接口</td><td>ConnectOperatorToGraphParams</td><td>标准化算子与图的绑定流程，降低集成复杂度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算子开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算子开发 </tag>
            
            <tag> Cast </tag>
            
            <tag> TIR </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Concat算子开发</title>
      <link href="/2023/12/15/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/concat/"/>
      <url>/2023/12/15/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/concat/</url>
      
        <content type="html"><![CDATA[<h1>深度学习框架中Concat算子的TIR构建与实现：从理论到代码</h1><h2 id="摘要">摘要</h2><p>张量拼接（Concat）作为深度学习框架中最基础的算子之一，承担着多输入张量在指定维度上融合的核心功能。本文基于TIR（Tensor Intermediate Representation）中间表示，详细阐述Concat算子的构建流程，包括输入合法性校验、维度处理、符号计算图生成及调度优化等关键技术点。通过解析算子实现的底层逻辑，揭示深度学习框架中算子设计的通用性原则，为自定义算子开发提供方法论参考。</p><h2 id="引言">引言</h2><p>在深度学习模型中，张量的维度操作是构建复杂网络结构的基础。Concat算子通过在指定维度上拼接多个同秩张量，实现特征融合或维度扩展，广泛应用于残差连接、多尺度特征融合等场景。与Element-wise算子相比，Concat算子的实现需重点解决<strong>维度一致性校验</strong>、<strong>动态索引计算</strong>和<strong>符号形状推理</strong>三大核心问题。</p><p>本文基于某深度学习框架的TIR中间表示，从代码实现角度剖析Concat算子的构建过程。通过对输入校验、轴处理、计算图生成等模块的逐段解析，展现算子从抽象定义到具体执行的完整映射过程，并探讨其在性能优化中的潜在方向。</p><h2 id="背景知识：tir与算子构建框架">背景知识：TIR与算子构建框架</h2><p>在深度学习框架的编译流程中，TIR作为连接高层API与底层硬件执行的中间表示，承担着算子逻辑描述与优化的核心职责。一个典型的算子构建流程包括：</p><ol><li><strong>参数解析</strong>：提取算子输入张量、属性（如Concat的axis参数）及输出要求</li><li><strong>合法性校验</strong>：确保输入满足算子语义约束（如Concat要求非拼接维度一致）</li><li><strong>符号计算图生成</strong>：构建输入到输出的映射关系，通常以循环嵌套+条件判断形式表达</li><li><strong>调度优化</strong>：指定循环拆分、并行策略等，为代码生成提供优化信息</li><li><strong>图连接</strong>：将算子节点接入整体计算图，维护张量依赖关系</li></ol><p>本文实现的<code>create_concat_operator</code>函数正是遵循这一流程，完成Concat算子从参数到TIR表示的完整构建。</p><h2 id="concat算子的核心实现解析">Concat算子的核心实现解析</h2><h3 id="1-输入参数校验：保障算子语义正确性">1. 输入参数校验：保障算子语义正确性</h3><p>Concat算子的首要任务是确保输入满足基本语义约束，代码首先通过两层校验机制过滤非法输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验输入数量不少于2个（Concat的核心语义）</span></span><br><span class="line"><span class="keyword">if</span> (input_size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Concat operator requires at least two inputs.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验所有输入张量的秩（维度数量）一致</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; input_size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input_shapes_expr[i].<span class="built_in">size</span>() != num_dimensions) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;All inputs must have the same rank.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点</strong>：</p><ul><li>输入数量校验直接对应Concat算子的数学定义（至少两个张量才能拼接）</li><li>秩一致性校验确保拼接操作的维度基础一致，避免跨秩拼接的逻辑错误</li></ul><h3 id="2-拼接轴处理：支持负数索引与边界检查">2. 拼接轴处理：支持负数索引与边界检查</h3><p>拼接轴（axis）是Concat算子的核心参数，代码通过三重处理确保轴参数的有效性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理负数轴（转换为正数索引，如-1表示最后一个维度）</span></span><br><span class="line"><span class="keyword">if</span> (concat_axis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    concat_axis += num_dimensions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查轴范围有效性</span></span><br><span class="line"><span class="keyword">if</span> (concat_axis &lt; <span class="number">0</span> || concat_axis &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num_dimensions)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Concat axis is out of valid range.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>技术细节</strong>：</p><ul><li>负数轴处理借鉴Python的索引语法，提升API易用性（如在4维张量中，<code>axis=-1</code>等价于<code>axis=3</code>）</li><li>边界检查防止轴参数超出张量实际维度范围，减少运行时错误</li></ul><h3 id="3-维度一致性校验：非拼接维度的严格匹配">3. 维度一致性校验：非拼接维度的严格匹配</h3><p>Concat算子要求所有输入张量在非拼接维度上必须完全一致，代码通过逐维度比对实现这一约束：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查非拼接维度是否一致</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> dim = <span class="number">0</span>; dim &lt; num_dimensions; ++dim) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dim != concat_axis &amp;&amp;</span><br><span class="line">        input_shapes_expr[i][dim] != input_shapes_expr[<span class="number">0</span>][dim]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Non-concat dimensions must be equal for all inputs.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理论依据</strong>：<br>设输入张量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T_1, T_2, ..., T_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，形状分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_1, S_2, ..., S_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，拼接轴为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，则必须满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>d</mi><mo mathvariant="normal">≠</mo><mi>k</mi><mo>:</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">[</mo><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>S</mi><mi>j</mi></msub><mo stretchy="false">[</mo><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\forall i \neq j, \forall d \neq k: S_i[d] = S_j[d]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>。这一约束确保拼接后张量在非拼接维度上的连续性。</p><h3 id="4-符号形状计算：输出张量的形状推理">4. 符号形状计算：输出张量的形状推理</h3><p>输出张量的形状由&quot;拼接轴求和+非拼接轴保持&quot;原则确定，代码通过符号表达式实现动态形状计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建输出形状（符号表达式）</span></span><br><span class="line">vector&lt;ScalarExpr&gt; output_shape = input_shapes_expr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; input_size; ++i) &#123;</span><br><span class="line">    output_shape[concat_axis] =</span><br><span class="line">        output_shape[concat_axis] + input_shapes_expr[i][concat_axis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>符号计算优势</strong>：</p><ul><li>支持动态形状（如输入维度为变量而非常量时）</li><li>为后续自动微分、形状优化提供可追踪的符号信息</li><li>示例：若输入形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span>，axis=1，则输出形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,3+4)=(2,7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="5-计算逻辑生成：条件索引链的构建">5. 计算逻辑生成：条件索引链的构建</h3><p>Concat算子的核心计算逻辑是根据输出索引定位到对应输入张量的元素，代码通过循环变量与条件表达式链实现这一映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有输入，构建条件索引链</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; input_size; ++i) &#123;</span><br><span class="line">    <span class="comment">// 计算当前输入在拼接轴上的偏移范围</span></span><br><span class="line">    ScalarExpr end_offset = current_offset + input_shapes_expr[i][concat_axis];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建调整后索引（拼接轴减去偏移量）</span></span><br><span class="line">    vector&lt;Expr&gt; adjusted_indices = loopvars;</span><br><span class="line">    adjusted_indices[concat_axis] = loopvars[concat_axis] - current_offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建条件表达式：当前索引属于当前输入的偏移范围</span></span><br><span class="line">    Expr condition = (loopvars[concat_axis] &gt;= current_offset) &amp;&amp;</span><br><span class="line">                     (loopvars[concat_axis] &lt; end_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建if-else表达式链</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        concat_expr = input_expr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        concat_expr = Expr::if_then_else(condition, input_expr, concat_expr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    current_offset = end_offset; <span class="comment">// 更新偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑解析</strong>：</p><ul><li>对输出张量的每个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>i</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>i</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>k</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>i</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i_0, i_1, ..., i_k, ..., i_{n-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，通过拼接轴索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">i_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>判断其属于哪个输入张量</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>k</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>o</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>o</mi><mi>m</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i_k \in [o_{m-1}, o_m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>（其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">o_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个输入的累计偏移），则元素来自第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个输入，索引为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>i</mi><mn>0</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>i</mi><mi>k</mi></msub><mo>−</mo><msub><mi>o</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i_0, ..., i_k - o_{m-1}, ...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">)</span></span></span></span></li><li>条件表达式链实现了这一判断逻辑，确保每个输出元素正确映射到输入</li></ul><h3 id="6-调度与图连接：从计算逻辑到执行计划">6. 调度与图连接：从计算逻辑到执行计划</h3><p>代码最后通过创建调度（Schedule）和图连接参数，完成算子从计算逻辑到执行计划的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建调度（指定执行策略）</span></span><br><span class="line">Schedule* schedule = <span class="built_in">create_schedule</span>(D.<span class="built_in">get_tensor</span>()-&gt;op);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接算子到计算图</span></span><br><span class="line">ConnectOperatorToGraphParams* connect_params = <span class="keyword">new</span> <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line">connect_params-&gt;node_name = node_name;</span><br><span class="line">connect_params-&gt;output_datatype = FuncParams-&gt;output_data_types[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">connect_operator_to_graph</span>(tir, connect_params, concat_node);</span><br></pre></td></tr></table></figure><p><strong>调度的作用</strong>：<br>调度模块负责指定算子的执行策略，如循环并行方式、内存布局等，直接影响算子在硬件上的执行效率。对于Concat算子，常见的调度优化包括：</p><ul><li>拼接轴维度的循环拆分与并行化</li><li>非拼接轴的向量化加载/存储</li><li>对齐内存访问以减少缓存失效</li></ul><h2 id="技术亮点与扩展思考">技术亮点与扩展思考</h2><h3 id="1-符号计算的通用性设计">1. 符号计算的通用性设计</h3><p>代码采用符号表达式（<code>ScalarExpr</code>）而非具体数值表示张量形状，使其能够：</p><ul><li>支持动态形状输入（如来自用户输入的可变批次大小）</li><li>兼容静态形状优化（编译时可确定的维度）</li><li>为框架的自动形状推导提供基础</li></ul><h3 id="2-条件表达式链的性能考量">2. 条件表达式链的性能考量</h3><p>当前实现通过if-else链构建计算逻辑，在输入数量较多时可能引入分支开销。优化方向包括：</p><ul><li><strong>编译时展开</strong>：对于输入数量固定的场景，展开条件链为顺序判断</li><li><strong>查找表优化</strong>：预计算偏移范围，通过二分查找定位输入索引</li><li><strong>硬件特性适配</strong>：利用SIMD指令的掩码操作批量处理条件判断</li></ul><h3 id="3-与其他维度操作的协同设计">3. 与其他维度操作的协同设计</h3><p>Concat算子常与Reshape、Split等维度操作配合使用，在设计时需考虑：</p><ul><li>形状计算的一致性（如拼接后立即Reshape时的形状传递）</li><li>内存复用（避免不必要的张量复制，如原地拼接）</li><li>自动微分支持（拼接操作的梯度计算需要反向映射索引）</li></ul><h2 id="参考文献">参考文献</h2><ol><li>Abadi, M., et al. (2016). TensorFlow: Large-scale machine learning on heterogeneous systems.</li><li>Chen, T., et al. (2018). TVM: An automated end-to-end optimizing compiler for deep learning.</li><li>Paszke, A., et al. (2019). PyTorch: An imperative style, high-performance deep learning library.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算子开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算子开发 </tag>
            
            <tag> TIR </tag>
            
            <tag> 编译器 </tag>
            
            <tag> Concat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer编码器-解码器双向协作模式：原理、设计与优化</title>
      <link href="/2023/10/20/transformer/%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
      <url>/2023/10/20/transformer/%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>编码器-解码器双向协作模式：原理、设计、问题与解决方案</h1><h2 id="1-引言：transformer与编码器-解码器框架概述">1. 引言：Transformer与编码器-解码器框架概述</h2><p>自2017年Google团队在《Attention Is All You Need》中提出<strong>Transformer</strong>模型以来，其基于“注意力机制”的核心设计彻底改变了自然语言处理（NLP）、计算机视觉（CV）等领域的序列建模范式。Transformer的核心架构由<strong>编码器（Encoder）</strong> 和<strong>解码器（Decoder）</strong> 两部分组成，二者通过注意力机制实现信息交互，是机器翻译、文本摘要、对话生成等“序列到序列（Seq2Seq）”任务的核心载体。</p><p>在传统Seq2Seq模型（如RNN-based）中，编码器仅负责将输入序列编码为固定长度的“上下文向量”，再传递给解码器生成输出序列——这种“单向信息流动”模式在长序列或复杂任务中存在明显局限。随着研究推进，<strong>编码器-解码器双向协作模式</strong>逐渐成为主流：它打破了“编码器一次性输出、解码器被动接收”的限制，实现了编码器与解码器在生成过程中的<strong>动态信息交互</strong>（编码器根据解码器的当前状态调整输出，解码器根据编码器的动态反馈优化生成），显著提升了模型对复杂上下文的建模能力。</p><p>要理解双向协作模式，首先需要掌握其核心组件——<strong>多头注意力机制</strong>。</p><h2 id="2-基础概念：多头注意力机制">2. 基础概念：多头注意力机制</h2><p>注意力机制的本质是“模拟人类聚焦关键信息的能力”：在处理序列时，通过计算“查询（Query, Q）”与“键（Key, K）”的关联度（注意力权重），对“值（Value, V）”进行加权求和，最终得到聚焦关键信息的输出。而<strong>多头注意力（Multi-Head Attention）</strong> 是对基础注意力机制的扩展，通过并行计算多个“注意力头”，捕捉序列中不同维度的关联信息。</p><h3 id="2-1-多头注意力的定义与数学表达">2.1 多头注意力的定义与数学表达</h3><p>多头注意力的核心逻辑是：将Q、K、V通过不同的线性变换拆分为多个子空间（即“头”），在每个子空间内独立计算注意力输出，最后将所有头的输出拼接并通过线性变换得到最终结果。其数学流程可概括为以下5步：</p><ol><li><p><strong>线性变换</strong>：对输入的Q、K、V分别进行线性变换（参数矩阵分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>Q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>K</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">W_Q, W_K, W_V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），得到维度一致的中间结果：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>Q</mi><mo>⋅</mo><msub><mi>W</mi><mi>Q</mi></msub><mo separator="true">,</mo><mtext> </mtext><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>K</mi><mo>⋅</mo><msub><mi>W</mi><mi>K</mi></msub><mo separator="true">,</mo><mtext> </mtext><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>V</mi><mo>⋅</mo><msub><mi>W</mi><mi>V</mi></msub></mrow><annotation encoding="application/x-tex">Q&#x27; = Q \cdot W_Q,\ K&#x27; = K \cdot W_K,\ V&#x27; = V \cdot W_V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.038em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q, K \in \mathbb{R}^{n \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V \in \mathbb{R}^{n \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为序列长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为Q/K的维度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">d_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为V的维度），线性变换后<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q&#x27;, K&#x27;, V&#x27; \in \mathbb{R}^{n \times d_{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为Transformer的隐藏层维度）。</p></li><li><p><strong>拆分多头</strong>：将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Q&#x27;, K&#x27;, V&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>沿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>维度拆分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>个“头”（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>为头的数量，需满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>h</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d_{model} \mod h = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），每个头的维度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mi mathvariant="normal">/</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">d_k&#x27; = d_{model}/h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">h</span></span></span></span>：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo>=</mo><mtext>split</mtext><mo stretchy="false">(</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow></msup></mrow><annotation encoding="application/x-tex">Q_i = \text{split}(Q&#x27;, h) \in \mathbb{R}^{n \times d_k&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">split</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.214em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>=</mo><mtext>split</mtext><mo stretchy="false">(</mo><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow></msup></mrow><annotation encoding="application/x-tex">K_i = \text{split}(K&#x27;, h) \in \mathbb{R}^{n \times d_k&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">split</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.214em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>=</mo><mtext>split</mtext><mo stretchy="false">(</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><msubsup><mi>d</mi><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow></msup></mrow><annotation encoding="application/x-tex">V_i = \text{split}(V&#x27;, h) \in \mathbb{R}^{n \times d_v&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">split</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.214em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">i=1,2,...,h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span></span></span></span>）。</p></li><li><p><strong>缩放点积注意力计算</strong>：在每个头内，计算Q与K的相似度（点积），并除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.338808em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.901192em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.733692em;"><span style="top:-2.398692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30130799999999996em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.861192em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.338808em;"><span></span></span></span></span></span></span></span></span>（避免点积结果过大导致Softmax梯度消失），再通过Softmax得到注意力权重，最终对V加权求和：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><msub><mi>Q</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>Softmax</mtext><mrow><mo fence="true">(</mo><mfrac><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo>⋅</mo><msubsup><mi>K</mi><mi>i</mi><mi>T</mi></msubsup></mrow><msqrt><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></msqrt></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\text{Attention}(Q_i, K_i, V_i) = \text{Softmax}\left( \frac{Q_i \cdot K_i^T}{\sqrt{d_k&#x27;}} \right) \cdot V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">Softmax</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.153565em;"><span style="top:-2.5011224999999997em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9841107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7416285714285715em;"><span style="top:-2.1527714285714286em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.8448em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3472285714285714em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.956110714285715em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width='400em' height='1.5428571428571431em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47246071428571423em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">⋅</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.214em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>拼接多头输出</strong>：将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>个注意力头的输出沿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d_k&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span>维度拼接，恢复为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>维度：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Concat</mtext><mo>=</mo><mtext>concat</mtext><mo stretchy="false">(</mo><mtext>Attention</mtext><mo stretchy="false">(</mo><msub><mi>Q</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mtext>Attention</mtext><mo stretchy="false">(</mo><msub><mi>Q</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>h</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Concat} = \text{concat}(\text{Attention}(Q_1,K_1,V_1), ..., \text{Attention}(Q_h,K_h,V_h))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Concat</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">concat</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p></li><li><p><strong>最终线性变换</strong>：通过参数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">W_O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对拼接结果进行线性变换，得到多头注意力的最终输出：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MultiHead</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>Concat</mtext><mo>⋅</mo><msub><mi>W</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">\text{MultiHead}(Q,K,V) = \text{Concat} \cdot W_O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">MultiHead</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Concat</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li></ol><h3 id="2-2-多头注意力的核心作用">2.2 多头注意力的核心作用</h3><p>多头注意力的价值在于<strong>并行捕捉多尺度、多维度的关联信息</strong>，解决了“单头注意力只能聚焦单一维度关联”的局限。具体作用可分为3点：</p><ol><li><p><strong>捕捉多维度特征关联</strong>：不同注意力头可聚焦序列的不同属性。例如，在机器翻译任务中：</p><ul><li>部分头聚焦“语法关联”（如主谓一致、时态匹配）；</li><li>部分头聚焦“语义关联”（如同义词替换、上下文语义呼应）；</li><li>部分头聚焦“位置关联”（如长距离依赖的代词指代）。<br>多个头的结果融合后，模型能更全面地理解序列语义。</li></ul></li><li><p><strong>提升长距离依赖建模能力</strong>：单头注意力在长序列中易受“局部信息干扰”，而多头注意力通过多个头的并行计算，可同时关注“局部细节”和“全局结构”，例如在文档摘要任务中，部分头关注句子内的短语关联，部分头关注跨句子的逻辑衔接。</p></li><li><p><strong>增强模型鲁棒性</strong>：多个头的独立计算相当于“多视角验证”——即使个别头捕捉到噪声信息，其他头的有效信息仍能保证最终输出的可靠性。例如，在对话生成中，若某个头误将无关上下文纳入注意力，其他头对“对话主题”的聚焦可抵消这种干扰。</p></li></ol><h2 id="3-编码器-解码器双向协作模式的必要性">3. 编码器-解码器双向协作模式的必要性</h2><p>要理解“为什么需要双向协作”，首先需明确<strong>传统单向协作模式的局限性</strong>——这是双向协作模式诞生的核心动因。</p><h3 id="3-1-传统单向协作模式的局限">3.1 传统单向协作模式的局限</h3><p>在原始Transformer（或早期Seq2Seq模型）中，编码器与解码器的协作是“单向”的：</p><ul><li>编码器：将输入序列（如机器翻译的“源语言句子”）通过多层自注意力和前馈网络，编码为固定长度的“全局上下文向量”（或多层隐藏状态），一次性传递给解码器；</li><li>解码器：接收编码器的上下文向量，结合自身的“掩码自注意力”（防止未来信息泄露），逐词生成输出序列（如“目标语言句子”）。</li></ul><p>这种模式在复杂任务中存在3个关键问题：</p><ol><li><p><strong>信息压缩损耗</strong>：编码器需将输入序列的所有信息压缩为固定维度的向量（或多层状态），对于长序列（如1000词以上的文档），必然导致“关键细节丢失”。例如，在文本摘要任务中，若输入文档包含多个关键事件，单向协作的编码器可能仅保留部分事件信息，导致摘要遗漏核心内容。</p></li><li><p><strong>动态信息缺失</strong>：解码器生成过程中无法向编码器反馈“当前生成状态”——例如，在机器翻译中，当解码器生成“目标语言的主语”后，需要编码器提供“源语言中与该主语对应的修饰词”，但单向协作中编码器无法感知解码器的当前生成需求，只能提供固定的全局信息，导致翻译准确性下降。</p></li><li><p><strong>上下文对齐精度低</strong>：单向协作中，编码器的上下文向量与解码器的生成步骤是“静态对齐”的（即所有生成步骤共享同一批编码器信息），无法根据生成进度动态调整对齐焦点。例如，在对话生成中，解码器生成“回复的开头”时需要聚焦“用户上一轮的结尾”，生成“回复的中间”时需要聚焦“用户上一轮的核心观点”，但单向协作无法实现这种动态对齐。</p></li></ol><h3 id="3-2-双向协作模式的核心价值">3.2 双向协作模式的核心价值</h3><p>双向协作模式的本质是<strong>打破“编码器单向输出、解码器被动接收”的限制</strong>，实现二者的“动态信息闭环”：</p><ul><li>解码器在生成过程中，将“当前生成状态”（如已生成的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>个词的隐藏状态）反馈给编码器；</li><li>编码器根据解码器的反馈，调整自身的注意力权重，输出“与当前生成需求匹配的动态上下文信息”；</li><li>解码器再利用编码器的动态信息，优化下一个词的生成。</li></ul><p>这种双向交互直接解决了单向协作的3大局限：</p><ul><li>避免信息压缩损耗：编码器无需一次性输出所有信息，而是根据解码器的需求“按需输出”关键信息，减少长序列中的细节丢失；</li><li>补充动态信息：解码器的反馈让编码器能“感知生成进度”，提供更贴合当前需求的信息；</li><li>提升上下文对齐精度：动态交互实现了“生成步骤与编码器信息”的实时对齐，例如生成主语时聚焦源语言主语，生成修饰词时聚焦源语言修饰词。</li></ul><h2 id="4-编码器-解码器双向协作模式的作用原理">4. 编码器-解码器双向协作模式的作用原理</h2><p>双向协作模式之所以能提升任务性能，核心在于其<strong>动态信息交互机制</strong>——通过多头注意力实现编码器与解码器的“双向信息流动”，具体可分为“编码器到解码器的信息引导”和“解码器到编码器的需求反馈”两个方向。</p><h3 id="4-1-双向信息交互的核心机制">4.1 双向信息交互的核心机制</h3><p>在双向协作模式中，编码器与解码器通过<strong>跨注意力层（Cross-Attention Layer）</strong> 实现交互，且交互是“双向”的（区别于原始Transformer中仅解码器包含跨注意力层的“单向交互”）：</p><ol><li><p><strong>解码器→编码器的需求反馈</strong>：编码器的顶层加入“解码器状态感知层”——该层以“解码器当前生成步骤的隐藏状态”为Q，以“编码器自身的隐藏状态”为K/V，计算注意力权重。通过这种方式，编码器能识别“解码器当前最需要哪些输入序列信息”，并调整自身输出的权重分布（例如，解码器生成“苹果”时，编码器会重点输出输入序列中与“苹果”相关的描述）。</p></li><li><p><strong>编码器→解码器的信息引导</strong>：解码器的跨注意力层仍以“自身隐藏状态”为Q，但以“编码器调整后的动态输出”为K/V——此时编码器的输出已包含“解码器需求信息”，解码器能更精准地聚焦与当前生成相关的输入特征，避免无关信息干扰。</p></li></ol><p>简言之，双向协作模式形成了“<strong>解码器需求→编码器调整→解码器优化</strong>”的闭环，使信息交互从“静态匹配”升级为“动态适配”。</p><h3 id="4-2-双向协作对任务性能的提升逻辑">4.2 双向协作对任务性能的提升逻辑</h3><p>以两个典型Seq2Seq任务为例，可更直观理解双向协作的作用：</p><h4 id="案例1：机器翻译-源语言：中文-目标语言：英文">案例1：机器翻译（源语言：中文，目标语言：英文）</h4><ul><li>输入序列：“我在北京市中心的咖啡馆里工作”</li><li>单向协作：编码器一次性输出包含“我、北京、市中心、咖啡馆、工作”的全局向量，解码器生成“ I work in the café in the center of Beijing ”时，可能因“咖啡馆”和“市中心”的信息在全局向量中权重相近，误译为“ I work in the center of Beijing in the café ”（语序错误）。</li><li>双向协作：<ol><li>解码器生成“ I work in the ”后，将该状态反馈给编码器；</li><li>编码器通过注意力计算，识别解码器当前需要“地点名词”，调整输出权重，使“咖啡馆”的权重高于“市中心”；</li><li>解码器接收编码器的动态输出，精准生成“ café ”，避免语序错误。</li></ol></li></ul><h4 id="案例2：文本摘要-输入：新闻段落-输出：摘要">案例2：文本摘要（输入：新闻段落，输出：摘要）</h4><ul><li>输入段落：包含“地震发生时间（2023年10月）、地点（四川雅安）、伤亡人数（10人受伤）、救援进展（消防员已抵达）”4个关键信息；</li><li>单向协作：编码器可能仅突出“地震地点”和“伤亡人数”，导致摘要遗漏“救援进展”；</li><li>双向协作：<ol><li>解码器生成“四川雅安2023年10月发生地震，10人受伤”后，反馈状态给编码器；</li><li>编码器识别解码器已覆盖“时间、地点、伤亡”，需补充“救援信息”，调整输出权重，突出“消防员已抵达”；</li><li>解码器接收动态信息，生成“消防员已抵达现场开展救援”，完善摘要。</li></ol></li></ul><h2 id="5-经典编码器-解码器双向协作模式设计案例">5. 经典编码器-解码器双向协作模式设计案例</h2><p>学术界和工业界已提出多种双向协作模式的设计方案，核心差异在于“编码器与解码器的交互方式”和“注意力机制的改进”。以下为3类典型设计及其效果原理：</p><h3 id="5-1-共享注意力空间的双向协作：mass模型">5.1 共享注意力空间的双向协作：MASS模型</h3><h4 id="设计背景">设计背景</h4><p>MASS（Masked Sequence to Sequence Pre-training）是微软亚洲研究院提出的预训练模型，针对“Seq2Seq任务中编码器与解码器信息割裂”的问题，设计了“共享注意力空间”的双向协作模式。</p><h4 id="核心设计">核心设计</h4><ol><li><p><strong>掩码策略与共享注意力</strong>：</p><ul><li>编码器：对输入序列进行“连续片段掩码”（如掩码“北京市中心”），迫使编码器学习“掩码区域的上下文关联”；</li><li>解码器：以“编码器的掩码区域”为目标，生成缺失片段；</li><li>双向交互：编码器与解码器共享同一套K/V矩阵（即“注意力空间共享”），解码器生成时的Q可直接与编码器的K/V计算注意力，同时编码器也能通过共享K/V感知解码器的Q（即解码器的生成需求）。</li></ul></li><li><p><strong>动态信息反馈</strong>：解码器每生成一个token，其Q会更新并反馈给编码器，编码器通过共享注意力调整自身的V（即上下文向量），为下一个token的生成提供更精准的信息。</p></li></ol><h4 id="为什么起效果">为什么起效果</h4><ul><li>共享注意力空间减少了“编码器与解码器的信息转换损耗”——无需额外的线性变换将编码器的K/V转换为解码器可识别的格式，提升了信息交互效率；</li><li>连续片段掩码迫使编码器和解码器必须通过双向交互才能补全信息（编码器需解码器的生成状态判断掩码区域的边界，解码器需编码器的上下文判断掩码内容），强化了二者的协作依赖。</li></ul><h3 id="5-2-分层双向协作：bart模型">5.2 分层双向协作：BART模型</h3><h4 id="设计背景">设计背景</h4><p>BART（Bidirectional and Auto-Regressive Transformers）是Facebook提出的Seq2Seq预训练模型，针对“长序列中双向协作计算复杂度高”的问题，设计了“分层双向交互”机制。</p><h4 id="核心设计">核心设计</h4><ol><li><p><strong>编码器-解码器分层结构</strong>：</p><ul><li>编码器：采用6层双向自注意力（与BERT一致），负责编码输入序列的全局信息；</li><li>解码器：采用6层“掩码自注意力+分层跨注意力”，其中“分层跨注意力”分为3个层级，分别与编码器的第2、4、6层输出交互。</li></ul></li><li><p><strong>分层双向反馈</strong>：</p><ul><li>解码器的低层跨注意力（第1-2层）与编码器的低层输出（第2层）交互，聚焦“局部细节信息”（如短语、语法）；</li><li>解码器的中层跨注意力（第3-4层）与编码器的中层输出（第4层）交互，聚焦“句子级语义关联”；</li><li>解码器的高层跨注意力（第5-6层）与编码器的高层输出（第6层）交互，聚焦“文档级逻辑结构”；</li><li>同时，解码器的各层状态会反馈给编码器对应的层级，调整编码器该层级的注意力权重。</li></ul></li></ol><h4 id="为什么起效果">为什么起效果</h4><ul><li>分层交互降低了计算复杂度：解码器无需与编码器的所有层交互，仅需与3个关键层级交互，减少了注意力计算量（复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \cdot L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \cdot L/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>为层数）；</li><li>分层聚焦提升了信息对齐精度：低层关注细节、高层关注全局，避免了“单层交互中细节与全局信息混杂”的问题，例如在文档翻译中，低层确保短语翻译准确，高层确保段落逻辑连贯。</li></ul><h3 id="5-3-统一双向交互：unified-transformer">5.3 统一双向交互：Unified Transformer</h3><h4 id="设计背景">设计背景</h4><p>Unified Transformer是百度提出的“通用Seq2Seq模型”，针对“不同任务（翻译、对话、摘要）需调整双向协作模式”的问题，设计了“统一双向交互框架”。</p><h4 id="核心设计">核心设计</h4><ol><li><p><strong>任务无关的双向注意力模块</strong>：</p><ul><li>编码器和解码器均包含“双向跨注意力层”：编码器的跨注意力以“解码器状态”为Q，解码器的跨注意力以“编码器状态”为Q，且二者共享注意力参数；</li><li>引入“任务类型嵌入（Task Embedding）”：将任务类型（如翻译、对话）编码为向量，融入Q、K的计算中，使同一双向模块可适配不同任务。</li></ul></li><li><p><strong>动态交互强度控制</strong>：</p><ul><li>引入“交互权重因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>”：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>由任务类型和序列长度动态调整（如对话任务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>更大，需更强的双向交互；短序列任务<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>更小，减少冗余计算）；</li><li>注意力权重计算为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi><mo>⋅</mo><mtext>Softmax</mtext><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup><mi mathvariant="normal">/</mi><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt><mo stretchy="false">)</mo><mo>⋅</mo><mi>V</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\text{Attention}(Q,K,V) = \alpha \cdot \text{Softmax}(QK^T/\sqrt{d_k}) \cdot V + (1-\alpha) \cdot V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1072199999999999em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Softmax</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>控制双向交互的强度。</li></ul></li></ol><h4 id="为什么起效果">为什么起效果</h4><ul><li>统一模块提升了泛化能力：无需为不同任务设计专用双向协作层，仅通过任务嵌入即可适配翻译、对话等任务，降低了模型设计成本；</li><li>动态交互强度控制平衡了“性能”与“效率”：在需要强交互的任务（如多轮对话）中提升<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>以保证效果，在简单任务（如短文本翻译）中降低<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>以减少计算量。</li></ul><h2 id="6-双向协作模式面临的核心问题">6. 双向协作模式面临的核心问题</h2><p>尽管双向协作模式显著提升了任务性能，但在实际应用中仍面临4类关键问题，这些问题本质上是“信息交互效率”与“模型性能”的矛盾体现：</p><h3 id="6-1-计算复杂度急剧增加">6.1 计算复杂度急剧增加</h3><p>双向协作的核心是“动态信息交互”，但每次交互都需额外计算注意力权重：</p><ul><li>单向协作中，编码器的计算复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><msub><mi>L</mi><mrow><mi>e</mi><mi>n</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \cdot L_{enc})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，解码器为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>⋅</mo><msub><mi>L</mi><mrow><mi>d</mi><mi>e</mi><mi>c</mi></mrow></msub><mo>+</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo>⋅</mo><msub><mi>L</mi><mrow><mi>d</mi><mi>e</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m^2 \cdot L_{dec} + n \cdot m \cdot L_{dec})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为输入长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>为输出长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>e</mi><mi>n</mi><mi>c</mi></mrow></msub><mi mathvariant="normal">/</mi><msub><mi>L</mi><mrow><mi>d</mi><mi>e</mi><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{enc}/L_{dec}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为编码器/解码器层数）；</li><li>双向协作中，因编码器需额外计算“解码器状态引导的注意力”，复杂度增至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><msub><mi>L</mi><mrow><mi>e</mi><mi>n</mi><mi>c</mi></mrow></msub><mo>+</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo>⋅</mo><msub><mi>L</mi><mrow><mi>e</mi><mi>n</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>⋅</mo><msub><mi>L</mi><mrow><mi>d</mi><mi>e</mi><mi>c</mi></mrow></msub><mo>+</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo>⋅</mo><msub><mi>L</mi><mrow><mi>d</mi><mi>e</mi><mi>c</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2 \cdot L_{enc} + n \cdot m \cdot L_{enc}) + O(m^2 \cdot L_{dec} + n \cdot m \cdot L_{dec})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>——当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>均超过1000时，计算量会翻倍，导致模型训练和推理速度显著下降。</li></ul><p>例如，在文档级机器翻译（输入长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">n=2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，输出长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>1500</mn></mrow><annotation encoding="application/x-tex">m=1500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>）中，双向协作的计算时间是单向协作的1.8-2.2倍，难以满足实时推理需求。</p><h3 id="6-2-信息过载与冗余">6.2 信息过载与冗余</h3><p>双向协作中，编码器会根据解码器的反馈持续输出动态信息，但若缺乏“信息筛选机制”，解码器会接收大量重复或无关的信息：</p><ul><li>例如，在多轮对话生成中，解码器生成“我明天有空”后，编码器可能同时输出“用户上一轮提到‘周末聚会’”“用户前两轮提到‘时间冲突’”“用户历史对话中提到‘明天’”等信息，其中“用户前两轮提到‘时间冲突’”与当前生成无关，属于冗余信息；</li><li>冗余信息会导致解码器的“注意力分散”——Softmax权重被无关信息稀释，无法聚焦关键特征，最终导致生成内容偏离主题。</li></ul><h3 id="6-3-上下文对齐错位">6.3 上下文对齐错位</h3><p>双向协作的核心目标是“动态对齐编码器信息与解码器生成步骤”，但在以下场景中易出现“对齐错位”：</p><ol><li><strong>长序列中的位置偏移</strong>：当输入序列包含多个相似实体（如“苹果公司发布了新手机，苹果商店同步上线”），解码器生成“苹果商店”时，编码器可能因“位置权重计算误差”，将注意力聚焦到“苹果公司”的位置，导致对齐错位；</li><li><strong>生成节奏不匹配</strong>：解码器生成速度（如每秒生成5个token）与编码器动态调整速度（如每秒调整3次）不匹配，导致编码器的信息更新滞后于解码器的生成步骤，例如解码器已生成第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>个token，编码器仍输出针对第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">t-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个token的信息。</li></ol><h3 id="6-4-训练不稳定性">6.4 训练不稳定性</h3><p>双向协作增加了编码器与解码器的“依赖耦合度”——编码器的输出依赖解码器的状态，解码器的生成依赖编码器的动态信息，这种耦合会导致训练过程中的“梯度传播不稳定”：</p><ol><li><strong>梯度消失</strong>：编码器的梯度需通过解码器的跨注意力层反向传播，而解码器的自注意力层（掩码机制）会削弱长序列的梯度传递，导致编码器低层的梯度趋近于0，无法有效更新参数；</li><li><strong>梯度爆炸</strong>：当解码器生成某个“高置信度token”（如概率为0.95的“的”）时，其梯度会急剧放大，并通过双向交互传递给编码器，导致编码器的参数更新幅度过大，模型收敛震荡。</li></ol><p>例如，在训练双向协作的BART模型时，若未采取特殊措施，训练损失会在第5-10个epoch出现显著波动（波动幅度是单向协作的3-5倍），甚至出现训练崩溃。</p><h2 id="7-问题解决方案与有效性原理">7. 问题解决方案与有效性原理</h2><p>针对上述4类核心问题，学术界和工业界已提出多种解决方案，其设计思路均围绕“平衡信息交互效率与模型性能”展开，以下为经过实践验证的有效方法：</p><h3 id="7-1-解决-计算复杂度高-：稀疏化与分层优化">7.1 解决“计算复杂度高”：稀疏化与分层优化</h3><h4 id="方案1：稀疏注意力机制">方案1：稀疏注意力机制</h4><p><strong>核心思路</strong>：通过“限制注意力计算的范围”，减少双向交互中的注意力权重计算量，而非对所有Q-K对进行计算。<br><strong>典型实现</strong>：</p><ul><li>Longformer的“滑动窗口注意力”：编码器和解码器的跨注意力仅计算“当前位置±<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>”窗口内的Q-K对（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>为窗口大小，通常设为512），超出窗口的Q-K对权重设为0；</li><li>BigBird的“随机注意力+全局注意力”：对大多数位置采用随机采样（如采样100个位置）计算注意力，对关键位置（如句子开头、实体标记）采用全局注意力，兼顾效率与准确性。</li></ul><p><strong>为什么有效</strong>：<br>稀疏注意力将注意力计算复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>w</mi><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(w \cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>（滑动窗口）或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n} \cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>（随机采样）——例如，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">n=2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">w=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>时，计算量减少74.4%，同时窗口内的局部信息和关键位置的全局信息仍能保证双向交互的有效性。</p><h4 id="方案2：分层注意力蒸馏">方案2：分层注意力蒸馏</h4><p><strong>核心思路</strong>：通过“知识蒸馏”压缩编码器的输出维度，减少双向交互中的信息传递量。<br><strong>典型实现</strong>：</p><ul><li>训练一个“教师编码器”（完整维度，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">d_{model}=1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span>）和一个“学生编码器”（压缩维度，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">d_{model}=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>）；</li><li>教师编码器通过双向交互学习“最优动态输出”，并将其作为“蒸馏目标”，指导学生编码器学习“如何用更少维度保留关键信息”；</li><li>推理时使用学生编码器与解码器进行双向交互，减少计算和内存开销。</li></ul><p><strong>为什么有效</strong>：<br>维度压缩直接减少了注意力计算中的“矩阵乘法规模”（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mo>×</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024 \times 1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span>的矩阵乘法变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mo>×</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">512 \times 512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>，计算量减少75%），同时知识蒸馏确保学生编码器的输出与教师编码器的关键信息一致，不会因维度压缩导致性能下降。</p><h3 id="7-2-解决-信息过载-：门控与筛选机制">7.2 解决“信息过载”：门控与筛选机制</h3><h4 id="方案1：动态注意力门控">方案1：动态注意力门控</h4><p><strong>核心思路</strong>：在编码器与解码器的交互路径中加入“门控模块”，动态筛选对当前生成有用的信息。<br><strong>典型实现</strong>：</p><ul><li>在编码器的跨注意力层输出后，加入一个“ sigmoid 门控”：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>g</mi></msub><mo>⋅</mo><mtext>EncOut</mtext><mo>+</mo><msub><mi>b</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g = \sigma(W_g \cdot \text{EncOut} + b_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">EncOut</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EncOut</mtext></mrow><annotation encoding="application/x-tex">\text{EncOut}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">EncOut</span></span></span></span></span>为编码器的动态输出，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g \in [0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>为门控权重；</li><li>筛选后的编码器输出为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>FilteredOut</mtext><mo>=</mo><mi>g</mi><mo>⋅</mo><mtext>EncOut</mtext></mrow><annotation encoding="application/x-tex">\text{FilteredOut} = g \cdot \text{EncOut}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">FilteredOut</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">EncOut</span></span></span></span></span>——<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>接近1的信息被保留，接近0的信息被过滤。</li></ul><p><strong>为什么有效</strong>：<br>门控模块通过学习“当前生成步骤与编码器信息的相关性”，自动过滤冗余信息。例如，在对话生成中，当解码器生成“明天见”时，门控会给“用户提到‘明天’”的信息分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mn>0.9</mn></mrow><annotation encoding="application/x-tex">g=0.9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span></span></span></span>（保留），给“用户上周提到‘昨天’”的信息分配<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding="application/x-tex">g=0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span></span></span></span>（过滤），避免解码器注意力分散。</p><h4 id="方案2：关键信息预测">方案2：关键信息预测</h4><p><strong>核心思路</strong>：在双向协作前，先预测“解码器需要的关键信息类型”，引导编码器定向输出。<br><strong>典型实现</strong>：</p><ul><li>在解码器的隐藏层后加入一个“信息类型预测器”，预测当前生成步骤需要的信息类型（如“实体”“时间”“地点”“动作”）；</li><li>编码器根据预测的信息类型，调整自注意力权重，重点输出该类型的信息（如预测需要“地点”，则编码器将“北京”“咖啡馆”等地点信息的权重提升）。</li></ul><p><strong>为什么有效</strong>：<br>信息类型预测为编码器提供了“明确的筛选目标”，避免了“无差别输出所有动态信息”的问题。例如，在机器翻译中，若预测当前需要“动作动词”，编码器会定向输出源语言中的动词信息，解码器无需在名词、形容词等信息中筛选，提升了生成效率和准确性。</p><h3 id="7-3-解决-上下文对齐错位-：动态对齐与节奏匹配">7.3 解决“上下文对齐错位”：动态对齐与节奏匹配</h3><h4 id="方案1：位置感知动态对齐">方案1：位置感知动态对齐</h4><p><strong>核心思路</strong>：引入“位置预测模块”，学习编码器信息与解码器生成步骤的位置对应关系，动态调整对齐权重。<br><strong>典型实现</strong>：</p><ul><li>在编码器的跨注意力层中加入“位置偏移预测器”，预测解码器当前生成步骤<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>对应的编码器位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">t=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">p=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）；</li><li>根据预测位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，调整注意力窗口：将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>附近的编码器位置权重提升，远离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的位置权重降低，实现“精准对齐”。</li></ul><p><strong>为什么有效</strong>：<br>位置预测模块直接解决了“长序列中的位置偏移”问题。例如，在“苹果公司发布了新手机，苹果商店同步上线”的翻译中，当解码器生成“苹果商店”（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">t=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>）时，位置预测器会预测对应的编码器位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">p=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>（“苹果商店”在输入序列中的位置），并将该位置的权重提升，避免对齐到“苹果公司”（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>）。</p><h4 id="方案2：自适应节奏匹配">方案2：自适应节奏匹配</h4><p><strong>核心思路</strong>：动态调整编码器的信息更新频率，使其与解码器的生成节奏匹配。<br><strong>典型实现</strong>：</p><ul><li>计算解码器的“生成节奏特征”：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mtext>avg</mtext><mo stretchy="false">(</mo><msub><mtext>DecoderOut</mtext><mi>t</mi></msub><mo>−</mo><msub><mtext>DecoderOut</mtext><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r = \text{avg}(\text{DecoderOut}_t - \text{DecoderOut}_{t-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">avg</span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">DecoderOut</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">DecoderOut</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>越大表示生成节奏越快（如连续生成短词），越小表示节奏越慢（如生成长词或复杂句）；</li><li>根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>调整编码器的更新频率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f = \max(1, \lfloor k / r \rfloor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">⌋</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为常数——节奏快时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>增大（编码器每生成1个token更新1次），节奏慢时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>减小（编码器每生成2-3个token更新1次）。</li></ul><p><strong>为什么有效</strong>：<br>节奏匹配确保编码器的信息更新不会“滞后”或“超前”于解码器的生成步骤。例如，当解码器快速生成短词（如“我、在、北京”）时，编码器每生成1个token更新1次，提供实时信息；当解码器缓慢生成复杂句（如“我计划下周去北京参加会议”）时，编码器每生成2个token更新1次，避免频繁更新导致的信息波动。</p><h3 id="7-4-解决-训练不稳定性-：梯度优化与预训练">7.4 解决“训练不稳定性”：梯度优化与预训练</h3><h4 id="方案1：梯度裁剪与归一化">方案1：梯度裁剪与归一化</h4><p><strong>核心思路</strong>：通过“限制梯度范围”和“归一化梯度分布”，避免梯度爆炸或消失。<br><strong>典型实现</strong>：</p><ul><li>梯度裁剪：在反向传播时，若梯度的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数超过阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>1.0</mn></mrow><annotation encoding="application/x-tex">\theta=1.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span></span>），则将梯度缩放为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>⋅</mo><mtext>grad</mtext><mi mathvariant="normal">/</mi><mi mathvariant="normal">∥</mi><mtext>grad</mtext><msub><mi mathvariant="normal">∥</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta \cdot \text{grad} / \|\text{grad}\|_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">grad</span></span><span class="mord">/</span><span class="mord">∥</span><span class="mord text"><span class="mord">grad</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，防止梯度爆炸；</li><li>层归一化（Layer Normalization）：在编码器和解码器的每一层输出后，对隐藏状态进行归一化：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LN</mtext><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>γ</mi><mo>⋅</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi mathvariant="double-struck">E</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><msqrt><mrow><mtext>Var</mtext><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>ϵ</mi></mrow></msqrt></mfrac><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\text{LN}(x) = \gamma \cdot \frac{x - \mathbb{E}[x]}{\sqrt{\text{Var}[x] + \epsilon}} + \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">LN</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.8396em;vertical-align:-0.8295999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.4641625em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0369107142857144em;"><span class="svg-align" style="top:-3.428571428571429em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="mord mtight" style="padding-left:1.19em;"><span class="mord text mtight"><span class="mord mtight">Var</span></span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">ϵ</span></span></span><span style="top:-3.0089107142857143em;"><span class="pstrut" style="height:3.428571428571429em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5428571428571431em;"><svg width='400em' height='1.5428571428571431em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4196607142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathbb mtight">E</span></span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8295999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\gamma, \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>为可学习参数——归一化后的隐藏状态分布更稳定，梯度传递更顺畅，减少梯度消失。</li></ul><p><strong>为什么有效</strong>：<br>梯度裁剪直接限制了“梯度爆炸”的幅度，层归一化则通过稳定隐藏状态的均值和方差，解决了“深度网络中梯度逐层衰减”的问题。例如，在训练双向协作的Unified Transformer时，加入梯度裁剪和层归一化后，训练损失的波动幅度从±0.8降至±0.2，模型收敛更稳定。</p><h4 id="方案2：预训练-微调策略">方案2：预训练-微调策略</h4><p><strong>核心思路</strong>：先在大规模通用数据上预训练双向协作模块，再在下游任务上微调，降低训练难度。<br><strong>典型实现</strong>：</p><ul><li>预训练阶段：使用大规模无标注数据（如Wikipedia、BookCorpus），训练编码器与解码器的双向协作能力（如MASS的掩码补全、BART的文本修复），让模型学习“通用的双向交互模式”；</li><li>微调阶段：在下游任务（如机器翻译、文本摘要）的标注数据上，微调双向协作模块的参数，使其适配具体任务需求。</li></ul><p><strong>为什么有效</strong>：<br>预训练让模型在“低风险环境”（无标注数据，无需追求任务性能）中学习到“稳定的双向交互参数初始化”，避免了从零开始训练时的“参数随机化导致的梯度不稳定”。例如，预训练后的BART模型在微调机器翻译任务时，训练损失的收敛速度是“从零训练”的2-3倍，且无明显震荡。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> Transformer </tag>
            
            <tag> 编码器-解码器 </tag>
            
            <tag> 双向协作 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂多头注意力机制</title>
      <link href="/2023/08/23/transformer/%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/23/transformer/%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1>多头注意力机制的原理、设计与进阶优化</h1><h2 id="1-多头注意力机制是什么">1. 多头注意力机制是什么</h2><p>多头注意力机制（Multi-Head Attention）的核心本质，是通过<strong>并行计算多个独立的注意力头（Attention Head）</strong>，在不同的特征子空间中分别捕捉输入序列的多元语义关系（如语法依赖、语义关联、位置交互等），最终将所有注意力头的输出聚合，形成更全面、更细粒度的全局上下文表示。</p><p>从数学层面可将其拆解为<strong>线性投影→多头拆分→并行注意力计算→结果聚合</strong>四个核心步骤，具体定义与实现如下：</p><h2 id="2-多头注意力机制的数学实现流程">2. 多头注意力机制的数学实现流程</h2><h3 id="2-1-线性投影-linear-projection">2.1 线性投影（Linear Projection）</h3><p>首先，对输入的 Query（Q）、Key（K）、Value（V）向量分别施加三组独立的可学习线性变换，将其从原始模型维度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 映射到注意力头的目标维度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（Q、K 维度）和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">d_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（V 维度）。</p><ul><li>核心目的：为后续“多头拆分”做维度适配，同时通过线性变换注入差异化的语义表征。</li><li>数学表达：<br>设输入向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 为序列长度），三组可学习参数矩阵分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>Q</mi></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W^Q \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>K</mi></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W^K \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>V</mi></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W^V \in \mathbb{R}^{d_{\text{model}} \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.880431em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，则投影后的向量为：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mtext>proj</mtext></msub><mo>=</mo><mi>Q</mi><mo>⋅</mo><msup><mi>W</mi><mi>Q</mi></msup><mo separator="true">,</mo><mspace width="1em"/><msub><mi>K</mi><mtext>proj</mtext></msub><mo>=</mo><mi>K</mi><mo>⋅</mo><msup><mi>W</mi><mi>K</mi></msup><mo separator="true">,</mo><mspace width="1em"/><msub><mi>V</mi><mtext>proj</mtext></msub><mo>=</mo><mi>V</mi><mo>⋅</mo><msup><mi>W</mi><mi>V</mi></msup></mrow><annotation encoding="application/x-tex">Q_{\text{proj}} = Q \cdot W^Q, \quad K_{\text{proj}} = K \cdot W^K, \quad V_{\text{proj}} = V \cdot W^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.177439em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.177439em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span></span></span></span></span></span></span></span></p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mtext>proj</mtext></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q_{\text{proj}} \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mtext>proj</mtext></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K_{\text{proj}} \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mtext>proj</mtext></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V_{\text{proj}} \in \mathbb{R}^{L \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="2-2-多头拆分-head-splitting">2.2 多头拆分（Head Splitting）</h3><p>将投影后的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mtext>proj</mtext></msub></mrow><annotation encoding="application/x-tex">Q_{\text{proj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mtext>proj</mtext></msub></mrow><annotation encoding="application/x-tex">K_{\text{proj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mtext>proj</mtext></msub></mrow><annotation encoding="application/x-tex">V_{\text{proj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">proj</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 按注意力头数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 进行<strong>均匀拆分</strong>，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 组独立的子向量（每个子向量对应一个注意力头的输入）。</p><ul><li>维度约束：为保证拆分后各头维度一致且总维度不变，通常设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><msub><mi>d</mi><mi>v</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mtext>model</mtext></msub><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">d_k = d_v = \frac{d_{\text{model}}}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2469679999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9019679999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>=</mo><mi>h</mi><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}} = h \cdot d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。</li><li>拆分后维度：<br>每组子向量的维度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><mfrac><msub><mi>d</mi><mi>k</mi></msub><mi>h</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{L \times \frac{d_k}{h}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11149em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.11149em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0692714285714287em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.573242857142857em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>（或等价重塑为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mrow><mi>h</mi><mo>×</mo><mi>L</mi><mo>×</mo><mfrac><msub><mi>d</mi><mi>k</mi></msub><mi>h</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{h \times L \times \frac{d_k}{h}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11149em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.11149em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0692714285714287em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.573242857142857em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>，便于并行计算），记第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个头的子向量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup></mrow><annotation encoding="application/x-tex">QW_i^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.276864em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.959239em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup></mrow><annotation encoding="application/x-tex">KW_i^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup></mrow><annotation encoding="application/x-tex">VW_i^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">i = 1, 2, ..., h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span></span></span></span>）。</li></ul><h3 id="2-3-并行点积注意力计算-parallel-scaled-dot-product-attention">2.3 并行点积注意力计算（Parallel Scaled Dot-Product Attention）</h3><p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 组子向量分别独立计算<strong>缩放点积注意力</strong>，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 个注意力头的输出（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 个不同特征子空间的上下文表示）。</p><ul><li>单个注意力头的计算逻辑：<br>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个头的输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">head_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 计算公式为：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo separator="true">,</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><mo separator="true">,</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup><mo stretchy="false">)</mo><mo>=</mo><mtext>softmax</mtext><mrow><mo fence="true">(</mo><mfrac><mrow><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo>⋅</mo><mo stretchy="false">(</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup></mrow><annotation encoding="application/x-tex">head_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V) = \text{softmax}\left( \frac{QW_i^Q \cdot (KW_i^K)^T}{\sqrt{d_k}} \right) \cdot VW_i^V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.276864em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9592389999999998em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="mord text"><span class="mord">softmax</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.636239em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6769999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.959239em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>其中：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sqrt{d_k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.383108em;vertical-align:-0.538em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5864385em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8622307142857143em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.8222307142857144em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17776928571428574em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>：缩放因子，用于缓解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 过大导致的 softmax 梯度饱和问题；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(KW_i^K)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.258664em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>：Key 子向量的转置，确保与 Query 子向量的点积可计算；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>softmax</mtext></mrow><annotation encoding="application/x-tex">\text{softmax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">softmax</span></span></span></span></span>：将注意力分数归一化为权重（求和为 1），表征每个 Key 对 Query 的贡献占比；</li><li>最终输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><mfrac><msub><mi>d</mi><mi>v</mi></msub><mi>h</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">head_i \in \mathbb{R}^{L \times \frac{d_v}{h}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03667em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.03667em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9623857142857143em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.466357142857143em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23056em;"><span style="top:-2.3em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.5em;"></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>（因 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub><mo>=</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_v = d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也可写为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><mfrac><msub><mi>d</mi><mi>k</mi></msub><mi>h</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{L \times \frac{d_k}{h}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.11149em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.11149em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0692714285714287em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.573242857142857em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>）。</li></ul></li></ul><h3 id="2-4-结果聚合-output-concatenation-linear-projection">2.4 结果聚合（Output Concatenation &amp; Linear Projection）</h3><p>将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> 个注意力头的输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">head_1, head_2, ..., head_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行<strong>拼接（Concat）</strong>，再通过一组可学习的线性变换矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>o</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_o \in \mathbb{R}^{d_{\text{model}} \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 映射回原始模型维度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到多头注意力的最终输出。</p><ul><li>数学表达：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MultiHead</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>Concat</mtext><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>W</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\text{MultiHead}(Q, K, V) = \text{Concat}(head_1, head_2, ..., head_h) \cdot W_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">MultiHead</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Concat</span></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></li><li>最终输出维度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>MultiHead</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\text{MultiHead}(Q, K, V) \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">MultiHead</span></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，与输入向量维度一致，可直接接入后续网络层（如 Feed-Forward Network）。</li></ul><h2 id="3-多头注意力的核心作用">3. 多头注意力的核心作用</h2><p>多头注意力的核心价值在于突破传统注意力机制的表达局限，为模型提供多维度、高效化、长距离的信息交互能力，主要体现在三个方面：</p><h3 id="3-1-多元关系建模">3.1 多元关系建模</h3><p>单一注意力头仅能捕捉输入序列的单一模式关联，而多头注意力通过并行子空间学习，可同时捕获多种类型的关系。例如在句子“气候变化影响全球经济”中，一个头可能关注“气候变化”与“影响”的主谓关系，另一个头专注“全球”与“经济”的修饰关系，还有头捕捉“气候变化”与“经济”的长距离因果关联。在机器翻译任务中，这种能力可同时建模语法规则、语义重点和指代关系，显著提升翻译准确性。</p><h3 id="3-2-并行计算加速">3.2 并行计算加速</h3><p>与循环神经网络（RNN）的顺序计算模式不同，多头注意力对序列中所有元素的处理可完全并行执行。所有注意力头的计算可通过矩阵运算批量完成，充分利用GPU等硬件的并行计算能力，将训练效率提升数倍甚至数十倍。这种高效性为训练百亿级参数的大模型奠定了基础。</p><h3 id="3-3-长距离依赖捕获">3.3 长距离依赖捕获</h3><p>传统RNN受限于梯度消失问题，难以建模超过50个token的长序列依赖；CNN则需要通过多层堆叠才能扩大感受野。而多头注意力通过直接计算任意两个token间的注意力权重，可实现“端到端”的长距离信息交互，即使序列长度达到数千仍能保持稳定性能。在文档理解、基因组分析等长序列任务中，这种优势尤为突出。</p><h2 id="4-为什么需要多头注意力机制">4. 为什么需要多头注意力机制</h2><p>多头注意力的设计源于对单头注意力局限性的突破，以及对复杂序列建模需求的深度适配，其存在必要性可从三个维度解释：</p><h3 id="4-1-单头注意力的表达瓶颈">4.1 单头注意力的表达瓶颈</h3><p>单头注意力本质上是在单一特征空间中进行全局信息聚合，存在两个核心缺陷：一是无法同时关注不同类型的关联模式，例如在处理“他在公园看到了她，因为她是他的妹妹”时，单头注意力难以同时捕捉“他-她”的指代关系和“公园-看到”的场景关系；二是高维空间中的表示效率低下，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>较大时，单一子空间的线性变换难以充分挖掘特征间的非线性关联。</p><h3 id="4-2-分而治之的学习策略">4.2 分而治之的学习策略</h3><p>多头注意力采用“分而治之”的策略，将高维特征空间分解为多个低维子空间。这种分解不仅降低了每个子空间的学习难度，使模型能更高效地学习局部特征交互，还通过子空间的多样性覆盖了更全面的特征模式。这与卷积神经网络中多滤波器提取不同特征的思想异曲同工，但注意力头的学习更具动态适应性。</p><h3 id="4-3-模型鲁棒性的提升">4.3 模型鲁棒性的提升</h3><p>单一注意力头的学习过程易受噪声干扰，若某一模式的学习出现偏差，将直接影响整体性能。而多头注意力通过多路径学习实现了“容错机制”：即使个别头学到的模式不佳，其他头仍能提供有效信息，显著降低了模型对单一特征模式的依赖，提升了泛化能力。实验表明，移除BERT模型中10%的注意力头，任务性能几乎无损失，印证了其鲁棒性优势。</p><h2 id="5-多头注意力为什么会有作用">5. 多头注意力为什么会有作用</h2><p>多头注意力的有效性并非偶然，而是源于其在表示学习、优化特性和计算逻辑上的深层优势，可从理论和实证两方面得到验证：</p><h3 id="5-1-理论层面：子空间表示的完备性">5.1 理论层面：子空间表示的完备性</h3><p>从表示学习理论来看，多头注意力的本质是将输入特征映射到多个正交子空间，每个子空间专注于学习特定类型的特征交互。数学上可证明，当子空间数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>足够且投影矩阵线性无关时，多头注意力的表示能力等价于高维空间中的非线性变换，但其学习难度远低于直接在高维空间中建模。这种子空间分解还避免了高维点积运算导致的数值饱和问题，通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>的缩放因子进一步保证了梯度稳定性。</p><h3 id="5-2-实证层面：注意力头的功能特化">5.2 实证层面：注意力头的功能特化</h3><p>大量研究通过可视化和消融实验揭示了注意力头的功能特化现象。Voita等人2019年的研究发现，Transformer模型中的注意力头存在明确分工：部分头专注于捕捉语法依赖（如主谓宾结构），部分头聚焦于语义关联（如同义词替换），还有头专门处理长距离指代关系。在BERT模型的MultiNLI任务中，仅保留20%的核心注意力头即可维持90%以上的原始性能，证明了头功能特化带来的学习效率提升。</p><h3 id="5-3-优化层面：并行计算的梯度优势">5.3 优化层面：并行计算的梯度优势</h3><p>并行计算不仅提升了训练速度，更改善了优化过程的梯度特性。RNN的顺序计算导致梯度传播存在累积效应，易出现梯度消失或爆炸；而多头注意力的并行结构使每个头的梯度独立计算后聚合，梯度传播路径更短且更稳定。实验显示，采用8头注意力的Transformer模型，训练收敛速度比单头注意力快3倍以上，且最终损失值更低。</p><h2 id="6-多头注意力的设计细节与演进">6. 多头注意力的设计细节与演进</h2><h3 id="6-1-原始设计-transformer-2017">6.1 原始设计（Transformer, 2017）</h3><p>Vaswani等人的原始设计确立了多头注意力的核心框架，其关键设计 choices 包括：</p><ul><li><strong>头数与维度配比</strong>：采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">h=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>个注意力头，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">d_{\text{model}}=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span>，每个头的维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">d_k=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span>。这种配比在参数总量（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>512</mn><mo>×</mo><mn>512</mn><mo>+</mo><mn>512</mn><mo>×</mo><mn>512</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>048</mn><mo separator="true">,</mo><mn>576</mn></mrow><annotation encoding="application/x-tex">3 \times 512 \times 512 + 512 \times 512 = 1,048,576</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mord">6</span></span></span></span>）与表示能力间取得平衡；</li><li><strong>缩放点积注意力</strong>：引入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>作为缩放因子，解决高维空间点积值过大导致的Softmax梯度消失问题；</li><li><strong>统一投影机制</strong>：Q、K、V共享基础线性投影层后再拆分多头，而非为每个头单独设计投影层，减少了参数冗余。</li></ul><p>原始设计中，多头注意力在Transformer架构中存在三种变体：</p><ul><li><strong>自注意力（Self-Attention）</strong>：Q、K、V来自同一输入，用于编码器内的上下文建模；</li><li><strong>交叉注意力（Cross-Attention）</strong>：Q来自解码器，K、V来自编码器，实现源-目标序列的信息交互；</li><li><strong>掩码自注意力（Masked Self-Attention）</strong>：屏蔽解码器中未来位置的token，适配自回归生成任务。</li></ul><h3 id="6-2-设计演进与变体">6.2 设计演进与变体</h3><p>随着研究深入，多头注意力的设计不断优化，形成了多种变体：</p><ul><li><strong>稀疏多头注意力</strong>：如Longformer采用滑动窗口注意力，仅计算局部窗口内的注意力，将复杂度从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；</li><li><strong>动态多头注意力</strong>：如Adaptively Sparse Transformers通过可学习门控机制动态激活重要注意力头，减少冗余计算；</li><li><strong>跨模态多头注意力</strong>：如Vision Transformer（ViT）将图像patch作为token，采用多头注意力捕捉空间关联，适配视觉任务。</li></ul><h2 id="7-多头注意力的效果验证">7. 多头注意力的效果验证</h2><p>多头注意力的有效性已被大量实验证实，其性能优势主要体现在三个维度：</p><h3 id="7-1-基准任务性能突破">7.1 基准任务性能突破</h3><p>在Transformer原论文的机器翻译任务中，8头注意力模型在WMT 2014英德翻译任务上达到28.4 BLEU分数，比当时最优的RNN模型提升2.0分；在WMT 2014英法翻译任务上达到41.8 BLEU分数，提升1.5分。后续BERT模型通过12头注意力设计，在GLUE基准测试中刷新11项任务的最优结果，充分证明了多头注意力的表示能力。</p><h3 id="7-2-头数与性能的关系">7.2 头数与性能的关系</h3><p>消融实验显示，头数对性能的影响呈&quot;边际效益递减&quot;规律：当头数从1增加到8时，模型性能显著提升；从8增加到16时，性能提升幅度小于1%；超过16后，性能甚至出现下降（可能因参数冗余导致过拟合）。这解释了为何主流大模型（GPT-3采用96头，PaLM采用128头）会根据模型规模合理配置头数。</p><h3 id="7-3-功能特化的实证证据">7.3 功能特化的实证证据</h3><p>通过注意力权重可视化发现，在句子&quot;She bought the book because it was interesting&quot;中：</p><ul><li>头1专注于&quot;She&quot;与&quot;bought&quot;的主谓关系；</li><li>头3聚焦于&quot;it&quot;与&quot;book&quot;的指代关系；</li><li>头5关注&quot;because&quot;引导的因果关联。<br>这种特化能力使模型能像人类一样从多角度理解文本，是其超越传统模型的核心原因。</li></ul><h2 id="8-多头注意力面临的核心问题">8. 多头注意力面临的核心问题</h2><p>尽管性能优异，多头注意力仍存在三大核心瓶颈，制约了其在更广泛场景的应用：</p><h3 id="8-1-计算复杂度高昂">8.1 计算复杂度高昂</h3><p>多头注意力的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo>⋅</mo><msup><mi>n</mi><mn>2</mn></msup><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h \cdot n^2 \cdot d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，与序列长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的平方成正比。当处理长序列（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n=1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span></span>）时，注意力计算量占模型总计算量的60%以上；当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>8192</mn></mrow><annotation encoding="application/x-tex">n=8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span></span></span></span>时，计算量将增加64倍，远超GPU显存承载能力。例如，GPT-3处理1024token序列时，单次注意力计算需占用12GB显存，而长文档处理（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>32768</mn></mrow><annotation encoding="application/x-tex">n=32768</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span></span></span></span>）则需TB级显存。</p><h3 id="8-2-注意力头冗余">8.2 注意力头冗余</h3><p>大量剪枝实验表明，多头注意力存在严重的参数冗余。在BERT模型中，60%的注意力头被移除后，MultiNLI任务的准确率仅下降1.2%；在机器翻译任务中，移除50%的头后BLEU分数损失小于0.5%。这些冗余头不仅增加了计算成本，还可能引入噪声，影响模型泛化能力。</p><h3 id="8-3-长序列建模困境">8.3 长序列建模困境</h3><p>传统多头注意力难以处理超长序列（如法律文档、基因组序列）：一方面，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的复杂度导致计算不可行；另一方面，全局注意力权重分布过于分散，模型难以聚焦关键信息。例如，处理10000token的医学文献时，传统多头注意力的注意力权重熵值比短序列高3倍，关键信息捕捉能力显著下降。</p><h2 id="9-问题的解决方案与原理">9. 问题的解决方案与原理</h2><p>针对上述问题，研究界提出了四类核心优化策略，均已在实际应用中验证了有效性：</p><h3 id="9-1-稀疏化策略：降低计算复杂度">9.1 稀疏化策略：降低计算复杂度</h3><p>稀疏化策略通过减少注意力连接数量，将稠密注意力矩阵转化为稀疏形式，核心方法包括：</p><ul><li><strong>局部窗口注意力</strong>：如Longformer采用固定大小窗口（如512token），仅计算窗口内的注意力，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。在PG-19长文档数据集上，该方法比全注意力快3倍，困惑度损失小于0.5%；</li><li><strong>随机稀疏注意力</strong>：如BigBird随机选择部分token进行全局注意力计算，兼顾局部与全局信息。在PubMed长文本分类任务中，其性能比全注意力高2.3%，计算量降低70%；</li><li><strong>哈希注意力</strong>：如Reformer通过局部敏感哈希（LSH）将相似token聚类，仅计算同簇内注意力。在Enwik8压缩任务中，该方法节省内存60%，速度提升2.1倍。</li></ul><p><strong>有效性原理</strong>：人类阅读文本时也仅关注局部连贯信息和少量关键节点，稀疏化策略模拟了这种认知模式，通过保留&quot;局部密集+全局稀疏&quot;的注意力连接，在牺牲极小信息损失的前提下实现复杂度优化。硬件层面，NVIDIA Ampere架构对32×32块稀疏矩阵提供10倍于稠密矩阵的计算效率，进一步放大了稀疏化的优势。</p><h3 id="9-2-注意力头剪枝：消除冗余">9.2 注意力头剪枝：消除冗余</h3><p>头剪枝通过识别并移除冗余注意力头，在保持性能的同时减少参数和计算量，主要方法包括：</p><ul><li><strong>基于梯度的剪枝</strong>：计算移除每个头后的损失变化（一阶近似），优先剪枝损失影响最小的头。在BERT模型上，该方法可剪枝60%的头，参数减少25%，推理速度提升30%；</li><li><strong>功能导向剪枝</strong>：保留负责核心功能（如语法建模、长距离依赖）的头，移除功能重复的头。Voita等人的研究表明，仅保留12个&quot;核心头&quot;即可维持BERT模型95%的性能；</li><li><strong>动态剪枝</strong>：如Switch Transformer通过门控网络动态激活当前样本所需的注意力头，平均激活率仅为20%，推理速度提升4倍。</li></ul><p><strong>有效性原理</strong>：注意力头的功能特化导致大量头承担相似角色，剪枝仅移除&quot;功能冗余&quot;的头，而非&quot;功能独特&quot;的核心头。实验显示，剪枝后的模型注意力权重分布更集中，泛化能力反而略有提升。</p><h3 id="9-3-低秩近似：压缩注意力矩阵">9.3 低秩近似：压缩注意力矩阵</h3><p>低秩近似通过矩阵分解技术将高维注意力矩阵表示为低秩矩阵乘积，核心方法包括：</p><ul><li><strong>Linformer</strong>：将K、V矩阵通过低秩投影矩阵映射到低维空间，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nr)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>为低秩维度）。在GLUE基准测试中，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">r=128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>时，其性能与BERT相差小于1%，计算量降低60%；</li><li><strong>Performer</strong>：采用正余弦函数将注意力核映射为低维特征，避免显式计算注意力矩阵。在长序列分类任务中，其训练速度比全注意力快5倍，显存占用减少80%。</li></ul><p><strong>有效性原理</strong>：注意力矩阵本质上具有低秩特性——序列中相似token的注意力权重高度相关，可通过少量基向量线性表示。低秩近似通过捕捉这种结构特性，用少量参数保留核心信息，同时规避高维矩阵运算。</p><h3 id="9-4-动态注意力机制：适配长序列">9.4 动态注意力机制：适配长序列</h3><p>动态注意力机制根据输入内容自适应调整注意力范围，核心方法包括：</p><ul><li><strong>自适应窗口注意力</strong>：如Extended Transformer Construction（ETC）对关键token采用大窗口，对普通token采用小窗口。在16384token的长文档摘要任务中，其性能比固定窗口方法高3.1%；</li><li><strong>可学习注意力范围</strong>：如Long Short-Term Transformer（LST）通过学习每个token的注意力半径，实现动态范围调整。在视频分类任务中，该方法可捕捉从帧内细节到跨秒动作的多尺度信息。</li></ul><p><strong>有效性原理</strong>：长序列中不同token的信息重要性差异显著（如文档标题与注释），动态注意力机制通过为重要token分配更大的注意力范围，实现&quot;资源向关键信息倾斜&quot;，解决了全局注意力的分散化问题。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 计算公式 </tag>
            
            <tag> 多头注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂QKV</title>
      <link href="/2023/08/22/transformer/QKV/"/>
      <url>/2023/08/22/transformer/QKV/</url>
      
        <content type="html"><![CDATA[<h1>QKV：Transformer注意力机制的核心范式</h1><h2 id="1-qkv的起源与本质">1. QKV的起源与本质</h2><p>QKV（Query-Key-Value，查询-键-值）并非独立存在的结构，而是Transformer模型为实现<strong>结构化注意力交互</strong>而设计的核心组件。其本质是对Transformer输入向量（词嵌入与位置编码的融合表示）进行三次独立线性变换，从而将输入的单一语义表征拆分为三种功能差异化的向量，为后续注意力权重的计算与信息聚合提供范式支撑。</p><h2 id="2-qkv的前置输入：transformer的基础表征">2. QKV的前置输入：Transformer的基础表征</h2><p>Transformer处理的是固定长度的离散序列（如文本中的词汇、图像中的patch），需先将序列元素转化为连续的高维向量，该过程由<strong>词嵌入</strong>与<strong>位置编码</strong>两步完成，最终形成QKV的生成基础——输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>。</p><h3 id="2-1-词嵌入-word-embedding">2.1 词嵌入（Word Embedding）</h3><p>词嵌入的核心作用是将离散的符号化Token（如文本中的单词“apple”）映射至连续的低维实数向量空间，生成具有语义区分度的表征。其数学定义为：设序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，模型维度（即嵌入向量维度）为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则词嵌入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>V</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">E \in \mathbb{R}^{V \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>为词汇表大小）通过查表操作与Token的独热编码（One-Hot Encoding）相乘，得到词嵌入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>m</mi><mi>b</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Emb \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。<br>该向量不仅能捕捉Token的固有语义（如“苹果”与“水果”的语义关联性），还可通过预训练（如Word2Vec、BERT预训练嵌入）引入通用语言知识，为后续QKV的语义交互奠定基础。</p><h3 id="2-2-位置编码-positional-encoding">2.2 位置编码（Positional Encoding）</h3><p>由于Transformer无循环或卷积结构，无法天然捕捉序列的时序/位置信息，因此需通过<strong>位置编码</strong>将位置特征注入词嵌入。位置编码需满足两个核心性质：1）不同位置对应不同编码向量；2）位置编码的差值仅与Token间的相对距离相关（平移不变性）。<br>常见的位置编码实现包括<strong>正弦-余弦编码</strong>与<strong>可学习位置编码</strong>：</p><ul><li>正弦-余弦编码（固定式）：对第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>个位置、第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>维的编码值，定义为：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>i</mi><mtext> 为偶数</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>i</mi><mtext> 为奇数</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">PE_{pos,i} = \begin{cases} \sin\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right) &amp; \text{若} \ i \ 为偶数 \\\cos\left(\frac{pos}{10000^{2(i-1)/d_{\text{model}}}}\right) &amp; \text{若} \ i \ 为奇数 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.564755em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932071428571429em;"><span style="top:-2.893207142857143em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43524499999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.564755em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932071428571429em;"><span style="top:-2.893207142857143em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43524499999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace"> </span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">偶</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace"> </span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">奇</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>该编码无需训练，可直接生成与词嵌入同维度的位置编码矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">PE \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。</li><li>可学习位置编码（参数化）：通过训练一个可学习矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mi>θ</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">PE_{\theta} \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，使模型自主学习适配任务的位置特征。</li></ul><h3 id="2-3-最终输入向量x">2.3 最终输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></h3><p>词嵌入与位置编码通过元素级加法融合，形成Transformer的基础输入向量：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>E</mi><mi>m</mi><mi>b</mi><mo>+</mo><mi>P</mi><mi>E</mi><mo separator="true">,</mo><mspace width="1em"/><mi>X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">X = Emb + PE, \quad X \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>该向量同时包含Token的语义信息与位置信息，是QKV生成的唯一数据源。</p><h2 id="3-qkv的生成：线性变换与功能分化">3. QKV的生成：线性变换与功能分化</h2><p>输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>通过三个独立的<strong>线性变换层</strong>（无非线性激活函数）生成Q、K、V，三者的维度设计与参数学习均服务于注意力机制的“查询-匹配-聚合”逻辑。</p><h3 id="3-1-核心定义与数学表达">3.1 核心定义与数学表达</h3><p>设注意力头数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>（多头注意力的基础参数），为使每头注意力的计算复杂度可控，通常令Q与K的维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mtext>model</mtext></msub><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">d_k = \frac{d_{\text{model}}}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2469679999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9019679999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，V的维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub><mo>=</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_v = d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（简化后续矩阵运算）。三个线性变换的数学表达如下：</p><table><thead><tr><th>向量类型</th><th>计算公式</th><th>参数矩阵</th><th>输出维度</th><th>核心功能</th></tr></thead><tbody><tr><td>Query（Q）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">Q = X \cdot W_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_q \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“查询方”，引导注意力聚焦方向</td></tr><tr><td>Key（K）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">K = X \cdot W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_k \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“匹配方”，提供语义匹配特征</td></tr><tr><td>Value（V）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">V = X \cdot W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>v</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_v \in \mathbb{R}^{d_{\text{model}} \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V \in \mathbb{R}^{L \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“信息方”，承载待聚合的语义信息</td></tr></tbody></table><h3 id="3-2-关键特性">3.2 关键特性</h3><ul><li><strong>参数独立性</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_q, W_k, W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为三个完全独立的可学习参数矩阵，模型可通过训练自主优化三者的语义表征，实现Q的“查询能力”、K的“匹配能力”与V的“信息传递能力”的差异化优化。</li><li><strong>维度一致性</strong>：Q与K的维度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，确保二者可通过点积计算相似度；V的维度与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一致，简化注意力输出与后续层的维度衔接。</li></ul><h2 id="4-qkv的作用：注意力机制的完整流程">4. QKV的作用：注意力机制的完整流程</h2><p>QKV的核心价值在于支撑<strong>缩放点积注意力（Scaled Dot-Product Attention）</strong> 的计算，该过程可分为“分数计算-缩放-掩码-权重分配与信息聚合”四步，最终输出融合全局上下文的注意力向量。</p><h3 id="4-1-步骤1：注意力分数计算-query与key的匹配">4.1 步骤1：注意力分数计算（Query与Key的匹配）</h3><p>注意力分数衡量“每个Query与每个Key的语义相关度”，通过Q与K的转置矩阵点积实现。设查询序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">L_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、键序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">L_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（自注意力中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>=</mo><msub><mi>L</mi><mi>k</mi></msub><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L_q = L_k = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），则分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>L</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">S \in \mathbb{R}^{L_q \times L_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.841331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.841331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>的计算式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">S = Q \cdot K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>矩阵中元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个Query（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">Q_i \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）与第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个Key（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>j</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">K_j \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）的语义匹配度，值越大表示二者关联越强。</p><h3 id="4-2-步骤2：注意力缩放-缓解梯度饱和">4.2 步骤2：注意力缩放（缓解梯度饱和）</h3><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>较大时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">Q \cdot K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的元素值会随<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>增大而显著增大（若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的元素服从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>分布，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的方差为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。过大的输入会导致softmax函数进入<strong>梯度饱和区</strong>（输出趋近于0或1），梯度趋近于0，模型训练停滞。<br>为解决该问题，需对分数矩阵进行缩放，使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的方差归一化为1：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>scaled</mtext></msub><mo>=</mo><mfrac><mi>S</mi><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo>=</mo><mfrac><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">S_{\text{scaled}} = \frac{S}{\sqrt{d_k}} = \frac{Q \cdot K^T}{\sqrt{d_k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">scaled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29033em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="4-3-步骤3：掩码操作-约束注意力范围">4.3 步骤3：掩码操作（约束注意力范围）</h3><p>掩码（Mask）是可选但关键的步骤，用于屏蔽无效或需限制的注意力交互，常见类型包括：</p><ul><li><strong>因果掩码（Causal Mask）</strong>：主要用于Transformer解码器，通过将分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>scaled</mtext></msub></mrow><annotation encoding="application/x-tex">S_{\text{scaled}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">scaled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中“未来位置”的元素设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>，使当前Query无法关注后续Token（如文本生成中避免“偷看”未来词）。</li><li><strong>填充掩码（Padding Mask）</strong>：用于屏蔽序列中的无效填充Token（如为统一序列长度而添加的“[PAD]”），通过将填充位置对应的分数设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>，避免模型对无意义信息分配注意力。</li></ul><h3 id="4-4-步骤4：softmax归一化与信息聚合">4.4 步骤4：Softmax归一化与信息聚合</h3><ol><li><strong>权重归一化</strong>：对掩码后的分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>masked</mtext></msub></mrow><annotation encoding="application/x-tex">S_{\text{masked}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应用softmax函数，将分数转化为求和为1的注意力权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>L</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">A \in \mathbb{R}^{L_q \times L_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.841331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.841331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，表示每个Key对Query的贡献占比：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mtext>Softmax</mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mtext>masked</mtext></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mtext>masked</mtext><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>L</mi><mi>k</mi></msub></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mtext>masked</mtext><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">A = \text{Softmax}(S_{\text{masked}}), \quad A_{i,j} = \frac{\exp(S_{\text{masked},i,j})}{\sum_{t=1}^{L_k} \exp(S_{\text{masked},i,t})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord">Softmax</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.597941em;vertical-align:-1.170941em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.170941em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><strong>信息聚合</strong>：将注意力权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>与Value矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>（设长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">L_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，自注意力中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L_v = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>）相乘，得到最终的注意力输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">O \in \mathbb{R}^{L_q \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，每个Query对应一个融合全局相关信息的向量：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mi>A</mi><mo>⋅</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">O = A \cdot V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span></p>该过程实现了“按语义相关性加权聚合信息”的核心目标，是Transformer捕捉全局依赖的关键。</li></ol><h2 id="5-为什么需要qkv：从-单向量复用-到-三阶交互">5. 为什么需要QKV：从“单向量复用”到“三阶交互”</h2><p>QKV的设计源于对早期注意力机制（如Bahdanau注意力、Luong注意力）的优化，核心是解决“单向量复用”范式的灵活性不足问题。</p><h3 id="5-1-早期注意力机制的局限">5.1 早期注意力机制的局限</h3><p>早期注意力采用“输入向量复用”模式，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>K</mi><mo>=</mo><mi>V</mi><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Q=K=V=X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>为输入向量），该模式存在两大缺陷：</p><ol><li><strong>功能耦合</strong>：同一向量需同时承担“查询引导”“匹配判断”“信息传递”三种功能，无法针对性优化某一环节的表征能力；</li><li><strong>场景受限</strong>：仅能建模输入自身的单一关联（如文本序列内部的依赖），无法适配跨模态（如文本-图像匹配）、跨序列（如编码器-解码器交互）等复杂任务——此类任务需“查询来自源模态/序列，键与值来自目标模态/序列”的灵活交互模式。</li></ol><h3 id="5-2-qkv的优势：三阶交互范式">5.2 QKV的优势：三阶交互范式</h3><p>QKV通过“分离式线性变换”构建<strong>查询-键-值三阶交互范式</strong>，实现三大突破：</p><ol><li><strong>功能解耦</strong>：Q专注于“what to look for”（需要什么信息），K专注于“what to match”（提供匹配特征），V专注于“what to provide”（传递有用信息），三者可通过独立参数优化适配不同功能需求；</li><li><strong>场景泛化</strong>：支持“Q与K/V来源分离”（如交叉注意力中Q来自解码器，K/V来自编码器），可直接应用于机器翻译、图文检索、语音识别等跨模态/跨序列任务；</li><li><strong>细粒度关联</strong>：通过独立优化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_q, W_k, W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，模型可捕捉更细粒度的语义关联（如Q侧重“动作”，K侧重“实体”，V侧重“属性”），提升表征的丰富性。</li></ol><h2 id="6-qkv对transformer的贡献：支撑全局依赖与并行计算">6. QKV对Transformer的贡献：支撑全局依赖与并行计算</h2><p>QKV是Transformer实现“全局依赖捕捉”与“并行化计算”两大核心能力的载体，其作用通过<strong>自注意力</strong>与<strong>交叉注意力</strong>两种模式体现。</p><h3 id="6-1-自注意力-self-attention-：捕捉序列内部全局依赖">6.1 自注意力（Self-Attention）：捕捉序列内部全局依赖</h3><p>自注意力中，Q、K、V均来源于<strong>同一输入序列</strong>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><mi>K</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>V</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">Q=X W_q, K=X W_k, V=X W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>为单一序列的输入向量），其贡献在于：</p><ol><li><strong>全局依赖捕捉</strong>：每个Token可直接与序列中所有其他Token计算注意力，无需像RNN那样按顺序迭代，突破了“局部依赖优先”的限制；</li><li><strong>并行化效率</strong>：注意力分数计算、权重归一化、信息聚合均为矩阵运算，可通过GPU并行加速，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（远低于RNN的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msubsup><mi>d</mi><mtext>model</mtext><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_{\text{model}}^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.2831079999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），显著提升长序列处理效率。</li></ol><h3 id="6-2-交叉注意力-cross-attention-：实现跨序列-模态信息交互">6.2 交叉注意力（Cross-Attention）：实现跨序列/模态信息交互</h3><p>交叉注意力中，Q与K/V来源于<strong>不同序列/模态</strong>（如机器翻译中，Q来自解码器当前步输出，K/V来自编码器的源文本序列），其贡献在于：</p><ol><li><strong>跨域语义对齐</strong>：建立源序列（如英文）与目标序列（如中文）的语义关联，是编码器-解码器架构实现翻译、摘要等任务的核心；</li><li><strong>模态融合</strong>：在跨模态任务中（如图文生成），Q来自文本序列（需生成的描述），K/V来自图像的patch序列，可实现“文本查询引导图像信息聚合”，生成与图像内容匹配的文本。</li></ol><h2 id="7-qkv的核心问题：复杂度与长序列挑战">7. QKV的核心问题：复杂度与长序列挑战</h2><p>尽管QKV是Transformer的核心，但随序列长度增长，其固有的计算特性会引发一系列问题，限制模型在长序列任务（如文档级NLP、高分辨率图像生成）中的应用。</p><h3 id="7-1-计算复杂度高：平方级增长瓶颈">7.1 计算复杂度高：平方级增长瓶颈</h3><p>QKV的时间复杂度与空间复杂度均随序列长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>呈<strong>平方级增长</strong>：</p><ul><li>时间复杂度：注意力分数计算（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）+ 权重-Value相乘（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），总复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mtext>model</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_{\text{model}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（因<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>=</mo><mi>h</mi><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}} = h d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）；</li><li>空间复杂度：需存储Q（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）、K（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）、V（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）及分数矩阵（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">L=10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>时，分数矩阵的元素数可达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，远超普通GPU的内存承载能力。</li></ul><h3 id="7-2-长距离稀释：注意力权重分散">7.2 长距离稀释：注意力权重分散</h3><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>增大时，softmax输出的注意力权重会<strong>均匀分散</strong>到大量Key上，导致“长距离且语义相关的Key”无法获得足够权重——该现象称为“长距离依赖稀释”。其本质是：注意力权重的分布熵随<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>增大而升高，单个Query的注意力被“无关Key”稀释，无法聚焦于核心信息。</p><h3 id="7-3-信息冗余：q-k-v表征相关性过高">7.3 信息冗余：Q-K-V表征相关性过高</h3><p>尽管Q、K、V由独立参数生成，但三者均源于同一输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的线性变换，导致其语义表征存在<strong>高度相关性</strong>。这种冗余不仅增加了模型的参数总量（三个矩阵而非一个），还可能使模型对噪声特征过度拟合（如Q与K的相关性过高，导致匹配分数偏差），降低泛化能力。</p><h3 id="7-4-异常值敏感：匹配分数失衡">7.4 异常值敏感：匹配分数失衡</h3><p>Q与K的点积运算对<strong>异常值</strong>（如词嵌入初始化偏差、噪声导致的极大/极小元素）高度敏感：若K中某一向量存在异常值，其与所有Q的匹配分数会被异常放大，导致softmax权重向该K倾斜，模型过度关注无关信息，忽略核心语义。</p><h2 id="8-qkv问题的解决方案：从效率优化到表征增强">8. QKV问题的解决方案：从效率优化到表征增强</h2><p>针对QKV的上述问题，学界提出了一系列优化方案，可分为“计算复杂度优化”“长距离稀释缓解”“冗余与异常值处理”三类。</p><h3 id="8-1-降低计算复杂度：稀疏化与低秩近似">8.1 降低计算复杂度：稀疏化与低秩近似</h3><h4 id="8-1-1-稀疏注意力-sparse-attention">8.1.1 稀疏注意力（Sparse Attention）</h4><p>核心思路：<strong>限制Q与K的交互范围</strong>，将全量注意力（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）转化为稀疏交互，典型方案包括：</p><ul><li>局部稀疏注意力：每个Q仅与自身周围固定窗口内的K交互（如窗口大小为5，Q仅关注左右各2个K），复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo>⋅</mo><mi>W</mi><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L \cdot W \cdot d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>为窗口大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>≪</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">W \ll L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），代表模型为Longformer；</li><li>全局稀疏注意力：通过规则或采样选取部分“关键K”与Q交互，如Reformer的LSH（Locality-Sensitive Hashing）注意力——将相似的Q-K映射至同一哈希桶，仅在桶内计算注意力，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>log</mi><mo>⁡</mo><mi>L</mi><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L \log L \cdot d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul><h4 id="8-1-2-低秩近似-low-rank-approximation">8.1.2 低秩近似（Low-Rank Approximation）</h4><p>核心思路：假设KV矩阵具有<strong>低秩结构</strong>，通过矩阵分解或投影降低维度，典型方案包括：</p><ul><li>Linformer：对K、V分别施加线性投影（投影维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>≪</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">E \ll L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），将K转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>E</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K&#x27; \in \mathbb{R}^{E \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，V转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>E</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V&#x27; \in \mathbb{R}^{E \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，注意力计算变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mrow><mo mathvariant="normal">′</mo><mi>T</mi></mrow></msup><mo>⋅</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Q \cdot K&#x27;^T \cdot V&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>E</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L E d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li><li>Performer：将点积注意力转化为基于正交集函数的核注意力（如随机傅里叶特征映射），通过低秩近似模拟全量注意力效果，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k \log d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul><h3 id="8-2-缓解长距离稀释：强化远距离关联">8.2 缓解长距离稀释：强化远距离关联</h3><h4 id="8-2-1-相对位置编码-relative-positional-encoding">8.2.1 相对位置编码（Relative Positional Encoding）</h4><p>传统位置编码仅注入绝对位置信息，无法区分Q-K的相对距离。相对位置编码通过在注意力分数中引入<strong>Q-K相对距离向量</strong>，直接建模位置依赖，代表方案为Transformer-XL：<br>修正后的注意力分数为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>Q</mi><mi>i</mi></msub><mo>+</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mi>K</mi><mi>j</mi><mi>T</mi></msubsup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">S_{i,j} = \frac{(Q_i + R_{i-j}) \cdot K_j^T}{\sqrt{d_k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5561030000000002em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.626103em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">R_{i-j} \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>为Q的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个位置与K的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个位置的相对位置向量，模型可通过该向量为“远距离但语义相关的Q-K”分配更高权重。</p><h4 id="8-2-2-记忆机制-memory-mechanism">8.2.2 记忆机制（Memory Mechanism）</h4><p>核心思路：<strong>缓存历史序列的KV信息</strong>，使当前Q可与历史KV交互，突破固定序列长度限制，代表方案为Transformer-XL与Recurrent Transformer：</p><ul><li>Transformer-XL：将前一段序列的KV缓存为“记忆单元”（Memory Cache），当前段Q在计算注意力时，同时与当前KV和记忆KV交互，相当于“记住”了更早的序列信息；</li><li>Recurrent Transformer：将KV缓存设计为循环门控单元（如LSTM的门控机制），动态更新记忆内容，优先保留长距离关键信息。</li></ul><h4 id="8-2-3-核函数注意力-kernel-attention">8.2.3 核函数注意力（Kernel Attention）</h4><p>通过将点积注意力替换为<strong>非线性核函数</strong>，增强对远距离Q-K语义关联的捕捉能力，典型核函数为径向基函数（RBF）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><msub><mi>Q</mi><mi>i</mi></msub><mo>−</mo><msub><mi>K</mi><mi>j</mi></msub><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">S_{i,j} = \exp\left(-\frac{\|Q_i - K_j\|^2}{2\sigma^2}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.441138em;vertical-align:-0.95003em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911079999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∥</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>为可学习的核宽度参数。该函数通过欧式距离的非线性映射，使语义相近但位置较远的Q-K仍能获得较高分数，缓解长距离稀释。</p><h3 id="8-3-解决信息冗余的问题">8.3 解决信息冗余的问题</h3><p>QKV虽经独立变换，但三者承载的语义信息高度重叠，例如（Q和K）均需编码语义匹配特征，V需编码信息传递特征。解决方案是<strong>拆分Q和K之间的功能边界</strong>或<strong>减少冗余参数/特征</strong>，在不损失性能的前提下降低复杂度。</p><h4 id="8-3-1-解纠缠注意力机制">8.3.1 解纠缠注意力机制</h4><p>代表模型如DeBERTa模型，将Q和K拆分为内容向量和位置向量两部分：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>Q</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>Q</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><mi>K</mi><mo>=</mo><msub><mi>K</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>K</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Q = Q_{content} + Q_{position},K = K_{content} + K_{position}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>将注意力分数拆分为<strong>内容相似度</strong>和<strong>位置相似度</strong>，二者加权后再缩放。这种设计让Q和K的功能更加明确，内容向量负责语义匹配，位置向量负责位置信息关联，避免单一向量同时编码两种信息导致信息冗余，同时V仅需要聚焦于信息的传递。</p><h4 id="8-3-2-q和v参数共享与维度压缩">8.3.2 Q和V参数共享与维度压缩</h4><p>针对参数冗余，可使用跨层参数共享或维度拆分来减少参数数量：<br>（1）跨层共享：将不同层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">W_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>参数共享（或部分共享），避免每层学习独立的线性编码，参数量可减少70%以上，同时缓解信息冗余。<br>（2）维度压缩：在生成QKV之前，先将输入向量维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>压缩到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">d_{\text{model}}/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span></span></span></span>，再进行注意力变换，最后通过注意力输出恢复维度。压缩过程会自动过滤冗余特征，同时保留核心信息，降低计算量。</p><h4 id="8-3-3-注意力蒸馏">8.3.3 注意力蒸馏</h4><p>通过教师模型指导学生模型学习，让学生模型中的QKV仅保留教师模型中关键的注意力模式，剔除冗余信息。例如：<br>（1）教师模型使用全量的QKV，学生模型使用维度减半的QKV。<br>（2）训练时使学生模型的注意力权重尽可能接近教师模型，迫使学生模型仅学习核心关联，减少信息冗余。</p><h3 id="8-4-解决对异常值敏感的问题">8.4 解决对异常值敏感的问题</h3><p>Q和K中存在异常的元素时，Q和V之间的点积会被过度放大，导致Softmax输出极端权重，破坏注意力机制的全局关联。解决方案是<strong>限制异常值的范围</strong>和<strong>使用更加稳健的相似度度量</strong>。</p><h4 id="8-4-1-q和k进行归一化">8.4.1 Q和K进行归一化</h4><p>在计算Q和K的点积之前，先对Q和K进行归一化，消除异常值的量级影响。<br>（1）LayerNorm归一化：将Q、K和V先进行归一化后再进行点积。<br>（2）L2归一化：对Q的每个行向量和K的每个列向量进行L2归一化，再计算点积。此时Q和V的计算近似于余弦相似度，数值稳定在[-1,1]。</p><h4 id="8-4-2-点积剪辑">8.4.2 点积剪辑</h4><p>对Q和K的点积结果进行剪辑，将超出阈值的数值限定在固定范围内，例如限制剪辑阈值T，则剪辑后的分数为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>c</mi><mi>l</mi><mi>i</mi><mi>p</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score_{clip} = min(Q \cdot K^T, T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p><p>其中T可以通过超参数搜索进行确定，确保异常值不会被过度地放大相似度，同时不影响正常范围内的关联计算。</p><h4 id="8-4-3-稳健相似度替换">8.4.3 稳健相似度替换</h4><p>采用对异常值更稳健的相似度度量替换点积，例如曼哈顿距离（Manhattan Distance），相似度计算为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>=</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><msub><mi>Q</mi><mi>i</mi></msub><mo>−</mo><msub><mi>K</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score = - sum(|Q_i - K_j|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></span></p><p>通过绝对值代替平方，减少异常值的影响权重。这类度量在处理噪声值较多的数据时能有效提升QKV的稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自注意力机制</title>
      <link href="/2023/08/22/transformer/self-attenion/"/>
      <url>/2023/08/22/transformer/self-attenion/</url>
      
        <content type="html"><![CDATA[<h1>自注意力机制</h1><h2 id="自注意力机制公式">自注意力机制公式</h2><p>self-attention = Softmax(QK^T / sqrt(d_k))*V</p><h3 id="为什么要对qk-t进行缩放">为什么要对QK^T进行缩放</h3><p>（1）这样可以对数值进行缩放，避免QK^T的数值过大，导致Softmax函数的输出结果接近于0，从而影响模型的训练。<br>（2）在模型训练时QK^T的数值范围分布更加均匀，避免梯度消失和梯度爆炸的问题。</p><h3 id="self-attention一定要这样表达吗？有无其他的计算方式">self-attention一定要这样表达吗？有无其他的计算方式</h3><p>不需要，self-attention公式只要起到相同的作用即可，下面是不同的变体：<br>（1）Linformer:对K和V做低秩投影：用E、F将K,V从n乘dk压缩到k乘d_k;注意力分数计算变为QK^T * E * F^T / sqrt(d_k),再与F^T * V加权。<br>（2）Performer:利用正定核函数（如RBF核）将Softmax注意力近似为：Softmax(QK^T/sqrt(d_k))约等于R(Q)*R(K)^T。直接计算R(Q) * R(K)^T避免全量计算。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>softmax</title>
      <link href="/2023/08/22/transformer/softmax/"/>
      <url>/2023/08/22/transformer/softmax/</url>
      
        <content type="html"><![CDATA[<h1>Softmax公式</h1><p>输入向量为x = [x1, x2, x3, …, xn]<br>输出为：</p><p>Softmax(x) = exp(x_i) / sum(exp(x_j))</p><h1>Softmax的作用</h1><p>Softmax函数的作用是将一个向量映射到一个概率分布上，使得每一个元素的取值都在0到1之间，并且所有元素之和为1,在这过程中会放大元素之间的差异</p><p>（1）分类任务中的概率输出：在图像任务中，模型最后的输出的Logits没有实际意义，需要通过Softmax函数将其转换为概率分布，才能进行分类。<br>（2）交叉熵损失：CrossEntropyLoss = Softmax+NLLLoss,其中，NLLLoss = -log(Softmax(x_i))，这样可以直接计算出模型的预测概率与真实标签的差异。</p><h1>Softmax的问题</h1><p>（1）数值溢出\下溢问题：当输入向量的元素值很大时，exp(x_i)会溢出，导致计算结果为NaN；当元素值很小时，exp(x_i)会下溢，导致计算结果为0。<br>（2）独热问题：当Softmax的输出接近独热向量时，交叉熵损失的数值会集中在独热向量上，这会导致模型过度自信，无法关注错误类别的梯度，即梯度稀疏。<br>（3）异常值敏感问题：Softmax的输入向量中存在异常值的话，会扭曲整个计算过程中的概率分布，导致梯度集中在异常值对应的位置，这会影响模型的训练。</p><h1>Softmax的问题解决方案</h1><p>（1）数值溢出\下溢问题：通过减少输入向量中的最大值避免溢出，log(sum(exp(x_j))) = max(x)+log(sum(exp(x_j-max(x)))),此时x_j-max(x)&lt;0,exp(x_j-max(x))&lt;1,彻底避免了数值溢出。<br>（2）独热问题：将真实热标签输出进行平滑处理，迫使模型的输出更平均<br>（3）异常值敏感问题：对输入进行预处理</p><h1>Softmax函数的变体</h1><p>(1) LogSoftmax，直接对Softmax的结果取对数，LogSoftmax(x) = log(exp(x) / sum(exp(x))) = x - log(sum(exp(x)))。这样做的好处是可以解决下溢的问题<br>(2) 温度缩放Softmax：在Softmax函数中，引入一个温度系数T，Softmax(x) = exp(x/T)/sum(exp(x/T))。当T=1时，退化为标准Softmax函数，T&gt;1时，输出的分布会更加平均，T&lt;1时输出被放大，输出会更加尖锐。<br>(3) 稀疏Softmax：通过L1正则化，强制Softmax的输出部分元素非0，其余元素皆为0，这样可以增强模型的可解释性</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416分割等和子集</title>
      <link href="/2023/08/10/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>/2023/08/10/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>416分割等和子集</h1><h2 id="题目描述">题目描述</h2><p>给你一个只包含正整数的非空数值nums,请你判断是否可以将这个数组分为两个子集，使其元素和相等。</p><h2 id="问题分析">问题分析</h2><p>(1)若一个数组nums可以被分为两个子集，那么数组和必定是偶数。<br>(2)问题可以转化为，是否存在一个子集，它的元素和是数组和的一半，这是典型的子集和target问题。</p><h2 id="解题核心与思路">解题核心与思路</h2><p>这是典型的背包问题：<br>（1）每个元素可以选择一次<br>（2）背包容量为数组和的一半<br>（3）是否存在一个子集，它的元素和等于背包容量<br>转化为动态规划问题：<br>（1）dp[i]表示是否可以用数组中的元素组成和为i的子集。<br>（2）初始化dp[0] = true，表示和为0的子集总是存在的。<br>（3）迭代数组nums中的元素n，再从target反向遍历到n,更新dp[j] = dp[j]||dp[j-n]。</p><h2 id="解题代码">解题代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;target)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target<span class="number">+1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=n;j--)&#123;</span><br><span class="line">                dp[j] = dp[j]||dp[j-n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>(1)时间复杂度:O(n*target),其中n是数组的长度，target是数组和的一半。<br>(2)空间复杂度:O(target),使用了一个长度为target+1的数组dp。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 01背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大模型知识点速记</title>
      <link href="/2023/08/10/transformer/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E8%AE%B0/"/>
      <url>/2023/08/10/transformer/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>大模型训练/推理优化：深度碎片化知识点手册（50条）</h1><p>以下知识点延续“核心概念+记忆口诀+关键细节”结构，新增训练进阶、推理深度优化、工具框架、前沿策略四大模块，每条可在2分钟内完成深度理解，适合碎片化系统积累。</p><h2 id="一-训练优化：从基础到进阶-15条">一、训练优化：从基础到进阶（15条）</h2><h3 id="1-混合精度训练-fp8进阶">1. 混合精度训练（FP8进阶）</h3><ul><li><strong>核心逻辑</strong>：在FP16/FP32基础上引入8位浮点数（FP8），进一步压缩计算与内存开销，通过双格式适配平衡速度与精度。</li><li><strong>记忆口诀</strong>：8位算得快，双格式适配，延迟缩放保精度。</li><li><strong>关键细节</strong>：<ul><li>两种FP8格式分工：前向计算用E4M3（更多尾数位，精度更高），反向梯度用E5M2（更多指数位，动态范围更大）；</li><li>依赖Delayed Scaling策略：通过历史最大值缓存估算缩放因子，避免实时计算带来的访存开销。</li></ul></li></ul><h3 id="2-梯度累积-进阶技巧">2. 梯度累积（进阶技巧）</h3><ul><li><strong>核心逻辑</strong>：小批量迭代累积梯度模拟大批量效果，解决显存与最优batch size的矛盾。</li><li><strong>记忆口诀</strong>：小batch攒梯度，N次一更新， lr乘N才等效。</li><li><strong>关键细节</strong>：<ul><li>与梯度裁剪协同：累积过程中需避免梯度中途溢出，建议在每次backward后暂存梯度范数；</li><li>适用局限：不适用于需要batch统计信息的层（如BatchNorm），需改用GroupNorm替代。</li></ul></li></ul><h3 id="3-zero优化-三阶段细分">3. ZeRO优化（三阶段细分）</h3><ul><li><strong>核心逻辑</strong>：通过分区模型状态（优化器、梯度、参数）消除数据并行中的冗余显存占用。</li><li><strong>记忆口诀</strong>：零冗余分区，-stage加一级，显存省一级。</li><li><strong>关键细节</strong>：<ul><li>ZeRO-1：仅分区优化器状态（如Adam的动量项），显存节省40%+；</li><li>ZeRO-2：增加梯度分区，支持更大批量训练，显存节省60%+；</li><li>ZeRO-3：全参数分区，配合CPU/NVMe卸载可运行超大规模模型（如1T参数）。</li></ul></li></ul><h3 id="4-3d并行-混合并行终极方案">4. 3D并行（混合并行终极方案）</h3><ul><li><strong>核心逻辑</strong>：融合数据并行、张量并行、流水线并行，从数据、模型结构、计算流程三维度拆分任务。</li><li><strong>记忆口诀</strong>：数据分样本，张量分矩阵，流水分层级，三管齐下装大模。</li><li><strong>关键细节</strong>：<ul><li>数据并行负责样本拆分，张量并行拆分单层计算，流水线并行拆分模型层级；</li><li>GPT-3采用“数据+张量+流水线”3D并行，支撑175B参数训练。</li></ul></li></ul><h3 id="5-梯度裁剪-两种模式对比">5. 梯度裁剪（两种模式对比）</h3><ul><li><strong>核心逻辑</strong>：通过限制梯度规模防止训练过程中梯度爆炸导致的参数异常。</li><li><strong>记忆口诀</strong>：范数裁剪保整体，元素裁剪控局部，阈值调参防崩溃。</li><li><strong>关键细节</strong>：<ul><li>L2范数裁剪：计算梯度向量的整体范数，超过阈值则等比缩放（适合Transformer）；</li><li>元素裁剪：直接限制单个梯度值的上下界（适合CNN等局部特征敏感模型）。</li></ul></li></ul><h3 id="6-优化器：adamw-vs-lion">6. 优化器：AdamW vs Lion</h3><table><thead><tr><th>类型</th><th>核心机制</th><th>记忆口诀</th><th>适用场景</th></tr></thead><tbody><tr><td>AdamW</td><td>自适应学习率+权重衰减</td><td>自适应稳收敛，细调效果佳</td><td>精调阶段、长文本任务</td></tr><tr><td>Lion</td><td>符号梯度+动量更新</td><td>符号更新快，显存占用低</td><td>预热阶段、低资源训练</td></tr></tbody></table><ul><li><strong>关键细节</strong>：Lion单步训练速度比AdamW快18%，显存占用低25%，但需配合更低学习率（1e-5）避免震荡。</li></ul><h3 id="7-学习率调度-三段式策略">7. 学习率调度（三段式策略）</h3><ul><li><strong>核心逻辑</strong>：分阶段动态调整学习率，平衡收敛速度与泛化能力。</li><li><strong>记忆口诀</strong>：预热防震荡，衰减降损失，微调收最优。</li><li><strong>关键细节</strong>：<ul><li>预热阶段（1000-5000步）：从1e-7线性升至目标lr，避免初始大lr破坏参数分布；</li><li>衰减阶段：用Cosine衰减替代线性衰减，后期缓慢下降保留探索能力；</li><li>微调阶段：降至初始lr的1/10，稳定收敛至最优解。</li></ul></li></ul><h3 id="8-梯度检查点-时间换空间">8. 梯度检查点（时间换空间）</h3><ul><li><strong>核心逻辑</strong>：牺牲部分计算时间，仅保存关键层激活值，反向传播时重新计算中间结果。</li><li><strong>记忆口诀</strong>： checkpoint留关键，反向重算省显存，时间换空间。</li><li><strong>关键细节</strong>：<ul><li>显存节省比例：可减少40%-60%激活值占用，但训练速度下降20%-30%；</li><li>最佳实践：在Transformer的每2-3层设置一个检查点，平衡显存与速度。</li></ul></li></ul><h3 id="9-权重初始化-transformer专属">9. 权重初始化（Transformer专属）</h3><ul><li><strong>核心逻辑</strong>：针对Transformer的残差连接与注意力机制设计初始化策略，避免梯度消失。</li><li><strong>记忆口诀</strong>： Xavier适配线性层，注意力缩放要除d，残差增益需控制。</li><li><strong>关键细节</strong>：<ul><li>线性层用Xavier初始化：按输入输出维度调整方差，避免激活值分布偏移；</li><li>注意力分数除以√d_model：防止点积结果过大导致softmax饱和。</li></ul></li></ul><h3 id="10-batchnorm替代方案-训练显存优化">10. BatchNorm替代方案（训练显存优化）</h3><ul><li><strong>核心逻辑</strong>：用GroupNorm/LayerNorm替代BatchNorm，减少批量依赖与显存占用。</li><li><strong>记忆口诀</strong>：BatchNorm靠批量，小batch用Group，LayerNorm更通用。</li><li><strong>关键细节</strong>：<ul><li>GroupNorm：将通道分组计算均值方差，不受batch size影响，显存占用比BatchNorm低30%；</li><li>大模型首选LayerNorm：每层独立归一化，适配动态batch场景（如对话训练）。</li></ul></li></ul><h3 id="11-数据预处理优化-动态padding">11. 数据预处理优化（动态Padding）</h3><ul><li><strong>核心逻辑</strong>：同一batch内按样本长度动态调整padding长度，减少无效计算。</li><li><strong>记忆口诀</strong>：动态pad随长变，无效计算减一半，缓存分组提效率。</li><li><strong>关键细节</strong>：<ul><li>实现方式：按长度区间分组（如0-64、65-128），同组样本用相同padding；</li><li>配合缓存机制：预生成各长度区间的mask矩阵，避免实时计算。</li></ul></li></ul><h3 id="12-分布式通信优化-nvlink-vs-pcie">12. 分布式通信优化（NVLink vs PCIe）</h3><ul><li><strong>核心逻辑</strong>：选择高效通信链路减少多卡数据传输延迟。</li><li><strong>记忆口诀</strong>：NVLink速度快，PCIe成本低，多卡集群靠前者。</li><li><strong>关键细节</strong>：<ul><li>NVLink带宽：单链路300GB/s，支持8卡全连接，适合张量并行密集通信；</li><li>PCIe 4.0带宽：单链路32GB/s，适合数据并行的低频大流量传输。</li></ul></li></ul><h3 id="13-标签平滑-泛化能力提升">13. 标签平滑（泛化能力提升）</h3><ul><li><strong>核心逻辑</strong>：软化硬标签（如0/1）为概率分布，减少模型对错误标签的过拟合。</li><li><strong>记忆口诀</strong>：标签加平滑，置信降一点，泛化强一点。</li><li><strong>关键细节</strong>：<ul><li>公式：y_smoothed = (1 - ε)×y_true + ε/K（K为类别数）；</li><li>ε取值：分类任务用0.1-0.2，生成任务用0.05（避免模糊语义）。</li></ul></li></ul><h3 id="14-对抗训练-鲁棒性增强">14. 对抗训练（鲁棒性增强）</h3><ul><li><strong>核心逻辑</strong>：在输入中添加微小扰动，迫使模型学习更稳健的特征表示。</li><li><strong>记忆口诀</strong>：加扰造对抗，模型练抗压，鲁棒性不差。</li><li><strong>关键细节</strong>：<ul><li>常用方法：FGSM（快速梯度符号法）生成扰动，扰动强度控制在ε=1e-3；</li><li>适用场景：对齐训练中的事实性增强（减少幻觉）。</li></ul></li></ul><h3 id="15-模型并行-张量并行细分">15. 模型并行（张量并行细分）</h3><ul><li><strong>核心逻辑</strong>：将Transformer层内的张量拆分到多卡，解决单层计算量过大问题。</li><li><strong>记忆口诀</strong>：QKV拆多头，矩阵分块算，结果拼回不丢精。</li><li><strong>关键细节</strong>：<ul><li>拆分维度：注意力头维度（num_heads）或隐藏层维度（hidden_size）；</li><li>通信开销：拆分后仅需交换中间结果，比流水线并行的气泡损失更低。</li></ul></li></ul><h2 id="二-推理优化：从压缩到加速-15条">二、推理优化：从压缩到加速（15条）</h2><h3 id="1-后训练量化-ptq">1. 后训练量化（PTQ）</h3><ul><li><strong>核心逻辑</strong>：训练完成后对模型权重/激活值量化，用少量校准数据统计分布。</li><li><strong>记忆口诀</strong>：训完再量化，校准算参数，快部署精度降不多。</li><li><strong>关键细节</strong>：<ul><li>流程：权重量化（离线计算缩放因子）→ 激活值量化（校准数据统计范围）→ 推理验证；</li><li>适用场景：快速部署、对精度要求中等的场景（如客服机器人）。</li></ul></li></ul><h3 id="2-量化感知训练-qat">2. 量化感知训练（QAT）</h3><ul><li><strong>核心逻辑</strong>：训练过程中嵌入量化模拟操作，让模型适应精度损失。</li><li><strong>记忆口诀</strong>：训练带量化，模型早适应，精度掉得少但耗时久。</li><li><strong>关键细节</strong>：<ul><li>模拟量化：前向传播添加量化/反量化节点，反向传播计算量化误差梯度；</li><li>优势：INT8量化后精度损失可控制在1%以内，远超PTQ的3%-5%。</li></ul></li></ul><h3 id="3-kv缓存优化-滑动窗口">3. KV缓存优化（滑动窗口）</h3><ul><li><strong>核心逻辑</strong>：长序列推理时仅缓存最近的K/V张量，替代全序列缓存。</li><li><strong>记忆口诀</strong>：长文滑窗口，旧KV丢一边，显存省一半。</li><li><strong>关键细节</strong>：<ul><li>实现原理：缓存大小固定为窗口长度（如2048 tokens），新token加入时剔除最早token；</li><li>适用模型：Llama 2、Qwen等支持长上下文的模型，可将10万token推理显存降低70%。</li></ul></li></ul><h3 id="4-算子融合-推理效率核心">4. 算子融合（推理效率核心）</h3><ul><li><strong>核心逻辑</strong>：将多个独立算子（如Linear+LayerNorm+GELU）合并为单一算子，减少内存读写。</li><li><strong>记忆口诀</strong>：算子串成块，读写少一半，速度翻一番。</li><li><strong>关键细节</strong>：<ul><li>常见融合模式：Transformer层内“Attention+Add+Norm”融合、“Linear+激活函数”融合；</li><li>工具依赖：TensorRT自动融合静态算子，TVM支持自定义融合规则。</li></ul></li></ul><h3 id="5-推测解码-speculative-decoding">5. 推测解码（Speculative Decoding）</h3><ul><li><strong>核心逻辑</strong>：用小模型快速预测候选序列，大模型仅验证修正，减少大模型调用次数。</li><li><strong>记忆口诀</strong>：小模型猜，大模型改，快生成还保质量。</li><li><strong>关键细节</strong>：<ul><li>流程：小模型生成K个候选token → 大模型批量验证 → 接受正确token并生成下一个；</li><li>加速比：可提升2-3倍推理速度，候选长度K通常设为5-10。</li></ul></li></ul><h3 id="6-剪枝-结构化vs非结构化">6. 剪枝（结构化vs非结构化）</h3><table><thead><tr><th>类型</th><th>核心逻辑</th><th>记忆口诀</th><th>部署要求</th></tr></thead><tbody><tr><td>结构化剪枝</td><td>剪整个通道/层，保留模型结构</td><td>剪层剪通道，部署无压力</td><td>通用硬件支持</td></tr><tr><td>非结构化剪枝</td><td>剪单个权重，稀疏化连接</td><td>剪单个权重，压缩比更高</td><td>需稀疏计算硬件（如GPU稀疏核）</td></tr></tbody></table><ul><li><strong>关键细节</strong>：剪枝后需微调恢复精度，结构化剪枝精度损失通常&lt;2%，非结构化可低至1%但部署成本高。</li></ul><h3 id="7-知识蒸馏-软标签进阶">7. 知识蒸馏（软标签进阶）</h3><ul><li><strong>核心逻辑</strong>：让学生模型学习老师模型的输出分布（软标签）与中间特征，而非仅硬标签。</li><li><strong>记忆口诀</strong>：学软分布，仿中间层，小模型有大能力。</li><li><strong>关键细节</strong>：<ul><li>温度系数（T）：控制软标签平滑度，T越大分布越平，通常取2-5；</li><li>损失构成：蒸馏损失（占70%）+ 硬标签损失（占30%），平衡泛化与拟合。</li></ul></li></ul><h3 id="8-动态批处理-推理吞吐量优化">8. 动态批处理（推理吞吐量优化）</h3><ul><li><strong>核心逻辑</strong>：动态合并不同时刻的请求，替代静态批处理，减少等待开销。</li><li><strong>记忆口诀</strong>：请求动态合，不等长序列，吞吐提三倍。</li><li><strong>关键细节</strong>：<ul><li>实现方式：按请求到达时间分批，每批满额或超时（如50ms）即处理；</li><li>工具支持：vLLM、TGI（Text Generation Inference）原生支持动态批处理。</li></ul></li></ul><h3 id="9-fp8推理-端到端优化">9. FP8推理（端到端优化）</h3><ul><li><strong>核心逻辑</strong>：训练用FP8的模型可直接以FP8推理，省去量化转换步骤。</li><li><strong>记忆口诀</strong>：训推同用8位，转换省时间，算力翻两倍。</li><li><strong>关键细节</strong>：<ul><li>硬件依赖：H100 GPU的FP8 Tensor Core算力是FP16的2倍；</li><li>精度保障：通过高精度累加（FP32）抵消低精度计算误差。</li></ul></li></ul><h3 id="10-低秩分解-linformer实践">10. 低秩分解（Linformer实践）</h3><ul><li><strong>核心逻辑</strong>：用低秩矩阵投影压缩注意力中的Q/K/V张量，降低计算复杂度。</li><li><strong>记忆口诀</strong>：高秩矩阵拆低秩，注意力复杂度降线性，长文处理不卡顿。</li><li><strong>关键细节</strong>：<ul><li>数学原理：将QK^T的O(n²d)复杂度降至O(nkd)（k≪n）；</li><li>Linformer实现：通过投影矩阵E/F将序列长度从n压缩到k（通常k=256）。</li></ul></li></ul><h3 id="11-flash-attention-内存高效注意力">11. Flash Attention（内存高效注意力）</h3><ul><li><strong>核心逻辑</strong>：通过分块计算与内存复用，避免注意力计算中的中间结果溢出显存。</li><li><strong>记忆口诀</strong>：分块算注意力，内存循环用，速度快还省空间。</li><li><strong>关键细节</strong>：<ul><li>突破点：将注意力计算拆分为小块，利用GPU共享内存（Shared Memory）替代全局内存；</li><li>性能提升：相比标准注意力快2-4倍，显存占用降低90%。</li></ul></li></ul><h3 id="12-模型编译-tvm-mlir">12. 模型编译（TVM/MLIR）</h3><ul><li><strong>核心逻辑</strong>：将模型转换为中间表示（IR），通过算子优化、内存规划生成硬件专属代码。</li><li><strong>记忆口诀</strong>：模型转IR，编译优算子，硬件跑更快。</li><li><strong>关键细节</strong>：<ul><li>优化步骤：算子融合→循环展开→内存对齐→指令调度；</li><li>适用场景：边缘设备部署（如ARM架构CPU），可提升30%-50%推理速度。</li></ul></li></ul><h3 id="13-稀疏推理-剪枝后加速">13. 稀疏推理（剪枝后加速）</h3><ul><li><strong>核心逻辑</strong>：利用硬件稀疏计算能力，跳过剪枝后的零值权重计算。</li><li><strong>记忆口诀</strong>：零值权重跳着算，稀疏硬件来加速，计算效率翻一番。</li><li><strong>关键细节</strong>：<ul><li>稀疏度要求：NVIDIA A100支持4:1稀疏（每4个元素1个非零），H100支持2:1稀疏；</li><li>性能瓶颈：稀疏度低于50%时加速效果不明显。</li></ul></li></ul><h3 id="14-多模态模型推理优化-权重共享">14. 多模态模型推理优化（权重共享）</h3><ul><li><strong>核心逻辑</strong>：跨模态（图文/音视频）共享基础编码器权重，减少重复计算。</li><li><strong>记忆口诀</strong>：模态共享基础层，参数省一半，推理更高效。</li><li><strong>关键细节</strong>：<ul><li>典型案例：CLIP的图文编码器共享Transformer主干，仅头部差异化；</li><li>优化点：共享层用INT8量化，差异化头部用FP16保留精度。</li></ul></li></ul><h3 id="15-推理缓存策略-多轮对话">15. 推理缓存策略（多轮对话）</h3><ul><li><strong>核心逻辑</strong>：缓存多轮对话中的历史KV张量，仅计算新轮次输入。</li><li><strong>记忆口诀</strong>：历史KV存起来，新话只算新增token，响应快一倍。</li><li><strong>关键细节</strong>：<ul><li>缓存管理：超过最大长度时按FIFO策略剔除最早轮次；</li><li>精度注意：缓存需与推理精度一致（如INT8推理缓存INT8 KV）。</li></ul></li></ul><h2 id="三-工具与框架：落地实战必备-7条">三、工具与框架：落地实战必备（7条）</h2><h3 id="1-训练框架：deepspeed">1. 训练框架：DeepSpeed</h3><ul><li><strong>核心功能</strong>：基于PyTorch的分布式训练优化框架，主打显存高效与速度提升。</li><li><strong>记忆口诀</strong>：ZeRO省显存，混合精度快，卸载能装大模型。</li><li><strong>关键细节</strong>：<ul><li>核心特性：ZeRO优化、FP8训练、梯度检查点自动集成；</li><li>适用场景：10B+参数模型训练，单卡24GB可训7B模型。</li></ul></li></ul><h3 id="2-训练框架：megatron-lm">2. 训练框架：Megatron-LM</h3><ul><li><strong>核心功能</strong>：NVIDIA推出的大模型训练框架，优化多卡并行效率。</li><li><strong>记忆口诀</strong>：3D并行强，张量拆分细，GPU利用率高。</li><li><strong>关键细节</strong>：<ul><li>特色功能：支持张量并行内的算子融合，多卡通信优化；</li><li>代表案例：Llama、GPT-3等模型训练基础框架。</li></ul></li></ul><h3 id="3-推理框架：tensorrt">3. 推理框架：TensorRT</h3><ul><li><strong>核心功能</strong>：NVIDIA专属推理优化引擎，主打量化、算子融合与编译优化。</li><li><strong>记忆口诀</strong>：量化融算子，编译生最优码，GPU跑最快。</li><li><strong>关键细节</strong>：<ul><li>优化流程：模型导入→量化校准→算子融合→引擎生成；</li><li>精度选项：支持FP32/FP16/INT8/FP8，INT8校准仅需50-100个样本。</li></ul></li></ul><h3 id="4-推理框架：vllm">4. 推理框架：vLLM</h3><ul><li><strong>核心功能</strong>：基于PagedAttention的高吞吐量推理框架，主打动态批处理。</li><li><strong>记忆口诀</strong>：分页存KV，动态合批快，吞吐超TGI。</li><li><strong>关键细节</strong>：<ul><li>核心创新：PagedAttention将KV缓存按页管理，支持非连续内存分配；</li><li>性能表现：同等配置下吞吐量是TGI的2-4倍。</li></ul></li></ul><h3 id="5-量化工具：gptq">5. 量化工具：GPTQ</h3><ul><li><strong>核心功能</strong>：针对Transformer的后训练量化工具，支持INT4/INT8量化。</li><li><strong>记忆口诀</strong>：量化GPT类模型，INT4精度高，速度提升明显。</li><li><strong>关键细节</strong>：<ul><li>技术原理：通过梯度下降优化量化误差，保留注意力层精度；</li><li>压缩比：7B模型INT4量化后仅占3GB显存，精度损失&lt;3%。</li></ul></li></ul><h3 id="6-剪枝工具：torchprune">6. 剪枝工具：TorchPrune</h3><ul><li><strong>核心功能</strong>：PyTorch生态剪枝工具，支持结构化与非结构化剪枝。</li><li><strong>记忆口诀</strong>：剪枝可视化，支持多策略，剪后易微调。</li><li><strong>关键细节</strong>：<ul><li>剪枝策略：支持L1/L2正则剪枝、运动剪枝（Movement Pruning）；</li><li>联动功能：剪枝后自动生成微调脚本，恢复精度效率高。</li></ul></li></ul><h3 id="7-peft工具：lora">7. PEFT工具：LoRA</h3><ul><li><strong>核心功能</strong>：参数高效微调工具，通过低秩矩阵适配大模型。</li><li><strong>记忆口诀</strong>：冻结主干网，训练小矩阵，微调省显存。</li><li><strong>关键细节</strong>：<ul><li>数学原理：将权重更新ΔW分解为U（m×r）和V（r×n），r通常取8-64；</li><li>显存优势：7B模型微调仅需5GB显存，比全量微调省90%。</li></ul></li></ul><h2 id="四-高频易混概念辨析-8条">四、高频易混概念辨析（8条）</h2><h3 id="1-fp8混合精度-vs-fp16混合精度">1. FP8混合精度 vs FP16混合精度</h3><ul><li><strong>核心差异</strong>：精度粒度与硬件依赖不同。<ul><li>FP16：动态范围足够（6.1e-5至6.5e4），无需复杂缩放策略，适配所有现代GPU；</li><li>FP8：动态范围有限（E4M3：2e-8至2e4），需Delayed Scaling，仅支持H100等新硬件。</li></ul></li></ul><h3 id="2-qat-vs-ptq">2. QAT vs PTQ</h3><table><thead><tr><th>维度</th><th>QAT（量化感知训练）</th><th>PTQ（后训练量化）</th></tr></thead><tbody><tr><td>时机</td><td>训练中嵌入量化模拟</td><td>训练完成后处理</td></tr><tr><td>精度</td><td>损失小（&lt;2%）</td><td>损失较大（3%-8%）</td></tr><tr><td>成本</td><td>需重新训练，耗时久</td><td>无需训练，几分钟完成</td></tr><tr><td>适用场景</td><td>高精度要求场景（如医疗）</td><td>快速部署场景（如客服）</td></tr></tbody></table><h3 id="3-模型并行-vs-张量并行">3. 模型并行 vs 张量并行</h3><ul><li><strong>模型并行</strong>：按层拆分模型（如Transformer的encoder层1-10在卡1，11-20在卡2），解决单卡装不下模型问题；</li><li><strong>张量并行</strong>：拆分单层内的张量（如QKV矩阵分块），解决单层计算量过大问题，通信更密集。</li></ul><h3 id="4-zero优化-vs-模型并行">4. ZeRO优化 vs 模型并行</h3><ul><li><strong>ZeRO优化</strong>：基于数据并行的分区策略，不改变模型结构，仅消除冗余显存；</li><li><strong>模型并行</strong>：改变模型部署结构，拆分层或张量，适用于单卡完全装不下模型的场景。</li></ul><h3 id="5-梯度裁剪-vs-梯度累积">5. 梯度裁剪 vs 梯度累积</h3><ul><li><strong>梯度裁剪</strong>：主动限制梯度规模，解决“梯度爆炸”，是稳定性保障手段；</li><li><strong>梯度累积</strong>：被动攒梯度模拟大batch，解决“显存不足”，是资源适配手段。</li></ul><h3 id="6-剪枝-vs-低秩分解">6. 剪枝 vs 低秩分解</h3><ul><li><strong>剪枝</strong>：删除无用参数（减少参数数量），可能破坏模型结构连续性；</li><li><strong>低秩分解</strong>：用小矩阵逼近大矩阵（减少参数维度），保留模型结构完整性。</li></ul><h3 id="7-kv缓存-vs-梯度检查点">7. KV缓存 vs 梯度检查点</h3><ul><li><strong>KV缓存</strong>：推理阶段使用，缓存中间计算结果避免重复计算，牺牲显存换速度；</li><li><strong>梯度检查点</strong>：训练阶段使用，删除中间激活值减少显存，牺牲速度换空间。</li></ul><h3 id="8-动态批处理-vs-静态批处理">8. 动态批处理 vs 静态批处理</h3><ul><li><strong>静态批处理</strong>：固定batch大小，请求需等待凑齐批次，长序列会拖慢整体；</li><li><strong>动态批处理</strong>：按时间/请求数动态调整批次，无需等待，吞吐量提升2-3倍。</li></ul><h2 id="五-进阶策略与前沿方向-5条">五、进阶策略与前沿方向（5条）</h2><h3 id="1-自蒸馏-self-distillation">1. 自蒸馏（Self-Distillation）</h3><ul><li><strong>核心逻辑</strong>：让模型自身的教师版本（如多轮微调后的模型）教学生版本（量化/剪枝后的模型）。</li><li><strong>记忆口诀</strong>：自己教自己，无需额外老师，压缩精度掉得少。</li><li><strong>关键细节</strong>：适用于无优质教师模型的场景，学生模型精度可接近原模型的95%。</li></ul><h3 id="2-持续学习-catastrophic-forgetting缓解">2. 持续学习（Catastrophic Forgetting缓解）</h3><ul><li><strong>核心逻辑</strong>：通过知识重放、参数正则化等方式，在微调新任务时保留原有能力。</li><li><strong>记忆口诀</strong>：新任务学知识，旧任务常回放，避免全忘记。</li><li><strong>关键细节</strong>：常用方法：弹性权重巩固（EWC）给旧任务关键参数加正则约束。</li></ul><h3 id="3-rlhf三阶段优化">3. RLHF三阶段优化</h3><ul><li><strong>核心逻辑</strong>：通过监督微调（SFT）、奖励模型（RM）训练、PPO优化，让模型对齐人类偏好。</li><li><strong>记忆口诀</strong>：先教后评再优化，三阶段对齐，回答更合规。</li><li><strong>关键细节</strong>：PPO阶段需平衡奖励值与原模型偏差，避免模型“过度迎合”导致事实性下降。</li></ul><h3 id="4-多模态联合优化">4. 多模态联合优化</h3><ul><li><strong>核心逻辑</strong>：跨模态（图文/音视频）共享优化策略，如统一量化、联合蒸馏。</li><li><strong>记忆口诀</strong>：模态共享优化策，参数计算双节省，跨域推理更高效。</li><li><strong>关键细节</strong>：CLIP通过联合蒸馏将图文模型体积压缩4倍，推理速度提升3倍。</li></ul><h3 id="5-边缘端优化-int2量化">5. 边缘端优化（INT2量化）</h3><ul><li><strong>核心逻辑</strong>：极致低精度量化（INT2），适配手机、IoT等边缘设备。</li><li><strong>记忆口诀</strong>：2位极致压缩，精度靠校准，边缘能运行。</li><li><strong>关键细节</strong>：需配合蒸馏使用，7B模型INT2量化后可压缩至1GB以内，适用于离线语音助手。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 大模型 </tag>
            
            <tag> 速记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写embedding</title>
      <link href="/2023/08/10/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/%E6%89%8B%E5%86%99embedding/"/>
      <url>/2023/08/10/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/%E6%89%8B%E5%86%99embedding/</url>
      
        <content type="html"><![CDATA[<h1>手写Transformer输入层：TokenEmbedding与PositionalEncoding笔记</h1><h2 id="一-概述：为什么需要这两个模块？">一、概述：为什么需要这两个模块？</h2><p>Transformer模型的核心痛点是<strong>无序性</strong>——自注意力机制无法区分Token的序列顺序，且无法直接处理离散的Token符号。因此需要两个基础模块解决这两个问题：</p><ul><li><strong>TokenEmbedding</strong>：将离散的Token（如整数ID）映射为连续的向量（可参与梯度学习）；</li><li><strong>PositionalEncoding</strong>：向词嵌入中注入“位置信息”，让模型感知Token的先后顺序。</li></ul><p>两者的最终输出维度需保持一致（均为 <code>[batch_size, seq_len, d_model]</code>），才能直接相加融合。</p><h2 id="二-tokenembedding：离散token-连续向量">二、TokenEmbedding：离散Token→连续向量</h2><h3 id="1-核心作用">1. 核心作用</h3><p>将词汇表中的离散Token（如“3”代表“苹果”）转化为固定维度（<code>d_model</code>）的连续向量，并通过<strong>缩放</strong>保证向量方差稳定（避免初始化时数值波动过大影响训练）。</p><h3 id="2-代码逐行解析">2. 代码逐行解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TokenEmbedding</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;词嵌入：将离散Token映射为连续向量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, d_model</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 继承nn.Module的初始化方法，必须调用</span></span><br><span class="line">        <span class="comment"># 1. 定义可学习的嵌入层：输入是Token的离散ID，输出是d_model维向量</span></span><br><span class="line">        <span class="comment"># nn.Embedding(词汇表大小, 输出向量维度)：本质是 vocab_size × d_model 的可学习矩阵</span></span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Embedding(vocab_size, d_model)  </span><br><span class="line">        <span class="comment"># 2. 保存d_model：后续forward中需要用它做缩放</span></span><br><span class="line">        <span class="variable language_">self</span>.d_model = d_model</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输入：x -&gt; [batch_size, seq_len]（批次内的Token序列，每个元素是Token的ID）</span></span><br><span class="line"><span class="string">        输出：-&gt; [batch_size, seq_len, d_model]（Token对应的连续向量）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 步骤1：通过嵌入层得到原始向量（未缩放）</span></span><br><span class="line">        raw_emb = <span class="variable language_">self</span>.embedding(x)  <span class="comment"># 形状：[batch_size, seq_len, d_model]</span></span><br><span class="line">        <span class="comment"># 步骤2：缩放向量（关键技巧！）</span></span><br><span class="line">        <span class="comment"># 原因：nn.Embedding初始化的向量方差随d_model增大而变大，乘以√d_model可将方差稳定在1附近</span></span><br><span class="line">        <span class="keyword">return</span> raw_emb * math.sqrt(<span class="variable language_">self</span>.d_model)</span><br></pre></td></tr></table></figure><h3 id="3-关键原理-易错点">3. 关键原理 &amp; 易错点</h3><table><thead><tr><th>关键细节</th><th>原理/目的</th><th>易错点提醒</th></tr></thead><tbody><tr><td><code>nn.Embedding(vocab_size, d_model)</code></td><td>覆盖所有可能的Token（vocab_size），输出维度与Transformer一致（d_model）</td><td>记反参数顺序！是“词汇表大小在前，输出维度在后”</td></tr><tr><td>乘以 <code>math.sqrt(d_model)</code></td><td>稳定嵌入向量的方差，避免训练初期数值过大/过小</td><td>容易漏写！忘记缩放会导致模型收敛变慢</td></tr><tr><td>输入输出维度</td><td>输入<code>[B, L]</code> → 输出<code>[B, L, D]</code>（B=batch_size, L=seq_len, D=d_model）</td><td>混淆维度顺序，需牢记“批次→序列→维度”</td></tr></tbody></table><h2 id="三-positionalencoding：注入序列位置信息">三、PositionalEncoding：注入序列位置信息</h2><h3 id="1-核心作用">1. 核心作用</h3><p>Transformer没有RNN的时序结构，无法天然感知Token顺序，因此通过<strong>固定的数学公式</strong>生成位置编码，与词嵌入相加，让模型知道“哪个Token在前，哪个在后”。<br>设计要求：<strong>相对位置可推导</strong>（如“第5个与第3个Token的相对位置”和“第10个与第8个”的编码规律一致）。</p><h3 id="2-代码逐行解析">2. 代码逐行解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位置编码：注入序列位置信息（非可学习参数）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, max_len=<span class="number">5000</span>, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 1. 定义dropout层：防止位置编码过拟合（可选但推荐）</span></span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(p=dropout)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 初始化位置编码矩阵pe：[max_len, d_model]</span></span><br><span class="line">        <span class="comment"># max_len：模型支持的最大序列长度（需覆盖所有可能的输入序列长度）</span></span><br><span class="line">        <span class="comment"># d_model：与词嵌入维度一致，保证可相加</span></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 生成“位置索引”：[max_len, 1]</span></span><br><span class="line">        <span class="comment"># 每个位置对应一个索引（0,1,2,...,max_len-1），unsqueeze(1)是为了后续广播乘法</span></span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 生成“衰减因子”：[d_model//2]</span></span><br><span class="line">        <span class="comment"># 原公式：10000^(2i/d_model) → 用exp+log转换避免数值溢出</span></span><br><span class="line">        <span class="comment"># i是维度索引（仅取偶数维度，因为后续分sin/cos）</span></span><br><span class="line">        div_term = torch.exp(</span><br><span class="line">            torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 填充pe矩阵：偶数维度用sin，奇数维度用cos（Transformer原论文设计）</span></span><br><span class="line">        <span class="comment"># 原因：sin/cos的周期性可体现相对位置，且奇偶维度分开增强区分度</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)  <span class="comment"># 0,2,4...维度（步长2取偶数）</span></span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)  <span class="comment"># 1,3,5...维度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 6. 增加batch维度：[1, max_len, d_model]</span></span><br><span class="line">        <span class="comment"># 适配输入x的batch_size（广播机制：1→B）</span></span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 7. 注册为非可学习参数：pe不参与梯度更新（固定的数学编码）</span></span><br><span class="line">        <span class="comment"># 若直接赋值self.pe，会被当作可学习参数，导致位置编码“学歪”</span></span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输入：x -&gt; [batch_size, seq_len, d_model]（词嵌入向量）</span></span><br><span class="line"><span class="string">        输出：-&gt; [batch_size, seq_len, d_model]（融合位置信息的向量）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 步骤1：词嵌入 + 位置编码（仅取与输入序列长度匹配的pe片段）</span></span><br><span class="line">        <span class="comment"># x.size(1)是当前输入的序列长度，避免pe的max_len大于seq_len导致维度不匹配</span></span><br><span class="line">        x = x + <span class="variable language_">self</span>.pe[:, :x.size(<span class="number">1</span>)]  <span class="comment"># 广播后：[B, L, D] + [1, L, D] → [B, L, D]</span></span><br><span class="line">        <span class="comment"># 步骤2：应用dropout（防止过拟合）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dropout(x)</span><br></pre></td></tr></table></figure><h3 id="3-关键原理-易错点">3. 关键原理 &amp; 易错点</h3><table><thead><tr><th>关键细节</th><th>原理/目的</th><th>易错点提醒</th></tr></thead><tbody><tr><td><code>pe = torch.zeros(max_len, d_model)</code></td><td>每行对应一个位置，每列对应一个维度</td><td>混淆维度！是“max_len行（位置），d_model列（维度）”</td></tr><tr><td><code>position.unsqueeze(1)</code></td><td>将<code>[max_len]</code>转为<code>[max_len, 1]</code>，与<code>div_term</code>（<code>[d_model//2]</code>）广播相乘</td><td>忘记扩维！会导致维度不匹配（无法广播）</td></tr><tr><td><code>sin/cos</code>分维度填充</td><td>利用周期性体现相对位置，增强编码区分度</td><td>搞混sin/cos对应的维度！记住“偶数sin，奇数cos”</td></tr><tr><td><code>self.register_buffer('pe', pe)</code></td><td>标记pe为非可学习参数，避免梯度更新</td><td>直接写<code>self.pe = pe</code>！会让pe变成可学习参数，破坏位置编码逻辑</td></tr><tr><td><code>self.pe[:, :x.size(1)]</code></td><td>只取与输入序列长度匹配的位置编码</td><td>漏写切片！若max_len&gt;seq_len，会导致维度不匹配报错</td></tr></tbody></table><h2 id="四-模块联动：从token到融合向量的完整流程">四、模块联动：从Token到融合向量的完整流程</h2><p>两个模块需按“Token→词嵌入→位置编码”的顺序串联，维度流转如下：</p><ol><li>输入Token序列：<code>x_input = [batch_size, seq_len]</code>（如<code>[2, 10]</code>）；</li><li>TokenEmbedding处理：<code>emb = token_emb(x_input)</code> → <code>[2, 10, 512]</code>；</li><li>PositionalEncoding处理：<code>x_with_pos = pos_enc(emb)</code> → <code>[2, 10, 512]</code>；</li><li>最终输出：作为Transformer编码器/解码器的输入。</li></ol><h2 id="五-测试代码解析-验证正确性">五、测试代码解析（验证正确性）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 1. 超参数设置（与Transformer输入层匹配）</span></span><br><span class="line">    vocab_size = <span class="number">1000</span>  <span class="comment"># 词汇表包含1000个不同Token</span></span><br><span class="line">    d_model = <span class="number">512</span>      <span class="comment"># 模型核心维度（所有模块输出维度需一致）</span></span><br><span class="line">    batch_size = <span class="number">2</span>     <span class="comment"># 每次训练的批次大小</span></span><br><span class="line">    seq_len = <span class="number">10</span>       <span class="comment"># 单条序列的Token长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 模拟输入：随机生成Token ID（范围0~vocab_size-1）</span></span><br><span class="line">    x = torch.randint(<span class="number">0</span>, vocab_size, (batch_size, seq_len))  <span class="comment"># 形状[2, 10]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 测试TokenEmbedding</span></span><br><span class="line">    token_emb = TokenEmbedding(vocab_size, d_model)</span><br><span class="line">    emb = token_emb(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;词嵌入输出形状：&quot;</span>, emb.shape)  <span class="comment"># 预期[2, 10, 512] → 验证维度是否正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 测试PositionalEncoding</span></span><br><span class="line">    pos_enc = PositionalEncoding(d_model)</span><br><span class="line">    x_with_pos = pos_enc(emb)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;融合位置信息后形状：&quot;</span>, x_with_pos.shape)  <span class="comment"># 预期[2, 10, 512] → 验证融合后维度是否一致</span></span><br></pre></td></tr></table></figure><p><strong>测试目的</strong>：确保每个模块的输出维度符合预期，避免后续Transformer层因维度不匹配报错。</p>]]></content>
      
      
      <categories>
          
          <category> 代码练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码练习 </tag>
            
            <tag> embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算子开发-add</title>
      <link href="/2023/08/01/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/add/"/>
      <url>/2023/08/01/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/add/</url>
      
        <content type="html"><![CDATA[<h1>算子开发-add</h1><p>在深度学习框架或数值计算引擎中，<strong>Add（加法）算子</strong>是最基础、最常用的计算单元之一。它看似简单，却需要兼顾输入兼容性（如张量广播）、数据类型安全、内存稳定性等核心问题。本文将详细拆解Add算子的实现逻辑，从需求分析到代码落地，剖析基础算子开发的关键设计思路。</p><h2 id="开发背景与核心需求">开发背景与核心需求</h2><p>Add算子的核心功能是实现两个张量（或标量）的逐元素加法，但在实际框架中，其需满足以下工程化需求：</p><ul><li><strong>输入合法性校验</strong>：避免空指针、输入数量不足（至少2个输入）、形状/数据类型信息缺失等问题导致崩溃；</li><li><strong>张量广播支持</strong>：兼容不同维度的输入（如<code>[2,3]</code>与<code>[3]</code>相加），按广播规则推导输出形状；</li><li><strong>数据类型安全</strong>：仅支持框架适配的数值类型（如<code>float32</code>/<code>float64</code>/<code>int32</code>/<code>int64</code>），拒绝非法类型；</li><li><strong>内存安全</strong>：避免内存泄漏、野指针访问，确保动态分配的资源（如<code>Var</code>、<code>Schedule</code>）正确释放；</li><li><strong>符号维度管理</strong>：支持动态维度（如<code>-1</code>表示未知维度），并通过约束保证输出维度的合法性。</li></ul><h2 id="核心设计思路">核心设计思路</h2><p>在具体实现前，需梳理Add算子的核心流程以确保逻辑闭环：</p><ol><li><strong>前置校验</strong>：先执行安全检查（空指针、输入数量），再进行合法性校验（形状/类型完整性）；</li><li><strong>形状处理</strong>：统一空形状（标量）为<code>[1]</code>，按广播规则计算输出形状；</li><li><strong>符号化构建</strong>：生成输入/输出的符号维度表达式，为框架后续优化（如编译优化、内存规划）提供元信息；</li><li><strong>计算逻辑实现</strong>：创建循环变量、构建输入索引、生成加法表达式，最终封装为可执行的算子节点；</li><li><strong>资源管理</strong>：确保动态分配的内存（如<code>Var</code>、<code>ConnectOperatorToGraphParams</code>）正确释放，避免泄漏。</li></ol><h2 id="代码核心逻辑解析">代码核心逻辑解析</h2><p>以下结合代码逐模块拆解实现细节，每一步均对应上述设计思路的落地。</p><h3 id="基础安全校验：规避运行时崩溃风险">基础安全校验：规避运行时崩溃风险</h3><p>任何算子的首要环节是<strong>安全防护</strong>，以避免非法输入导致的内存访问错误。代码开篇即执行两层关键校验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础安全检查：避免空指针访问</span></span><br><span class="line"><span class="keyword">if</span> (!func_params) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;func_params pointer is null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Node* node = func_params-&gt;node;</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Node pointer is null in func_params.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>空指针校验</strong>：<code>func_params</code>（算子参数容器）和<code>node</code>（算子节点）为核心入参，若为<code>null</code>则直接抛出异常，避免后续<code>-&gt;</code>访问导致崩溃；</li><li><strong>异常类型选择</strong>：使用<code>std::invalid_argument</code>而非通用异常，明确告知调用者“输入参数非法”，便于问题定位。</li></ul><h3 id="输入输出合法性校验：符合算子语义">输入输出合法性校验：符合算子语义</h3><p>Add算子的语义要求“至少2个输入、1个输出”，且必须包含形状和数据类型信息，这是确保算子正常计算的前提：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入输出数量校验：加法算子需至少2个输入和1个输出</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;_inputs_name.<span class="built_in">size</span>() &lt; <span class="number">2</span> || node-&gt;_outputs_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Add operator requires two inputs and one output.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形状和数据类型完整性校验：确保输入输出的形状与类型信息完整</span></span><br><span class="line"><span class="keyword">if</span> (func_params-&gt;input_shapes.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">    func_params-&gt;input_data_types.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">    func_params-&gt;output_data_types.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Add requires complete input/output shapes and data types.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数量校验</strong>：输入不足2个或无输出时，直接拒绝计算（例如仅传入1个输入无法执行加法）；</li><li><strong>信息完整性</strong>：若输入形状（<code>input_shapes</code>）或数据类型（<code>input_data_types</code>）缺失，后续无法推导输出形状和执行计算，因此必须校验。</li></ul><h3 id="形状预处理：统一维度处理逻辑">形状预处理：统一维度处理逻辑</h3><p>标量（无形状）和张量在维度处理上易出现不一致，因此需先进行<strong>形状统一</strong>，再推导广播后的输出形状。</p><h4 id="空形状转-1-：标量张量化">空形状转[1]：标量张量化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入形状调整：空形状统一转为[1]，保证维度处理一致性，计算输入张量秩</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_a = func_params-&gt;input_shapes[<span class="number">0</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_a = raw_shape_a.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_a;</span><br><span class="line"><span class="type">int</span> rank_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_b = func_params-&gt;input_shapes[<span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_b = raw_shape_b.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_b;</span><br><span class="line"><span class="type">int</span> rank_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_b.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><ul><li><strong>设计意图</strong>：标量（如<code>5</code>）可视为“1维、长度为1”的张量（<code>[5]</code>），使后续广播逻辑无需单独处理标量，简化代码；</li><li><strong>秩（rank）计算</strong>：张量的“秩”即维度数（如<code>[2,3]</code>的秩为2），后续广播需基于秩对比。</li></ul><h4 id="广播形状推导：兼容不同维度输入">广播形状推导：兼容不同维度输入</h4><p>广播是Add算子支持灵活输入的核心，代码严格遵循<strong>张量广播规则</strong>（低维张量向高维对齐，维度长度为1时可扩展）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导广播后输出形状：按张量广播规则计算最大兼容维度</span></span><br><span class="line"><span class="type">size_t</span> max_rank = std::<span class="built_in">max</span>(&#123;<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b), <span class="built_in">size_t</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">broadcasted_shape</span><span class="params">(max_rank, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">    <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前维度值，超出输入秩范围时按1处理</span></span><br><span class="line">    <span class="type">int</span> dim_a = (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? adjusted_shape_a[idx_a] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dim_b = (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? adjusted_shape_b[idx_b] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播规则判断：兼容维度或动态维度（-1）可广播，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (dim_a == dim_b || dim_a == <span class="number">1</span> || dim_b == <span class="number">1</span>) &#123;</span><br><span class="line">        broadcasted_shape[i] = std::<span class="built_in">max</span>(dim_a, dim_b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dim_a == <span class="number">-1</span> || dim_b == <span class="number">-1</span>) &#123;</span><br><span class="line">        broadcasted_shape[i] = (dim_a != <span class="number">-1</span>) ? dim_a : dim_b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Cannot broadcast A dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_a) + <span class="string">&quot; and B dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_b) + <span class="string">&quot; at position &quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; in node &quot;</span> + node_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>广播逻辑拆解</strong>：<ol><li>确定最大秩（<code>max_rank</code>）：例如输入A（秩2：<code>[2,3]</code>）和输入B（秩1：<code>[3]</code>），最大秩为2；</li><li>维度对齐：从最低维（右数第一位）开始对比，低维张量的“缺失维度”视为1（如B的第0维对应A的第1维，B的第1维视为1）；</li><li>维度兼容性判断：<ul><li>若两个维度相等（如<code>3</code>和<code>3</code>）或有一个为1（如<code>2</code>和<code>1</code>），则可广播为较大值（如<code>3</code>、<code>2</code>）；</li><li>若存在动态维度（<code>-1</code>，表示运行时确定），则优先取已知维度值；</li><li>若均不满足（如<code>2</code>和<code>3</code>），则抛出异常，避免非法计算。</li></ul></li></ol></li></ul><h3 id="符号维度构建：为框架优化提供元信息">符号维度构建：为框架优化提供元信息</h3><p>在编译型框架中，算子需提供<strong>符号化的维度信息</strong>（而非仅数值），用于后续的内存规划、循环展开等优化。代码中通过<code>Var</code>（符号变量）和<code>ScalarExpr</code>（符号表达式）实现这一功能。</p><h4 id="输入符号维度生成">输入符号维度生成</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义符号维度：生成输入维度符号表达式，收集待约束变量</span></span><br><span class="line">std::vector&lt;ScalarExpr&gt; exprs_a, exprs_b, output_dims;</span><br><span class="line">std::vector&lt;Var*&gt; vars_to_constrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成输入A的符号维度表达式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">    exprs_a.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_a_name, is_const_a, adjusted_shape_a[i], i, vars_to_constrain));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成输入B的符号维度表达式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">    exprs_b.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_b_name, is_const_b, adjusted_shape_b[i], i, vars_to_constrain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>make_dim</code>功能</strong>：为每个输入维度创建符号表达式（如<code>A_dim0</code>、<code>B_dim1</code>），并收集需要后续约束的变量（<code>vars_to_constrain</code>）；</li><li><strong>常量标记（<code>is_const_a</code>）</strong>：若输入是常量张量（如<code>[5,6]</code>），其维度为固定值，符号表达式直接绑定常量，避免冗余计算。</li></ul><h4 id="输出符号维度生成">输出符号维度生成</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成输出维度符号变量：为广播后形状创建对应的符号变量并加入约束列表</span></span><br><span class="line">std::vector&lt;Var*&gt; output_dim_vars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; broadcasted_shape.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::string var_name = output_name + <span class="string">&quot;_dim&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">    Var* var = <span class="built_in">new</span> (std::nothrow) <span class="built_in">Var</span>(var_name, <span class="string">&quot;int32&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!var) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    output_dim_vars.<span class="built_in">push_back</span>(var);</span><br><span class="line">    output_dims.<span class="built_in">push_back</span>(<span class="built_in">ScalarExpr</span>(var));</span><br><span class="line">    vars_to_constrain.<span class="built_in">push_back</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>动态内存安全</strong>：使用<code>new (std::nothrow)</code>分配<code>Var</code>，若内存不足则抛出<code>std::bad_alloc</code>，避免野指针；</li><li><strong>输出维度约束</strong>：输出维度的符号变量（如<code>C_dim0</code>）后续会绑定到“输入维度的最大值”（见维度约束部分），确保与广播逻辑一致。</li></ul><h3 id="计算逻辑实现：从占位符到加法表达式">计算逻辑实现：从占位符到加法表达式</h3><p>此部分为算子的“核心计算体”，需完成输入占位符创建、循环变量生成、索引构建、加法表达式封装。</p><h4 id="输入张量占位符">输入张量占位符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输入张量占位符</span></span><br><span class="line">Expr A = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_placeholder</span>(input_a_name, dtype_a, <span class="built_in">Shape</span>(exprs_a)));</span><br><span class="line">Expr B = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_placeholder</span>(input_b_name, dtype_b, <span class="built_in">Shape</span>(exprs_b)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验输入张量创建结果</span></span><br><span class="line"><span class="keyword">if</span> (!A.<span class="built_in">get_tensor</span>() || !B.<span class="built_in">get_tensor</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create input placeholders.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>占位符作用</strong>：<code>create_tensor_by_placeholder</code>创建输入张量的“符号占位符”，不实际存储数据，仅用于描述张量的名称、类型、维度信息；</li><li><strong>结果校验</strong>：确保占位符创建成功，避免后续基于空张量计算。</li></ul><h4 id="循环变量：实现逐元素遍历">循环变量：实现逐元素遍历</h4><p>Add算子为逐元素计算，需按输出维度生成<strong>数据并行循环变量</strong>（<code>LoopVar</code>），用于遍历输出张量的每个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输出循环变量：按广播后维度生成数据并行循环变量</span></span><br><span class="line"><span class="type">size_t</span> loop_rank = broadcasted_shape.<span class="built_in">size</span>();</span><br><span class="line">std::vector&lt;Expr&gt; loop_vars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop_rank; ++i) &#123;</span><br><span class="line">    std::string var_name = <span class="string">&quot;o&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">    LoopVar* lv = <span class="built_in">create_loopvar</span>(var_name, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), output_dims[i]), <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line">    <span class="keyword">if</span> (!lv) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create loop var &quot;</span> + var_name);</span><br><span class="line">    &#125;</span><br><span class="line">    loop_vars.<span class="built_in">push_back</span>(<span class="built_in">Expr</span>(lv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标量索引专用循环变量：用于常量1维张量的索引访问（范围0~1）</span></span><br><span class="line">LoopVar* zero_lv = <span class="built_in">create_loopvar</span>(<span class="string">&quot;zero_idx&quot;</span>, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), <span class="built_in">ScalarExpr</span>(<span class="number">1</span>)), <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line"><span class="keyword">if</span> (!zero_lv) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create zero loop variable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Expr zero_loop = <span class="built_in">Expr</span>(zero_lv);</span><br></pre></td></tr></table></figure><ul><li><strong>循环变量类型</strong>：<code>LoopVarType::DataPar</code>表示该循环可并行执行（如GPU的线程并行），为后续性能优化预留空间；</li><li><strong>专用零循环（<code>zero_loop</code>）</strong>：常量1维张量（如<code>[5]</code>）的索引固定为0，用<code>zero_loop</code>（范围<code>0~1</code>）访问，避免索引越界。</li></ul><h4 id="输入索引构建：匹配广播逻辑">输入索引构建：匹配广播逻辑</h4><p>广播后，输入张量的维度可能与输出不一致，需构建<strong>动态索引</strong>，确保每个输出元素能正确找到对应的输入元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建输入A索引表达式：根据广播规则和常量标记生成索引</span></span><br><span class="line">std::vector&lt;Expr&gt; index_a;</span><br><span class="line"><span class="type">int</span> rank_diff_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_const_a &amp;&amp; adjusted_shape_a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        index_a.<span class="built_in">push_back</span>(zero_loop);  <span class="comment">// 常量1维用专用索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> output_dim_idx = i + rank_diff_a;</span><br><span class="line">        <span class="comment">// 索引在循环变量范围内则使用循环变量，否则用专用索引</span></span><br><span class="line">        <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp; output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建输入B索引表达式：逻辑同输入A</span></span><br><span class="line">std::vector&lt;Expr&gt; index_b;</span><br><span class="line"><span class="comment">// ...（逻辑与index_a一致，略）</span></span><br></pre></td></tr></table></figure><ul><li><strong>索引逻辑示例</strong>：<ul><li>输入A（<code>[2,3]</code>，秩2），输入B（<code>[3]</code>，秩1），输出秩2；</li><li>对B的索引：<code>rank_diff_b = 2-1=1</code>，B的第0维对应输出的第1维，因此<code>index_b = [loop_vars[1]]</code>；</li><li>若B是常量1维（如<code>[5]</code>），则<code>index_b = [zero_loop]</code>，始终取第0个元素。</li></ul></li></ul><h4 id="加法表达式与输出张量">加法表达式与输出张量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建加法计算表达式</span></span><br><span class="line">Expr expr_a = A[index_a];</span><br><span class="line">Expr expr_b = B[index_b];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验加法支持的数据类型：仅支持float32/float64/int32/int64</span></span><br><span class="line"><span class="keyword">if</span> ((dtype_a != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int64&quot;</span>) ||</span><br><span class="line">    (dtype_b != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int64&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unsupported dtype for add: A=&quot;</span> + dtype_a + <span class="string">&quot;, B=&quot;</span> + dtype_b);</span><br><span class="line">&#125;</span><br><span class="line">Expr compute_body = expr_a + expr_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建输出计算张量：基于循环变量和计算表达式生成输出张量</span></span><br><span class="line">Expr C = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_compute</span>(output_name, output_dtype, <span class="built_in">Shape</span>(output_dims), Expr::<span class="built_in">assign</span>(loop_vars, compute_body)));</span><br><span class="line"><span class="keyword">if</span> (!C.<span class="built_in">get_tensor</span>() || !C.<span class="built_in">get_tensor</span>()-&gt;op) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create output compute tensor.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数据类型校验</strong>：仅支持四种常用数值类型，避免不支持的类型（如<code>bool</code>、<code>uint8</code>）导致计算错误；</li><li><strong><code>create_tensor_by_compute</code></strong>：将“循环变量遍历”和“加法表达式”封装为输出张量的计算逻辑，即“对每个循环变量对应的位置，执行<code>expr_a + expr_b</code>并赋值给输出”。</li></ul><h3 id="算子封装与图连接：融入框架计算流">算子封装与图连接：融入框架计算流</h3><p>算子逻辑实现后，需封装为框架可识别的<code>OperatorFunc</code>和<code>OperatorGraphFuncNode</code>，并连接到全局计算图（TIR）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建调度器与算子实例：封装计算逻辑与调度信息</span></span><br><span class="line">Schedule* schedule = <span class="built_in">create_schedule</span>(C.<span class="built_in">get_tensor</span>()-&gt;op);</span><br><span class="line"><span class="keyword">if</span> (!schedule) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create schedule.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存安全分配：避免内存分配失败导致的资源泄漏</span></span><br><span class="line">OperatorFunc* add_func = <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorFunc</span>(node_name, schedule);</span><br><span class="line">OperatorGraphFuncNode* add_node = <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorGraphFuncNode</span>(node_name, <span class="string">&quot;params_none&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!add_func || !add_node) &#123;</span><br><span class="line">    <span class="keyword">delete</span> add_func;</span><br><span class="line">    <span class="keyword">delete</span> add_node;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将算子添加到TIR计算图</span></span><br><span class="line">tir.<span class="built_in">add_operator</span>(add_node, add_func);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配图连接参数：封装算子连接所需的元信息</span></span><br><span class="line">ConnectOperatorToGraphParams* connect_params = <span class="built_in">new</span> (std::nothrow) <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line"><span class="keyword">if</span> (!connect_params) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line">connect_params-&gt;node_name = node_name;</span><br><span class="line">connect_params-&gt;output_datatype = output_dtype;</span><br><span class="line">connect_params-&gt;output_name = output_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立算子与计算图的连接</span></span><br><span class="line"><span class="built_in">connect_operator_to_graph</span>(tir, connect_params, add_node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放临时资源：避免内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span> connect_params;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Schedule</code>作用</strong>：调度器用于定义算子的执行策略（如循环顺序、并行方式），是框架性能优化的关键入口；</li><li><strong>资源泄漏防护</strong>：<ul><li>分配<code>add_func</code>和<code>add_node</code>后，若任一为<code>null</code>，立即释放已分配资源，再抛出异常；</li><li>临时变量<code>connect_params</code>使用后手动<code>delete</code>，避免内存泄漏。</li></ul></li></ul><h3 id="维度约束：确保符号变量合法性">维度约束：确保符号变量合法性</h3><p>最后，需为符号变量（输入和输出维度）添加<strong>取值约束</strong>，确保运行时维度在合法范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束输出维度变量：将输出维度绑定为输入维度的最大值，并设置有效范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_dim_vars.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    Var* var = output_dim_vars[i];</span><br><span class="line">    <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">    <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">    ScalarExpr dim_a_expr = (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? exprs_a[idx_a] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line">    ScalarExpr dim_b_expr = (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? exprs_b[idx_b] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    add_func-&gt;parameter_assign_expr[var] = ScalarExpr::<span class="built_in">simple_max</span>(dim_a_expr, dim_b_expr);</span><br><span class="line">    add_func-&gt;unknown_var_bound[var] = <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">    add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束输入符号变量：设置输入相关符号变量的有效范围（排除输出维度变量）</span></span><br><span class="line"><span class="keyword">for</span> (Var* var : vars_to_constrain) &#123;</span><br><span class="line">    <span class="comment">// ...（略：跳过输出维度变量，为输入变量设置1~MAX_VALID_RANGE的约束）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>输出维度约束</strong>：将输出维度的符号变量绑定为“输入维度的最大值”（与广播逻辑一致），同时限制取值范围为<code>1~MAX_VALID_RANGE</code>（避免0或负数维度）；</li><li><strong>输入维度约束</strong>：确保输入维度为合法正数，避免无效形状（如<code>[0,3]</code>）。</li></ul><h2 id="算子开发的关键亮点">算子开发的关键亮点</h2><p>回顾整个实现，该Add算子有三个核心亮点，亦是基础算子开发的通用经验：</p><ol><li><strong>全链路安全校验</strong>：从空指针、输入数量、形状完整性，到数据类型、索引数量，每一步均有校验，最大程度降低运行时崩溃风险；</li><li><strong>灵活的广播支持</strong>：严格遵循张量广播规则，兼容标量、不同秩张量，同时支持动态维度（<code>-1</code>），适配复杂场景；</li><li><strong>内存安全设计</strong>：所有动态分配的资源（<code>Var</code>、<code>OperatorFunc</code>、<code>connect_params</code>）均有释放逻辑，杜绝内存泄漏。</li></ol><h2 id="总结与后续优化">总结与后续优化</h2><p>Add算子作为基础计算单元，其开发重点不在于“加法逻辑本身”，而在于<strong>工程化兼容性和稳定性</strong>。本文通过“安全校验→形状处理→符号构建→计算实现→图连接”的流程，完成了一个健壮的Add算子开发。</p><p>后续可从两个方向优化：</p><ul><li><strong>扩展数据类型</strong>：支持<code>uint8</code>、<code>float16</code>等更多类型，适配端侧推理场景；</li><li><strong>性能优化</strong>：通过<code>Schedule</code>添加向量化（如SIMD）、循环展开等优化，提升大规模张量加法的计算效率。</li></ul><p>基础算子是框架的“基石”，唯有打磨好每个细节，才能支撑上层复杂模型的稳定运行。希望本文的拆解能为算子开发提供参考。</p><h2 id="完整代码">完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include.hpp&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALID_RANGE = MAX_INF;</span><br><span class="line"><span class="function">OperatorGraphFuncNode* <span class="title">create_add_operator</span><span class="params">(TIR&amp; tir, FuncParams* func_params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础安全检查：避免空指针访问</span></span><br><span class="line">    <span class="keyword">if</span> (!func_params) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;func_params pointer is null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node = func_params-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Node pointer is null in func_params.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入输出数量校验：加法算子需至少2个输入和1个输出</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_inputs_name.<span class="built_in">size</span>() &lt; <span class="number">2</span> || node-&gt;_outputs_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">            <span class="string">&quot;Add operator requires two inputs and one output.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形状和数据类型完整性校验：确保输入输出的形状与类型信息完整</span></span><br><span class="line">    <span class="keyword">if</span> (func_params-&gt;input_shapes.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">        func_params-&gt;input_data_types.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">        func_params-&gt;output_data_types.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">            <span class="string">&quot;Add requires complete input/output shapes and data types.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义核心变量：节点名、输入输出张量名</span></span><br><span class="line">    std::string node_name = node-&gt;_simple_name;</span><br><span class="line">    std::string input_a_name = node-&gt;_inputs_name[<span class="number">0</span>];</span><br><span class="line">    std::string input_b_name = node-&gt;_inputs_name[<span class="number">1</span>];</span><br><span class="line">    std::string output_name = node-&gt;_outputs_name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入输出数据类型</span></span><br><span class="line">    std::string dtype_a = func_params-&gt;input_data_types[<span class="number">0</span>];</span><br><span class="line">    std::string dtype_b = func_params-&gt;input_data_types[<span class="number">1</span>];</span><br><span class="line">    std::string output_dtype = func_params-&gt;output_data_types[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记输入张量是否为常量</span></span><br><span class="line">    <span class="type">bool</span> is_const_a = <span class="built_in">is_constant_tensor</span>(input_a_name);</span><br><span class="line">    <span class="type">bool</span> is_const_b = <span class="built_in">is_constant_tensor</span>(input_b_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入形状调整：空形状统一转为[1]，保证维度处理一致性，计算输入张量秩</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_a = func_params-&gt;input_shapes[<span class="number">0</span>];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_a =</span><br><span class="line">        raw_shape_a.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_a;</span><br><span class="line">    <span class="type">int</span> rank_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_b = func_params-&gt;input_shapes[<span class="number">1</span>];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_b =</span><br><span class="line">        raw_shape_b.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_b;</span><br><span class="line">    <span class="type">int</span> rank_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_b.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推导广播后输出形状：按张量广播规则计算最大兼容维度</span></span><br><span class="line">    <span class="type">size_t</span> max_rank = std::<span class="built_in">max</span>(</span><br><span class="line">        &#123;<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b), <span class="built_in">size_t</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">broadcasted_shape</span><span class="params">(max_rank, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">        <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前维度值，超出输入秩范围时按1处理</span></span><br><span class="line">        <span class="type">int</span> dim_a =</span><br><span class="line">            (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? adjusted_shape_a[idx_a] : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dim_b =</span><br><span class="line">            (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? adjusted_shape_b[idx_b] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播规则判断：兼容维度或动态维度（-1）可广播，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (dim_a == dim_b || dim_a == <span class="number">1</span> || dim_b == <span class="number">1</span>) &#123;</span><br><span class="line">            broadcasted_shape[i] = std::<span class="built_in">max</span>(dim_a, dim_b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dim_a == <span class="number">-1</span> || dim_b == <span class="number">-1</span>) &#123;</span><br><span class="line">            broadcasted_shape[i] = (dim_a != <span class="number">-1</span>) ? dim_a : dim_b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">                <span class="string">&quot;Cannot broadcast A dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_a) +</span><br><span class="line">                <span class="string">&quot; and B dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_b) + <span class="string">&quot; at position &quot;</span> +</span><br><span class="line">                std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; in node &quot;</span> + node_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符号维度：生成输入维度符号表达式，收集待约束变量</span></span><br><span class="line">    std::vector&lt;ScalarExpr&gt; exprs_a, exprs_b, output_dims;</span><br><span class="line">    std::vector&lt;Var*&gt; vars_to_constrain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输入A的符号维度表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">        exprs_a.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_a_name, is_const_a,</span><br><span class="line">                                   adjusted_shape_a[i], i, vars_to_constrain));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输入B的符号维度表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">        exprs_b.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_b_name, is_const_b,</span><br><span class="line">                                   adjusted_shape_b[i], i, vars_to_constrain));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输出维度符号变量：为广播后形状创建对应的符号变量并加入约束列表</span></span><br><span class="line">    std::vector&lt;Var*&gt; output_dim_vars;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; broadcasted_shape.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::string var_name = output_name + <span class="string">&quot;_dim&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        Var* var = <span class="built_in">new</span> (std::nothrow) <span class="built_in">Var</span>(var_name, <span class="string">&quot;int32&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!var) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        output_dim_vars.<span class="built_in">push_back</span>(var);</span><br><span class="line">        output_dims.<span class="built_in">push_back</span>(<span class="built_in">ScalarExpr</span>(var));</span><br><span class="line">        vars_to_constrain.<span class="built_in">push_back</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输入张量占位符</span></span><br><span class="line">    Expr A = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_placeholder</span>(input_a_name, dtype_a, <span class="built_in">Shape</span>(exprs_a)));</span><br><span class="line">    Expr B = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_placeholder</span>(input_b_name, dtype_b, <span class="built_in">Shape</span>(exprs_b)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验输入张量创建结果</span></span><br><span class="line">    <span class="keyword">if</span> (!A.<span class="built_in">get_tensor</span>() || !B.<span class="built_in">get_tensor</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create input placeholders.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出循环变量：按广播后维度生成数据并行循环变量</span></span><br><span class="line">    <span class="type">size_t</span> loop_rank = broadcasted_shape.<span class="built_in">size</span>();</span><br><span class="line">    std::vector&lt;Expr&gt; loop_vars;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop_rank; ++i) &#123;</span><br><span class="line">        std::string var_name = <span class="string">&quot;o&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        LoopVar* lv = <span class="built_in">create_loopvar</span>(var_name, <span class="string">&quot;int32&quot;</span>,</span><br><span class="line">                                     <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), output_dims[i]), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                     LoopVarType::DataPar);</span><br><span class="line">        <span class="keyword">if</span> (!lv) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create loop var &quot;</span> + var_name);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_vars.<span class="built_in">push_back</span>(<span class="built_in">Expr</span>(lv));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标量索引专用循环变量：用于常量1维张量的索引访问（范围0~1）</span></span><br><span class="line">    LoopVar* zero_lv =</span><br><span class="line">        <span class="built_in">create_loopvar</span>(<span class="string">&quot;zero_idx&quot;</span>, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), <span class="built_in">ScalarExpr</span>(<span class="number">1</span>)),</span><br><span class="line">                       <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line">    <span class="keyword">if</span> (!zero_lv) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create zero loop variable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Expr zero_loop = <span class="built_in">Expr</span>(zero_lv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输入A索引表达式：根据广播规则和常量标记生成索引</span></span><br><span class="line">    std::vector&lt;Expr&gt; index_a;</span><br><span class="line">    <span class="type">int</span> rank_diff_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_const_a &amp;&amp; adjusted_shape_a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(zero_loop);  <span class="comment">// 常量1维用专用索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> output_dim_idx = i + rank_diff_a;</span><br><span class="line">            <span class="comment">// 索引在循环变量范围内则使用循环变量，否则用专用索引</span></span><br><span class="line">            <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">                index_a.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index_a.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输入B索引表达式：逻辑同输入A</span></span><br><span class="line">    std::vector&lt;Expr&gt; index_b;</span><br><span class="line">    <span class="type">int</span> rank_diff_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_const_b &amp;&amp; adjusted_shape_b[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            index_b.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> output_dim_idx = i + rank_diff_b;</span><br><span class="line">            <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">                index_b.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index_b.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引数量校验：确保索引数量与输入张量维度匹配</span></span><br><span class="line">    <span class="keyword">if</span> (index_a.<span class="built_in">size</span>() != <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;A index count mismatch: expected &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(rank_a) + <span class="string">&quot;, got &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(index_a.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index_b.<span class="built_in">size</span>() != <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;B index count mismatch: expected &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(rank_b) + <span class="string">&quot;, got &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(index_b.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建加法计算表达式</span></span><br><span class="line">    Expr expr_a = A[index_a];</span><br><span class="line">    Expr expr_b = B[index_b];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验加法支持的数据类型：仅支持float32/float64/int32/int64</span></span><br><span class="line">    <span class="keyword">if</span> ((dtype_a != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int32&quot;</span> &amp;&amp;</span><br><span class="line">         dtype_a != <span class="string">&quot;int64&quot;</span>) ||</span><br><span class="line">        (dtype_b != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int32&quot;</span> &amp;&amp;</span><br><span class="line">         dtype_b != <span class="string">&quot;int64&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unsupported dtype for add: A=&quot;</span> + dtype_a +</span><br><span class="line">                                    <span class="string">&quot;, B=&quot;</span> + dtype_b);</span><br><span class="line">    &#125;</span><br><span class="line">    Expr compute_body = expr_a + expr_b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出计算张量：基于循环变量和计算表达式生成输出张量</span></span><br><span class="line">    Expr C = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_compute</span>(output_name, output_dtype, <span class="built_in">Shape</span>(output_dims),</span><br><span class="line">                                 Expr::<span class="built_in">assign</span>(loop_vars, compute_body)));</span><br><span class="line">    <span class="keyword">if</span> (!C.<span class="built_in">get_tensor</span>() || !C.<span class="built_in">get_tensor</span>()-&gt;op) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create output compute tensor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调度器与算子实例：封装计算逻辑与调度信息</span></span><br><span class="line">    Schedule* schedule = <span class="built_in">create_schedule</span>(C.<span class="built_in">get_tensor</span>()-&gt;op);</span><br><span class="line">    <span class="keyword">if</span> (!schedule) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create schedule.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存安全分配：避免内存分配失败导致的资源泄漏</span></span><br><span class="line">    OperatorFunc* add_func =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorFunc</span>(node_name, schedule);</span><br><span class="line">    OperatorGraphFuncNode* add_node =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorGraphFuncNode</span>(node_name, <span class="string">&quot;params_none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!add_func || !add_node) &#123;</span><br><span class="line">        <span class="keyword">delete</span> add_func;</span><br><span class="line">        <span class="keyword">delete</span> add_node;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束输出维度变量：将输出维度绑定为输入维度的最大值，并设置有效范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_dim_vars.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Var* var = output_dim_vars[i];</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">        <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">        ScalarExpr dim_a_expr =</span><br><span class="line">            (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? exprs_a[idx_a] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line">        ScalarExpr dim_b_expr =</span><br><span class="line">            (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? exprs_b[idx_b] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        add_func-&gt;parameter_assign_expr[var] =</span><br><span class="line">            ScalarExpr::<span class="built_in">simple_max</span>(dim_a_expr, dim_b_expr);</span><br><span class="line">        add_func-&gt;unknown_var_bound[var] =</span><br><span class="line">            <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">        add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束输入符号变量：设置输入相关符号变量的有效范围（排除输出维度变量）</span></span><br><span class="line">    <span class="keyword">for</span> (Var* var : vars_to_constrain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过已处理的输出维度变量</span></span><br><span class="line">        <span class="type">bool</span> is_output_dim = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Var* output_var : output_dim_vars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var == output_var) &#123;</span><br><span class="line">                is_output_dim = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_output_dim) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 约束输入相关的符号变量</span></span><br><span class="line">        <span class="keyword">if</span> (var-&gt;name.<span class="built_in">find</span>(input_a_name) != std::string::npos ||</span><br><span class="line">            var-&gt;name.<span class="built_in">find</span>(input_b_name) != std::string::npos) &#123;</span><br><span class="line">            add_func-&gt;unknown_var_bound[var] =</span><br><span class="line">                <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">            add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将算子添加到TIR计算图</span></span><br><span class="line">    tir.<span class="built_in">add_operator</span>(add_node, add_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配图连接参数：封装算子连接所需的元信息</span></span><br><span class="line">    ConnectOperatorToGraphParams* connect_params =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line">    <span class="keyword">if</span> (!connect_params) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    connect_params-&gt;node_name = node_name;</span><br><span class="line">    connect_params-&gt;output_datatype = output_dtype;</span><br><span class="line">    connect_params-&gt;output_name = output_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立算子与计算图的连接</span></span><br><span class="line">    <span class="built_in">connect_operator_to_graph</span>(tir, connect_params, add_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时资源：避免内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span> connect_params;</span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Add Schedule:\n&quot; &lt;&lt; schedule-&gt;to_str() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Add Kernel:\n&quot; &lt;&lt; add_func-&gt;to_c_kernel_program() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> add_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算子开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算子开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>474.一和零</title>
      <link href="/2023/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/474%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
      <url>/2023/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/474%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1>474.一和零</h1><h2 id="题目描述">题目描述</h2><p>给你一个二进制字符串strs和两个整数m和n.</p><p>请你找出并返回strs的最大子集的长度，该子集中最多含有m个0和n个1.</p><p>如果x的所有元素也都是y的元素，那么x就是y的子集</p><h2 id="问题分析">问题分析</h2><p>这是一个典型的二维01背包问题<br>(1)字符串数组中的每一个字符串就是一个物品<br>(2)物品有两个重量，分别是字符串中的0的个数和1的个数<br>(3)背包有两个限制，分别是0的个数不超过m，1的个数不超过n<br>(4)每个物品的价值都是1.</p><h2 id="解题核心与思路">解题核心与思路</h2><p>将题目转化为动态规划<br>(1)dp[i][j]表示最多有i个0和j个1的strs的最大子集的长度。<br>(2)初始化dp数组为0<br>(3)遍历strs数组中的每一个字符串，对于每一个字符串计算他的0和1的个数。<br>(4)从后向前遍历，更新dp[i][j] = max(dp[i][j],dp[i-zero][j-one]+1)。</p><h2 id="解题代码">解题代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:strs)&#123;</span><br><span class="line">            <span class="type">int</span> countM = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> countN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    countM++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    countN++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=countM;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=countN;j--)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],(dp[i-countM][j-countN]<span class="number">+1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(lmn+ls)<br>其中l是字符串数组的长度，m和n分别是0和1的个数，s是字符串的平均长度。<br>（2）空间复杂度：O(mn)</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 01二维背包 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
