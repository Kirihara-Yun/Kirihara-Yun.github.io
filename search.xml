<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>318. 最大单词长度乘积</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a>318. 最大单词长度乘积</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>解题的关键首先是判断两个单词是否有公共字母，然后计算它们的长度乘积。</p><p>如果采用穷举的方式判断是否含有公共字母，那么时间复杂度会是O(n^2 * m)，其中n是单词的数量，m是单词的平均长度。</p><p>所以可以采用编码的方式。</p><p>每个单词可以用一个26位的二进制数表示，第i位为1表示单词中包含第i个字母，为0表示不包含。</p><p>例如，单词”abc”可以表示为00000000000000000000000111。</p><p>然后判断两个单词是否有公共字母，只需要判断它们的二进制数是否有交集即可。</p><p>如果两个单词的二进制数相与的结果为0，那么这两个单词就没有公共字母。</p><p>所以可以先遍历一遍数组，将每个单词编码为一个26位的二进制数，然后再遍历一遍数组，判断每个单词是否与其他单词有公共字母。</p><p>如果有公共字母，就计算它们的长度乘积，取最大值即可。</p><p>如果没有公共字母，就返回0。</p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>（1）数据变量有masks和lengths，分别存储每个单词的二进制编码和长度。<br>（2）遍历数组，将每个单词编码为一个26位的二进制数，存储在masks数组中，同时记录每个单词的长度，存储在lengths数组中。<br>（3）遍历数组中每个单词的二元组合，判断是否含有公共字母，若没有则计算乘积并保留最大值。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masks</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lengths</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:words[i])&#123;</span><br><span class="line">                masks[i] |= (<span class="number">1</span>&lt;&lt;(c-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            lengths[i] = words[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((masks[i]&amp;masks[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,lengths[i]*lengths[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h2><p>时间复杂度：O(n^2 +L)，其中n是单词的数量，L是单词的总长度。<br>空间复杂度：O(n)，其中n是单词的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. 打乱数组</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a>384. 打乱数组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组nums,设计算法来打乱一个没有重复元素的数组。</p><p>打乱后，数组的所有排列应该是等可能的。</p><p>实现Solution类:</p><p>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>问题类型：这是一道设计随机算法的设计题，核心在于实现一个能够公平打乱元素的随机算法，确保所有排列具有等可能的概率。</p><p>核心问题：设计一个类，支持初始化数组，重置数组至初始状态，以及随机打乱数组。</p><p>关键约束：<br>（1）打乱后的数组需保证所有元素的排列能够等可能的出现<br>（2）reset()函数能够将数组重置到初始化的状态<br>（3）数组没有重复性的元素</p><p>解题思路：<br>（1）创建一个私有变量，在类初始化时将nums数组复制给他，作为整个数组的副本<br>（2）reset函数在调用时返回上述私有变量<br>（3）shuffle函数在调用时，首先提取副本，然后从后往前遍历数组，应用Fisher-Yates洗牌算法，随机交换当前元素与之前的一个元素，确保每个元素在每个位置的概率相等。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; original;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        original = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = original;</span><br><span class="line">        <span class="type">int</span> n = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">rand</span>()%(i<span class="number">+1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(ans[i],ans[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>（1）时间复杂度:O(n)，其中n为数组的长度，reset函数和shuffle函数的时间复杂度均为O(n)<br>（2）空间复杂度:O(n)，其中n为数组的长度，需要额外的空间存储原始数组的副本</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch对训练过程的优化（一）</title>
      <link href="/2025/09/10/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/conv/"/>
      <url>/2025/09/10/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/conv/</url>
      
        <content type="html"><![CDATA[<h1 id="数据层面优化"><a href="#数据层面优化" class="headerlink" title="数据层面优化"></a>数据层面优化</h1><p>数据是模型学习的原材料，数据层面的优化直接决定模型能学到多少有用的信息。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="数据标准化-归一化"><a href="#数据标准化-归一化" class="headerlink" title="数据标准化&#x2F;归一化"></a>数据标准化&#x2F;归一化</h3><p><strong>数据标准化&#x2F;归一化</strong>是指将数据转换为均值为0，方差为1的分布，这在很多模型中都是必要的。</p><h4 id="遇到的问题是什么？"><a href="#遇到的问题是什么？" class="headerlink" title="遇到的问题是什么？"></a>遇到的问题是什么？</h4><p>1.特征尺度差异导致“优化失衡”</p><p>原始数据中，不同特征的数值范围可能相差极大，例如：</p><p>在图像任务中，像素值范围是0到255，而手动设计的<strong>纹理特征</strong>的取值范围可能是0到1。</p><p>这种尺度差异会导致模型训练时的<strong>优化失衡</strong>问题，即模型在训练过程中，不同特征的<strong>优化速度</strong>可能相差极大，导致模型训练效率低下。</p><p>对于<strong>梯度下降</strong>等优化算法，参数更新量与特征值大小直接相关（更新量 &#x3D; 学习率<em>梯度</em>特征值）。数值大的特征（如“月收入”）会<strong>主导</strong>参数更新，而数值小的特征（如“年龄”）则会被忽略。</p><p><strong>损失函数</strong>的等高线会呈现极度拉伸的<strong>椭圆状</strong>，优化器需要反复曲折迭代才能找到最优解。</p><p>2.模型对“绝对数值”的敏感度较高，忽略了相对差异</p><p>许多模型的核心逻辑依赖特征间的“相对关系”，但原始数据的绝对数值会干扰这种判断：</p><p><strong>基于距离的模型如KNN、SVM等</strong>:距离计算（如欧式剧烈）会被大尺度特征主导。</p><p><strong>神经网络激活函数</strong>：ReLU在输入大于0时线性输出，若某些特征数值普遍较大，会导致对应神经元持续处于激活状态，梯度几乎为0，无法更新参数；而数值较小的特征可能始终处于死亡状态，完全失去作用。</p><p>3.特征分布偏移导致<strong>学习效率低下</strong></p><p>即使特征尺度相近，若分布差异大（如一个特征呈正态分布，另一个呈均匀分布），模型训练时可能会出现<strong>分布偏移</strong>问题，导致模型性能下降。</p><p>优化器的<strong>步长</strong>是针对整体特征设计的，若某些特征分布集中（方差小），优化步长可能过大，导致在该特征维度上<strong>跳过最优解</strong>。若分布分散（方差大），步长可能过小，需要多次迭代才能收敛。</p><p>例如：两个特征分别服从N（0，1）和N（0，100）分布，若使用<strong>标准梯度下降</strong>，则在第一个特征维度上的步长会是第二个特征维度上的100倍，这显然是不合理的。参数更新更剧烈，模型训练不稳定（损失值震荡）。</p><h4 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h4><p>标准化（如 Z-score：x’ &#x3D; (x - μ) &#x2F; σ）可以将特征转换为均值为0，方差为1的分布，解决特征尺度差异问题。</p><p>归一化（如 Min-Max Scaling：x’ &#x3D; (x - min) &#x2F; (max - min)）可以将特征转换为0到1之间的分布，解决特征分布偏移问题。</p><p>二者的核心作用是将特征映射到统一尺度或分布</p><h4 id="为什么能解决这个问题"><a href="#为什么能解决这个问题" class="headerlink" title="为什么能解决这个问题"></a>为什么能解决这个问题</h4><p>对于两个没有经过标准化和归一化的特征A和B，取值范围分别为[0,100]和[0,1]，计算梯度时，特征A的梯度会是特征B的100倍。</p><p>在标准化和归一化后，特征A和B的取值范围都变为[0,1]，计算梯度时，特征A的梯度与特征B的梯度规模一致。</p><h4 id="pytorch如何实现数据标准化与归一化"><a href="#pytorch如何实现数据标准化与归一化" class="headerlink" title="pytorch如何实现数据标准化与归一化"></a>pytorch如何实现数据标准化与归一化</h4><p><strong>数据标准化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有一个图像数据集，先计算其均值和标准差</span></span><br><span class="line">mean = torch.mean(data)</span><br><span class="line">std = torch.std(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义标准化变换</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean, std)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：对一个随机图像张量进行标准化</span></span><br><span class="line"></span><br><span class="line">img = torch.randn(<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">img_normalized = transform(img)</span><br></pre></td></tr></table></figure><p><strong>数据归一化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment">#结合transforms使用（适用于数据加载流程）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据的全局最大值和最小值</span></span><br><span class="line">global_max = data.<span class="built_in">max</span>()</span><br><span class="line">global_min = data.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义归一化变换（使用Lambda包装自定义函数）</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Lambda(<span class="keyword">lambda</span> x: (x - global_min) / (global_max - global_min))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据应用变换</span></span><br><span class="line">normalized_data = transform(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接在Tensor上操作（适用于小批量数据）</span></span><br><span class="line">normalized_tensor = (tensor - tensor.<span class="built_in">min</span>()) / (tensor.<span class="built_in">max</span>() - tensor.<span class="built_in">min</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
          <category> 训练优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 训练优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myblog</title>
      <link href="/2025/09/10/myblog/"/>
      <url>/2025/09/10/myblog/</url>
      
        <content type="html"><![CDATA[<p>myblog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2025/09/10/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2025/09/10/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a + b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>这是一个简单的JavaScript代码，用于计算两个数的和并输出结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MAGIS Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</title>
      <link href="/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/"/>
      <url>/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/</url>
      
        <content type="html"><![CDATA[<h1 id="MAGIS-Memory-Optimization-via-Coordinated-Graph-Transformation-and-Scheduling-for-DNN"><a href="#MAGIS-Memory-Optimization-via-Coordinated-Graph-Transformation-and-Scheduling-for-DNN" class="headerlink" title="MAGIS: Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN"></a>MAGIS: Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="图调度的局限性"><a href="#图调度的局限性" class="headerlink" title="图调度的局限性"></a>图调度的局限性</h3><pre><code>图调度技术（如张量重计算、张量换入与换出）的核心是时间维度的优化,通过调整张量的生命周期，减少内存占用，但是这无法改变张量本身的空间属性。例如：一个形状为[1024,1024]的张量，无论何时调度，其单次存储所需的内存大小都是固定的，即1024*1024*4=4MB。这导致在大形状张量场景下优化效果有限，重计算、换入/换出会增加额外的计算开销，显著牺牲性能。</code></pre><h3 id="图变换的孤立性"><a href="#图变换的孤立性" class="headerlink" title="图变换的孤立性"></a>图变换的孤立性</h3><pre><code>图变换（如算子融合、分裂、维度重排）的核心是空间维度优化--通过改变张量形状或图结构（如合并连续算子以减少中间张量）提升计算效率，但目前这类技术仅作为性能优化工具独立使用，未与内存需求联动。</code></pre><p>为此本文提出–MAGIS，一个协调图变换与图调度的DNN内存优化框架。MAGIS采用层次树（Hierarchical tree）表示分裂变换，这类变换能有效减小子图中的张量形状规模。为了控制复杂度，MAGIS基于图结构分析构建了轻量级搜索空间。此外,MAGIS将图调度拆解为“图变换”和“重排序”两个环节，并设计增量调度算法，以降低每次图变换步骤后的调度开销，从而实现二者的高效协同。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存优化 </tag>
            
            <tag> 图调度 </tag>
            
            <tag> 图优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133克隆图</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="133克隆图"><a href="#133克隆图" class="headerlink" title="133克隆图"></a>133克隆图</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。<br>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><p>class Node{<br>    int val;<br>    List<Node> neighbors;<br>}</p><h2 id="测试用例格式"><a href="#测试用例格式" class="headerlink" title="测试用例格式"></a>测试用例格式</h2><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（val &#x3D; 1），第二个节点值为2（val &#x3D; 2），以此类推。该图在测试用例中使用邻接列表表示。<br>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为1）。你必须返回给定节点的拷贝作为对克隆图的引用。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要解决无向连通图的深拷贝问题，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。</p><p>核心思路是创建每个节点的副本，并正确复制节点之间的连接关系</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>（1）使用DFS遍历图的每个节点<br>（2）使用哈希表map存储每个节点的原值和复制值，避免重复复制<br>（3）递归地复制每个节点的邻居</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>（1）首先处理空节点的情况<br>（2）在哈希表中寻找目标节点，若有则直接返回其复制值<br>（3）若没有则先复制当前节点，将其存储到哈希表中<br>（4）递归地复制当前节点的邻居</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(node)!=map.<span class="built_in">end</span>()) <span class="keyword">return</span> map[node];</span><br><span class="line">        Node* clone=<span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        map[node]=clone;</span><br><span class="line">        <span class="keyword">for</span>(Node* n:node-&gt;neighbors)&#123;</span><br><span class="line">            clone-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(N)，其中 N 是图中节点的数量。每个节点只会被访问一次。<br>空间复杂度：O(N)，其中 N 是图中节点的数量。哈希表和递归栈的空间复杂度均为 O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134加油站</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="134加油站"><a href="#134加油站" class="headerlink" title="134加油站"></a>134加油站</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条环路上有n个加油站，其中第i个加油站有汽油gas[i]升。<br>假设你有一辆容量无限的汽车，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组gas和cost，如果你可以按顺序环绕环路行驶一周，则返回出发时加油站的编号，否则返回-1。</p><p>如果存在解，保证他是唯一的。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>（1）注意到若总花费大于总油量，则一定不存在解。<br>（2）存在线性解法寻找具体的起始点：<br>    a.从第一个起始点开始，逐渐累积油量，若油量小于0，则从下一个加油站开始。<br>    b.重置当前油量<br>    c.遍历结束时，当前的起始点即为解。</p><h2 id="有效性分析"><a href="#有效性分析" class="headerlink" title="有效性分析"></a>有效性分析</h2><p>（1）为什么要从下一个加油站开始？<br>（2）若从第i个加油站开始，到第j个加油站油量小于0，则从第i+1个加油站开始到第j个加油站油量也一定小于0。<br>（3）因为这过程中存在这油量累积现象。</p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>（1）初始化总油量，当前油量和起始点为0<br>（2）遍历每一个加油站，更新总油量，当前油量。<br>（3）若当前油量小于0，<br>    a.更新起始点为下一个加油站<br>    b.重置当前油量<br>（4）遍历结束后，判断总油量是否大于等于0，若大于等于0，则返回起始点，否则返回-1。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    pubilc:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas,vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> totalRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> currentRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                totalRank+=gas[i]-cost[i];</span><br><span class="line">                currentRank+=gas[i]-cost[i];</span><br><span class="line">                <span class="keyword">if</span>(currentRank&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    start = i<span class="number">+1</span>;</span><br><span class="line">                    currentRank = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalRank&gt;=<span class="number">0</span>?start:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，遍历所有的加油站一次<br>空间复杂度：O(1)，只使用了常数个变量</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/09/hello-world/"/>
      <url>/2025/09/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
