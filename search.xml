<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>372超级次方</title>
      <link href="/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/372%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
      <url>/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/372%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1>372超级次方</h1><h2 id="题目描述">题目描述</h2><p>你的任务是对a的b次方mod1337取模，其中a是一个正整数，b是一个非常大的数并且会以数组形式给出。</p><h2 id="题目分析">题目分析</h2><p>核心难点在于b是一个非常大的数并且没有办法使用整数来表示，所以我们需要使用递归的方式来解决这个问题。<br>解题的关键在于两条数学性质：<br>（1）a<em>b mod p = (a mod p) * (b mod p) mod p;<br>（2）a^(10+b) mod p = (a^10 mod p)</em>(a^b mod p) mod p;</p><h2 id="解题思路">解题思路</h2><p>（1）指数分解：将数组b按位分解，例如b = [1,2,3],则b表示的数字为123，我们将其分解为100<em>1+10</em>2+3=123;<br>（2）快速幂：使用快速幂算法计算a^b mod p;<br>（3）递归取模：递归地计算(a^10 mod p)*(a^b mod p) mod p;每一步都严格取模。</p><h2 id="算法步骤">算法步骤</h2><p>（1）初始化result = 1,以及a = a % mod;<br>（2）判断是否b为0，若为0则返回result;<br>（3）递归计算b的每一位数字,result = (result^10 mod p)*(a^b(当前位)mod p)mod p<br>（4）返回result;</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">modPower</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> exp,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        base = base %mod;</span><br><span class="line">        <span class="keyword">while</span>(exp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exp%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                result =(<span class="number">1LL</span>*result*base)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            base = (<span class="number">1LL</span>*base*base)%mod;</span><br><span class="line">            exp /=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">superPow</span><span class="params">(<span class="type">int</span> a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">        a = a%mod;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;d:b)&#123;</span><br><span class="line">            result = (<span class="number">1LL</span>*<span class="built_in">modPower</span>(result,<span class="number">10</span>,mod)%mod)*(<span class="number">1LL</span>*<span class="built_in">modPower</span>(a,d,mod)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(nlogp)，其中n是数组b的长度，logp是快速幂的时间复杂度;<br>（2）空间复杂度：O(n)，递归栈的空间复杂度;</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>436寻找右区间</title>
      <link href="/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/436%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/"/>
      <url>/2025/09/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/436%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1>436寻找右区间</h1><h2 id="题目描述">题目描述</h2><p>给你一个数组intervals，其中intervals[i] = [starti, endi]，表示第i个区间的开始和结束。</p><p>区间i的右区间是满足startj &gt;= endi的最小的j,注意i可能等于j。</p><p>返回一个由每个区间i的右区间下表组成的数组，如果i不存在这样的右区间，则返回-1。</p><h2 id="题目分析">题目分析</h2><p>（1）核心需求：寻找每个区间的右区间；<br>（2）这是典型的下界查找问题，可以使用排序+二分查找来解决这个问题。</p><h2 id="解题思路">解题思路</h2><p>（1）收集所有区间的起始点和索引<br>（2）对所有区间的起始点进行排序<br>（3）遍历每一个区间，使用二分查找找到第一个大于等于endi的起始点的索引<br>（4）如果找到，则返回对应的索引，否则返回-1</p><h2 id="trick">trick</h2><p>（1）使用sort来进行排序<br>（2）使用lower_bound来进行二分查找</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; startIntervals;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            startIntervals.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(intervals[i][<span class="number">0</span>],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(startIntervals.<span class="built_in">begin</span>(),startIntervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">results</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(startIntervals.<span class="built_in">begin</span>(),startIntervals.<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(end,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(it!=startIntervals.<span class="built_in">end</span>())&#123;</span><br><span class="line">                results[i] = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(nlogn)，其中n是区间的数量，排序的时间复杂度为O(nlogn)，二分查找的时间复杂度为O(logn)，所以总时间复杂度为O(nlogn)；<br>（2）空间复杂度：O(n)，需要额外的空间来存储所有区间的起始点和索引；</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 力扣刷题 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MEMAGmemory-Efficient Graph Transformation via Access Pattern-Aware Optimization for DNNs</title>
      <link href="/2025/09/20/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/memag/"/>
      <url>/2025/09/20/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/memag/</url>
      
        <content type="html"><![CDATA[<h1>MEMAG: Memory-Efficient Graph Transformation via Access Pattern-Aware Optimization for DNNs</h1><h2 id="背景">背景</h2><h3 id="现有内存优化技术的局限性">现有内存优化技术的局限性</h3><p>深度神经网络（DNN）的内存优化技术主要分为两类：时间维度优化（图调度）和空间维度优化（图变换），但两者均存在显著缺陷：</p><p>图调度技术（如重计算、换入换出）通过调整张量生命周期减少内存占用，但无法改变张量的空间属性。例如，一个形状为[1024, 1024]的张量，无论何时调度，其单次存储所需的4MB内存是固定的。在大张量场景下，这类技术优化效果有限，且会引入额外计算或传输开销。</p><p>图变换技术（如算子融合、分裂）通过改变张量形状或图结构优化内存，但现有方法存在<strong>访问模式感知缺失</strong>的关键问题：</p><ul><li>仅关注张量形状拆分，忽视内存布局对访问效率的影响；</li><li>未考虑算子对内存访问模式的敏感性差异；</li><li>分裂变换可能破坏内存连续性，导致硬件利用率暴跌。</li></ul><h3 id="内存访问与计算效率的协同挑战">内存访问与计算效率的协同挑战</h3><p>现代GPU/CPU的计算能力提升远超内存带宽增长（如A100的40TFLOPS计算能力对应1.5TB/s带宽），内存访问效率已成为性能瓶颈。现有图变换技术因缺乏对内存访问模式的建模，导致&quot;内存节省&quot;与&quot;计算效率&quot;难以兼得：</p><ul><li>分裂大张量虽降低内存峰值，但非连续访问使带宽利用率从80%降至40%以下；</li><li>算子融合提升计算效率，却可能因内存局部性破坏导致延迟增加。</li></ul><p>为此，本文提出<strong>MEMAG（Memory-Efficient Graph Transformation）</strong>，一种基于访问模式感知的图级优化框架。MEMAG通过建立&quot;张量布局-访问模式-算子特性&quot;的关联模型，实现内存节省与计算效率的协同优化，突破现有技术的固有矛盾。</p><h2 id="引言">引言</h2><p>DNN模型的内存消耗与计算效率已成为制约其部署与应用的核心瓶颈，主要源于三个方面：</p><ol><li><p><strong>超大张量的内存占用</strong>：Transformer的多头注意力层中，<code>QK^T</code>矩阵（<code>seq_len=4096</code>）单头占用64MB，32头合计达2GB；高分辨率图像模型的特征图（如1024×1024）单张占用4MB，批量处理时内存需求呈线性增长。</p></li><li><p><strong>长生命周期张量的累积效应</strong>：模型参数（如BERT-large的3.4亿参数占用13.6GB）、训练过程中的激活值（生命周期贯穿反向传播）、多分支结构的中间张量，共同推高内存峰值。</p></li><li><p><strong>内存访问效率的严重损耗</strong>：GPU内存采用分层架构（寄存器→L2缓存→全局内存），连续访问可提升缓存命中率达70%以上，而碎片化访问会导致命中率降至30%以下，计算核心因数据饥饿闲置。</p></li></ol><h3 id="现有技术的核心缺陷">现有技术的核心缺陷</h3><ul><li><p><strong>图调度技术</strong>：以重计算为例，虽能减少激活值存储，但重复计算会增加30%以上的延迟；换入换出则受限于PCIe带宽，在单卡环境下无法通过异步传输隐藏延迟。</p></li><li><p><strong>图变换技术</strong>：MAGIS等框架的分裂变换仅基于维度可分性决策，未考虑内存布局。实验显示，对Transformer的注意力层应用分裂后，内存峰值降低70%，但因访问碎片化导致延迟增加25%。</p></li><li><p><strong>硬件感知优化</strong>：现有工作多聚焦计算密集型算子（如GEMM）的底层优化，缺乏图级别的内存访问协同策略，无法全局优化访问模式。</p></li></ul><h3 id="memag的创新思路">MEMAG的创新思路</h3><p>MEMAG的核心突破在于将<strong>内存访问模式</strong>引入图级中间表示与优化决策，具体包括：</p><ol><li><p>构建<strong>访问感知图（Access-Aware Graph, AA-Graph）</strong>，在计算图中嵌入张量布局、访问模式、算子敏感性等关键属性；</p></li><li><p>设计<strong>局部性保持变换规则</strong>，确保分裂/融合等操作不破坏内存连续性，维持高带宽利用率；</p></li><li><p>提出<strong>算子差异化优化策略</strong>，对带宽敏感算子（如矩阵乘法）严格保持访问模式，对容忍度高的算子（如ReLU）灵活优化以最大化内存节省。</p></li></ol><h3 id="本文贡献">本文贡献</h3><ol><li><p>提出AA-Graph中间表示，首次在图级别建立&quot;张量布局-访问模式-算子特性&quot;的关联模型，填补现有图表示在内存访问建模上的空白；</p></li><li><p>设计局部性保持变换算法，通过连续性约束与维度评分机制，在减少内存峰值的同时维持高带宽利用率；</p></li><li><p>实现MEMAG框架并在多种DNN模型上验证：相比现有方法，内存峰值降低65-75%，同时延迟增加控制在5%以内，帕累托边界优于MAGIS等先进技术。</p></li></ol><h2 id="动机">动机</h2><p>内存访问模式对DNN性能的影响可通过具体案例清晰展现，揭示现有图变换技术的固有缺陷：</p><h3 id="案例1：transformer注意力层的分裂变换">案例1：Transformer注意力层的分裂变换</h3><p>在A100上运行<code>seq_len=4096</code>的BERT模型：</p><ul><li><strong>原始计算</strong>：<code>QK^T</code>矩阵乘法的内存访问具有强连续性，单次事务加载32个连续元素，带宽利用率达82%，计算延迟12ms；</li><li><strong>传统分裂（n=8）</strong>：按<code>seq_len</code>均匀拆分后，子张量地址非连续，每次事务仅能有效利用4个元素，带宽利用率降至39%，延迟增至15ms（+25%）；</li><li><strong>MEMAG优化</strong>：沿连续存储维度拆分，保持子张量地址连续性，带宽利用率维持76%，延迟12.6ms（+5%）。</li></ul><h3 id="案例2：resnet卷积层的融合变换">案例2：ResNet卷积层的融合变换</h3><ul><li><strong>原始计算</strong>：3×3卷积+ReLU的独立执行，存在两次内存读写，延迟8ms；</li><li><strong>传统融合</strong>：合并为单算子但改变内存布局（从NHWC转为NCHW），导致访问碎片化，延迟增至9.5ms（+19%）；</li><li><strong>MEMAG优化</strong>：融合时保持NHWC布局，连续访问特征图，延迟降至6.8ms（-15%）。</li></ul><h3 id="核心发现">核心发现</h3><ol><li><p><strong>内存布局决定访问效率</strong>：张量的物理存储格式（如NHWC/NCHW、块对齐方式）直接影响访问连续性，相同逻辑形状的张量可能因布局不同导致2-3倍的性能差异；</p></li><li><p><strong>算子敏感性呈两极分化</strong>：矩阵乘法、卷积等算子的延迟与带宽利用率呈强线性相关（相关系数&gt;0.9），而激活函数、池化等算子对访问模式敏感度低（相关系数&lt;0.3）；</p></li><li><p><strong>变换粒度存在临界值</strong>：当分裂粒度小于GPU内存事务对齐粒度（如256B）时，带宽利用率会断崖式下降，这一临界值因算子类型而异。</p></li></ol><p>这些发现表明：图变换必须<strong>将内存访问模式纳入决策模型</strong>，而现有方法的中间表示缺乏此类信息，导致优化效果受限。MEMAG通过构建访问感知图，实现了内存节省与效率保持的协同。</p><h2 id="系统框架">系统框架</h2><p>MEMAG框架由四个核心组件构成：<strong>访问感知图生成器（AAG-Generator）</strong>、<strong>内存特性分析器（M-Analyzer）</strong>、<strong>局部性保持优化器（LPO）</strong>、<strong>增量调度器（IS）</strong>，整体架构如图1所示。</p><h3 id="aag-generator-访问感知图生成器">AAG-Generator（访问感知图生成器）</h3><p>负责将原始计算图转换为包含内存访问信息的AA-Graph，核心是为张量和算子添加扩展属性：</p><h4 id="1-张量节点属性">1. 张量节点属性</h4><ul><li><code>mem_layout</code>：存储格式（<code>&quot;NHWC&quot;</code>/<code>&quot;NCHW&quot;</code>/<code>&quot;blocked_16x16&quot;</code>）、内存起始偏移量（<code>offset=0x7f...</code>）、对齐方式（<code>align=256B</code>）；</li><li><code>dim_contiguity</code>：各维度的连续性标记（<code>True</code>/<code>False</code>），如NHWC的H/W维度为连续，C维度为非连续；</li><li><code>access_footprint</code>：访问区域掩码（如<code>[0..511, 0..4095]</code>表示连续行访问）；</li><li><code>element_size</code>：元素字节数（如FP16为2B）。</li></ul><h4 id="2-算子节点属性">2. 算子节点属性</h4><ul><li><code>access_pattern</code>：访问模式（<code>&quot;strided&quot;</code>连续访问/<code>&quot;random&quot;</code>随机访问/<code>&quot;strided2D&quot;</code>二维连续访问）；</li><li><code>bandwidth_sensitivity</code>：带宽敏感系数（0-1，矩阵乘法0.9/卷积0.8/ReLU0.3）；</li><li><code>output_layout</code>：输出张量的存储格式（如卷积算子默认输出<code>&quot;NCHW&quot;</code>）；</li><li><code>latency_model</code>：延迟模型（<code>a×B + b</code>，其中<code>B</code>为带宽利用率，<code>a/b</code>为算子特定系数）。</li></ul><h3 id="m-analyzer-内存特性分析器">M-Analyzer（内存特性分析器）</h3><p>基于AA-Graph分析内存访问特性，为优化决策提供依据：</p><ol><li><p><strong>连续性评估</strong>：对每个张量维度计算连续性得分：<br>[ \text{contiguity}(d) = \frac{\text{连续访问字节数}}{\text{总访问字节数}} ]<br>得分越高，该维度越适合作为分裂维度。</p></li><li><p><strong>带宽敏感性排序</strong>：根据<code>bandwidth_sensitivity</code>对算子排序，识别需要优先保持访问模式的关键算子。</p></li><li><p><strong>内存热点定位</strong>：结合张量大小与生命周期，识别内存峰值贡献最大的子图（内存热点），优先对其应用优化。</p></li></ol><h3 id="lpo-局部性保持优化器">LPO（局部性保持优化器）</h3><p>实现核心的图变换逻辑，包括分裂、融合等操作，核心是<strong>局部性保持规则</strong>：</p><h4 id="1-分裂变换决策">1. 分裂变换决策</h4><ul><li><strong>维度选择</strong>：优先选择<code>dim_contiguity=True</code>的维度，且分裂后子张量的<code>access_footprint</code>必须为连续区间；</li><li><strong>粒度控制</strong>：子张量大小不得小于临界值（如256B），对高敏感算子（系数&gt;0.7）需满足<code>子张量大小 ≥ 32×element_size</code>；</li><li><strong>评分函数</strong>：<br>[ \text{score}(d) = \alpha \cdot \text{mem_saving}(d) + (1-\alpha) \cdot \text{contiguity}(d) ]<br>其中<code>mem_saving</code>为内存节省率，<code>α</code>为平衡系数（默认0.5）。</li></ul><h4 id="2-融合变换决策">2. 融合变换决策</h4><ul><li>仅融合访问模式兼容的算子（如均为<code>&quot;strided&quot;</code>访问）；</li><li>融合后输出张量的<code>mem_layout</code>需保持与输入一致，避免布局转换导致的碎片化。</li></ul><h4 id="3-算子差异化策略">3. 算子差异化策略</h4><ul><li>高敏感算子（系数&gt;0.7）：严格遵循局部性规则，允许内存节省率适度降低（如从75%降至70%）；</li><li>低敏感算子（系数&lt;0.3）：可灵活拆分以最大化内存节省，容忍带宽利用率下降。</li></ul><h3 id="is-增量调度器">IS（增量调度器）</h3><p>基于AA-Graph的访问特性优化调度顺序：</p><ul><li>对高敏感算子的子图优先调度，利用缓存局部性；</li><li>调整Store/Load算子位置，确保数据换入时已按连续地址排列；</li><li>继承MAGIS的增量调度思想，仅重新调度受变换影响的子图，降低开销。</li></ul><h2 id="aag-generator的形式化定义">AAG-Generator的形式化定义</h2><h3 id="访问感知图-aa-graph">访问感知图（AA-Graph）</h3><p>AA-Graph被形式化为一个有向图( G = (V_T \cup V_O, E) )，其中：</p><ul><li>( V_T )为张量节点集合，每个节点( t \in V_T )关联属性集合( A_T(t) = { \text{mem_layout}, \text{dim_contiguity}, … } )；</li><li>( V_O )为算子节点集合，每个节点( o \in V_O )关联属性集合( A_O(o) = { \text{access_pattern}, \text{bandwidth_sensitivity}, … } )；</li><li>( E \subseteq (V_T \times V_O) \cup (V_O \times V_T) )为数据依赖边，表示算子与输入/输出张量的关联。</li></ul><h3 id="分裂变换的形式化">分裂变换的形式化</h3><p>分裂变换( f = (S, d, n) )需满足：</p><ol><li><strong>基础约束</strong>（继承MAGIS）：弱连通性、凸性、无冗余计算；</li><li><strong>连续性约束</strong>：张量( t \in S )的维度( d )满足( \text{dim_contiguity}(t, d) = \text{True} )；</li><li><strong>粒度约束</strong>：( \text{size}(t, d)/n \geq \text{critical_size}(o) )，其中( o \in S )为算子，( \text{critical_size} )为其临界粒度。</li></ol><h3 id="带宽利用率模型">带宽利用率模型</h3><p>给定算子( o )及其访问的张量( t )，带宽利用率( U )定义为：<br>[ U = \frac{\sum_{i=1}^k \text{contiguous_length}(t, i)}{\sum_{i=1}^k \text{access_length}(t, i)} ]<br>其中( \text{contiguous_length}(t, i) )为第( i )次访问的连续字节数，( \text{access_length}(t, i) )为总访问字节数。</p><h2 id="m-analyzer的实现">M-Analyzer的实现</h2><h3 id="内存热点分析">内存热点分析</h3><p>基于张量的生命周期与大小，计算每个子图的内存贡献：<br>[ \text{hotness}(S) = \sum_{t \in \text{live}(S)} \text{size}(t) \times \text{duration}(t) ]<br>其中( \text{live}(S) )为子图( S )执行期间存活的张量集合，( \text{duration}(t) )为存活时间。热点子图（( \text{hotness}(S) &gt; \theta )）将被优先优化。</p><h3 id="算子敏感性计算">算子敏感性计算</h3><p>通过硬件 profiling 建立算子延迟与带宽利用率的关系模型：<br>[ \text{latency}(o, U) = a_o \times (1 - U) + b_o ]<br>其中( a_o )和( b_o )为算子特定参数，通过线性回归拟合。带宽敏感系数定义为( a_o / (a_o + b_o) )，反映延迟对带宽的敏感程度。</p><h2 id="lpo的优化算法">LPO的优化算法</h2><h3 id="分裂变换算法">分裂变换算法</h3><ol><li>输入：AA-Graph ( G )、内存热点子图( S )、最大分裂数( n_{\text{max}} )；</li><li>对( S )中所有张量( t )，收集满足( \text{dim_contiguity}(t, d) = \text{True} )的维度( d )；</li><li>对每个候选维度( d )，计算不同分裂数( n )下的( \text{score}(d, n) )；</li><li>选择最高分对应的( (d, n) )，执行分裂变换；</li><li>验证分裂后子张量的连续性，若不满足则回溯调整。</li></ol><h3 id="融合变换算法">融合变换算法</h3><ol><li>输入：AA-Graph ( G )、连续算子序列( o_1, o_2, …, o_k )；</li><li>检查算子访问模式是否兼容（均为连续访问）；</li><li>评估融合后输出张量的布局是否保持连续性；</li><li>若满足条件，执行融合并更新AA-Graph属性。</li></ol><h2 id="实验结果">实验结果</h2><h3 id="实验设置">实验设置</h3><ul><li>硬件：NVIDIA A100（40GB）、Intel Xeon 8380（28核）；</li><li>模型：BERT-base（<code>seq_len=4096</code>）、ResNet-50（<code>input=1024x1024</code>）、GPT-2（<code>seq_len=1024</code>）、YOLOv5（<code>input=640x640</code>）；</li><li>基线方法：原始计算图（Baseline）、MAGIS、TASO、AutoTVM。</li></ul><h3 id="核心指标">核心指标</h3><ul><li>内存峰值（GB）：通过<code>nvidia-smi</code>监控；</li><li>端到端延迟（ms）：通过高精度计时器测量；</li><li>带宽利用率（%）：实际带宽/理论带宽（A100为1.5TB/s）；</li><li>帕累托边界：内存-延迟双目标优化的最优前沿。</li></ul><h3 id="主要结果">主要结果</h3><h4 id="1-单模型性能对比-bert-base">1. 单模型性能对比（BERT-base）</h4><table><thead><tr><th>方法</th><th>内存峰值</th><th>延迟</th><th>带宽利用率</th><th>内存降低</th><th>延迟变化</th></tr></thead><tbody><tr><td>Baseline</td><td>8.2GB</td><td>12.0ms</td><td>82%</td><td>-</td><td>-</td></tr><tr><td>MAGIS</td><td>2.1GB</td><td>15.0ms</td><td>39%</td><td>74%</td><td>+25%</td></tr><tr><td>TASO</td><td>7.8GB</td><td>10.5ms</td><td>79%</td><td>5%</td><td>-12%</td></tr><tr><td>MEMAG</td><td>2.3GB</td><td>12.6ms</td><td>76%</td><td>72%</td><td>+5%</td></tr></tbody></table><h4 id="2-多模型内存降低率-固定延迟增加-10">2. 多模型内存降低率（固定延迟增加&lt;10%）</h4><table><thead><tr><th>模型</th><th>MAGIS</th><th>TASO</th><th>AutoTVM</th><th>MEMAG</th></tr></thead><tbody><tr><td>BERT-base</td><td>74%</td><td>5%</td><td>8%</td><td>72%</td></tr><tr><td>ResNet-50</td><td>75%</td><td>12%</td><td>15%</td><td>73%</td></tr><tr><td>GPT-2</td><td>68%</td><td>7%</td><td>10%</td><td>65%</td></tr><tr><td>YOLOv5</td><td>70%</td><td>10%</td><td>12%</td><td>68%</td></tr></tbody></table><h4 id="3-帕累托边界对比">3. 帕累托边界对比</h4><p>在BERT模型上，MEMAG的帕累托边界显著优于其他方法：</p><ul><li>当内存限制为2GB时，MEMAG延迟（14.2ms）比MAGIS（18.5ms）低23%；</li><li>当延迟限制为13ms时，MEMAG内存（2.8GB）比MAGIS（3.5GB）低20%。</li></ul><h3 id="结果分析">结果分析</h3><ul><li>MEMAG在内存降低率上与MAGIS相当（72% vs 74%），但延迟增加仅为MAGIS的1/5（5% vs 25%），核心原因是带宽利用率提升了37个百分点（76% vs 39%）；</li><li>对带宽敏感的模型（如BERT、ResNet），MEMAG的优化效果更显著，而对低敏感模型（如YOLOv5），优势相对缩小但仍保持领先；</li><li>算子差异化策略有效：对矩阵乘法的优化使延迟降低20-25%，而对ReLU的灵活拆分确保了内存节省率。</li></ul><h2 id="相关工作">相关工作</h2><h3 id="图调度技术">图调度技术</h3><ul><li><strong>重计算</strong>：Chen等人提出的Checkpointing技术通过选择性重计算激活值减少内存，但其未考虑重计算过程中的内存访问效率；</li><li><strong>换入换出</strong>：Xu等人设计的FlexFlow支持张量动态换入换出，但单卡环境下无法隐藏传输延迟。</li></ul><h3 id="图变换技术">图变换技术</h3><ul><li><strong>MAGIS</strong>：协调图变换与调度实现内存优化，但缺乏访问模式感知，导致单卡效率损失；</li><li><strong>TASO</strong>：通过算子融合提升计算效率，但未针对内存峰值优化；</li><li><strong>AutoGraph</strong>：自动搜索最优计算图，但搜索空间未包含内存访问相关特征。</li></ul><h3 id="硬件感知优化">硬件感知优化</h3><ul><li><strong>TVM/AutoTVM</strong>：基于硬件特性优化算子实现，但聚焦于单个算子而非图级协同；</li><li><strong>Alchemist</strong>：优化张量布局提升缓存利用率，但未与图变换结合。</li></ul><p>MEMAG与现有工作的核心区别在于：首次在图级别建立内存访问模式的关联模型，实现全局的&quot;内存-效率&quot;协同优化。</p><h2 id="结论">结论</h2><p>本文提出MEMAG，一种基于访问模式感知的图级优化框架，通过构建AA-Graph中间表示，实现了DNN模型内存节省与计算效率的协同提升。MEMAG的核心创新在于将内存访问模式纳入图变换决策，设计局部性保持规则与算子差异化策略，解决了现有技术中&quot;内存节省伴随效率损失&quot;的固有矛盾。</p><p>实验表明，MEMAG在多种DNN模型上实现65-75%的内存峰值降低，同时延迟增加控制在5%以内，帕累托边界显著优于MAGIS等先进技术。未来工作将扩展至动态形状场景（如可变序列长度），并探索基于学习的访问模式预测方法。</p><p>MEMAG为DNN内存优化提供了新范式，证明图级优化必须兼顾内存空间属性与访问效率，这一思路可推广至更广泛的硬件平台与模型类型。</p>]]></content>
      
      
      <categories>
          
          <category> 学术论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存优化 </tag>
            
            <tag> 图变换 </tag>
            
            <tag> 访问模式 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>318. 最大单词长度乘积</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/318%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1>318. 最大单词长度乘积</h1><h2 id="题目描述">题目描述</h2><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p><h2 id="题目解析">题目解析</h2><p>解题的关键首先是判断两个单词是否有公共字母，然后计算它们的长度乘积。</p><p>如果采用穷举的方式判断是否含有公共字母，那么时间复杂度会是O(n^2 * m)，其中n是单词的数量，m是单词的平均长度。</p><p>所以可以采用编码的方式。</p><p>每个单词可以用一个26位的二进制数表示，第i位为1表示单词中包含第i个字母，为0表示不包含。</p><p>例如，单词&quot;abc&quot;可以表示为00000000000000000000000111。</p><p>然后判断两个单词是否有公共字母，只需要判断它们的二进制数是否有交集即可。</p><p>如果两个单词的二进制数相与的结果为0，那么这两个单词就没有公共字母。</p><p>所以可以先遍历一遍数组，将每个单词编码为一个26位的二进制数，然后再遍历一遍数组，判断每个单词是否与其他单词有公共字母。</p><p>如果有公共字母，就计算它们的长度乘积，取最大值即可。</p><p>如果没有公共字母，就返回0。</p><h2 id="代码思路">代码思路</h2><p>（1）数据变量有masks和lengths，分别存储每个单词的二进制编码和长度。<br>（2）遍历数组，将每个单词编码为一个26位的二进制数，存储在masks数组中，同时记录每个单词的长度，存储在lengths数组中。<br>（3）遍历数组中每个单词的二元组合，判断是否含有公共字母，若没有则计算乘积并保留最大值。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masks</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lengths</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:words[i])&#123;</span><br><span class="line">                masks[i] |= (<span class="number">1</span>&lt;&lt;(c-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            lengths[i] = words[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((masks[i]&amp;masks[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,lengths[i]*lengths[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码复杂度分析">代码复杂度分析</h2><p>时间复杂度：O(n^2 +L)，其中n是单词的数量，L是单词的总长度。<br>空间复杂度：O(n)，其中n是单词的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. 打乱数组</title>
      <link href="/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
      <url>/2025/09/18/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/384%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>384. 打乱数组</h1><h2 id="题目描述">题目描述</h2><p>给你一个整数数组nums,设计算法来打乱一个没有重复元素的数组。</p><p>打乱后，数组的所有排列应该是等可能的。</p><p>实现Solution类:</p><p>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p><h2 id="题目解析">题目解析</h2><p>问题类型：这是一道设计随机算法的设计题，核心在于实现一个能够公平打乱元素的随机算法，确保所有排列具有等可能的概率。</p><p>核心问题：设计一个类，支持初始化数组，重置数组至初始状态，以及随机打乱数组。</p><p>关键约束：<br>（1）打乱后的数组需保证所有元素的排列能够等可能的出现<br>（2）reset()函数能够将数组重置到初始化的状态<br>（3）数组没有重复性的元素</p><p>解题思路：<br>（1）创建一个私有变量，在类初始化时将nums数组复制给他，作为整个数组的副本<br>（2）reset函数在调用时返回上述私有变量<br>（3）shuffle函数在调用时，首先提取副本，然后从后往前遍历数组，应用Fisher-Yates洗牌算法，随机交换当前元素与之前的一个元素，确保每个元素在每个位置的概率相等。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; original;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        original = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = original;</span><br><span class="line">        <span class="type">int</span> n = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">rand</span>()%(i<span class="number">+1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(ans[i],ans[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度:O(n)，其中n为数组的长度，reset函数和shuffle函数的时间复杂度均为O(n)<br>（2）空间复杂度:O(n)，其中n为数组的长度，需要额外的空间存储原始数组的副本</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 设计 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch对训练过程的优化（一）</title>
      <link href="/2025/09/10/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/conv/"/>
      <url>/2025/09/10/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/conv/</url>
      
        <content type="html"><![CDATA[<h1>数据层面优化</h1><p>数据是模型学习的原材料，数据层面的优化直接决定模型能学到多少有用的信息。</p><h2 id="数据预处理">数据预处理</h2><h3 id="数据标准化-归一化">数据标准化/归一化</h3><p><strong>数据标准化/归一化</strong>是指将数据转换为均值为0，方差为1的分布，这在很多模型中都是必要的。</p><h4 id="遇到的问题是什么？">遇到的问题是什么？</h4><p>1.特征尺度差异导致“优化失衡”</p><p>原始数据中，不同特征的数值范围可能相差极大，例如：</p><p>在图像任务中，像素值范围是0到255，而手动设计的<strong>纹理特征</strong>的取值范围可能是0到1。</p><p>这种尺度差异会导致模型训练时的<strong>优化失衡</strong>问题，即模型在训练过程中，不同特征的<strong>优化速度</strong>可能相差极大，导致模型训练效率低下。</p><p>对于<strong>梯度下降</strong>等优化算法，参数更新量与特征值大小直接相关（更新量 = 学习率<em>梯度</em>特征值）。数值大的特征（如“月收入”）会<strong>主导</strong>参数更新，而数值小的特征（如“年龄”）则会被忽略。</p><p><strong>损失函数</strong>的等高线会呈现极度拉伸的<strong>椭圆状</strong>，优化器需要反复曲折迭代才能找到最优解。</p><p>2.模型对“绝对数值”的敏感度较高，忽略了相对差异</p><p>许多模型的核心逻辑依赖特征间的“相对关系”，但原始数据的绝对数值会干扰这种判断：</p><p><strong>基于距离的模型如KNN、SVM等</strong>:距离计算（如欧式剧烈）会被大尺度特征主导。</p><p><strong>神经网络激活函数</strong>：ReLU在输入大于0时线性输出，若某些特征数值普遍较大，会导致对应神经元持续处于激活状态，梯度几乎为0，无法更新参数；而数值较小的特征可能始终处于死亡状态，完全失去作用。</p><p>3.特征分布偏移导致<strong>学习效率低下</strong></p><p>即使特征尺度相近，若分布差异大（如一个特征呈正态分布，另一个呈均匀分布），模型训练时可能会出现<strong>分布偏移</strong>问题，导致模型性能下降。</p><p>优化器的<strong>步长</strong>是针对整体特征设计的，若某些特征分布集中（方差小），优化步长可能过大，导致在该特征维度上<strong>跳过最优解</strong>。若分布分散（方差大），步长可能过小，需要多次迭代才能收敛。</p><p>例如：两个特征分别服从N（0，1）和N（0，100）分布，若使用<strong>标准梯度下降</strong>，则在第一个特征维度上的步长会是第二个特征维度上的100倍，这显然是不合理的。参数更新更剧烈，模型训练不稳定（损失值震荡）。</p><h4 id="如何解决这个问题">如何解决这个问题</h4><p>标准化（如 Z-score：x’ = (x - μ) / σ）可以将特征转换为均值为0，方差为1的分布，解决特征尺度差异问题。</p><p>归一化（如 Min-Max Scaling：x’ = (x - min) / (max - min)）可以将特征转换为0到1之间的分布，解决特征分布偏移问题。</p><p>二者的核心作用是将特征映射到统一尺度或分布</p><h4 id="为什么能解决这个问题">为什么能解决这个问题</h4><p>对于两个没有经过标准化和归一化的特征A和B，取值范围分别为[0,100]和[0,1]，计算梯度时，特征A的梯度会是特征B的100倍。</p><p>在标准化和归一化后，特征A和B的取值范围都变为[0,1]，计算梯度时，特征A的梯度与特征B的梯度规模一致。</p><h4 id="pytorch如何实现数据标准化与归一化">pytorch如何实现数据标准化与归一化</h4><p><strong>数据标准化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有一个图像数据集，先计算其均值和标准差</span></span><br><span class="line">mean = torch.mean(data)</span><br><span class="line">std = torch.std(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义标准化变换</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean, std)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：对一个随机图像张量进行标准化</span></span><br><span class="line"></span><br><span class="line">img = torch.randn(<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">img_normalized = transform(img)</span><br></pre></td></tr></table></figure><p><strong>数据归一化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment">#结合transforms使用（适用于数据加载流程）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据的全局最大值和最小值</span></span><br><span class="line">global_max = data.<span class="built_in">max</span>()</span><br><span class="line">global_min = data.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义归一化变换（使用Lambda包装自定义函数）</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Lambda(<span class="keyword">lambda</span> x: (x - global_min) / (global_max - global_min))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据应用变换</span></span><br><span class="line">normalized_data = transform(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接在Tensor上操作（适用于小批量数据）</span></span><br><span class="line">normalized_tensor = (tensor - tensor.<span class="built_in">min</span>()) / (tensor.<span class="built_in">max</span>() - tensor.<span class="built_in">min</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PyTorch </category>
          
          <category> 训练优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 训练优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myblog</title>
      <link href="/2025/09/10/myblog/"/>
      <url>/2025/09/10/myblog/</url>
      
        <content type="html"><![CDATA[<p>myblog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2025/09/10/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2025/09/10/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="代码演示">代码演示</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = a + b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br></pre></td></tr></table></figure><h3 id="代码说明">代码说明</h3><p>这是一个简单的JavaScript代码，用于计算两个数的和并输出结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MAGIS Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</title>
      <link href="/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/"/>
      <url>/2025/09/10/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/magis/</url>
      
        <content type="html"><![CDATA[<h1>MAGIS: Memory Optimization via Coordinated Graph Transformation and Scheduling for DNN</h1><h2 id="背景">背景</h2><h3 id="图调度的局限性">图调度的局限性</h3><pre><code>图调度技术（如张量重计算、张量换入与换出）的核心是时间维度的优化,通过调整张量的生命周期，减少内存占用，但是这无法改变张量本身的空间属性。例如：一个形状为[1024,1024]的张量，无论何时调度，其单次存储所需的内存大小都是固定的，即1024*1024*4=4MB。这导致在大形状张量场景下优化效果有限，重计算、换入/换出会增加额外的计算开销，显著牺牲性能。</code></pre><h3 id="图变换的孤立性">图变换的孤立性</h3><pre><code>图变换（如算子融合、分裂、维度重排）的核心是空间维度优化--通过改变张量形状或图结构（如合并连续算子以减少中间张量）提升计算效率，但目前这类技术仅作为性能优化工具独立使用，未与内存需求联动。</code></pre><p>为此本文提出–MAGIS，一个协调图变换与图调度的DNN内存优化框架。MAGIS采用层次树（Hierarchical tree）表示分裂变换，这类变换能有效减小子图中的张量形状规模。为了控制复杂度，MAGIS基于图结构分析构建了轻量级搜索空间。此外,MAGIS将图调度拆解为“图变换”和“重排序”两个环节，并设计增量调度算法，以降低每次图变换步骤后的调度开销，从而实现二者的高效协同。</p><h2 id="引言">引言</h2><p>DNN内存消耗增长主要可归因于两大核心因素</p><p>（1）存在大量长生命周期张量，例如模型参数、训练前向传播过程中的激活值以及复杂网络中的中间张量。<br>（2）存在具有超大形状规模的张量，例如为提升训练/推理效率而设置的大批次(batchsize)，语言模型中较长的序列长度以及图像相关模型中超高的分辨率。</p><p>模型参数：<br>生命周期贯穿整个训练过程（从训练开始加载，到训练结束保存），是永久占用型张量。BERT-large为例，其3.4亿参数在单精度下占用约3.4亿*4B≈ 13.6GB显存，若使用混合精度训练（FP16）则可降至约6.8B，但仍然需要占用大量固定内存。推理时参数无需更新，但仍然需要全量加载，是边缘设备部署模型的核心障碍。</p><p>训练前向传播激活值：<br>激活值是前向传播中每层算子的输出，其生命周期需延续至反向传播结束。对于深度模型，前向传播会生成大量的激活值的暂存，那么内存峰值出现在反向传播之前。对于12层的BERT模型，激活值的内存占用甚至会超过模型本身</p><p>复杂网络中间张量：<br>结构复杂的模型如（多分支CNN、Transformer的encoder-decoder结构），这种张量是“非必要但不可避免”的临时结果。例如Transformer的多头注意力层，会生成Q、K、V三个中间张量，若未及时优化，这些张量会暂存至后续步骤结束，额外占用内存。</p><h3 id="优化价值">优化价值</h3><p>GPU：支持运行更大规模的DNN模型、实现多任务内存共置、减少分布式训练中的跨卡通信。</p><p>CPU：让DNN模型能够在移动端部署，同时避免占用过多的后台内存。</p><h3 id="图调度">图调度</h3><p>图调度是一种广泛应用于深度神经网络的内存优化技术，主要包括重计算、换入换出和重排序。核心思路是：通过调度每个算子/张量何时计算、何时换出从而减少驻留在内存中的张量峰值数量。</p><h3 id="图变换">图变换</h3><p>图变换是一种基于计算图等价变换的优化技术，大致可分为两类：</p><p>（1）聚合变换（Aggregation Transformation 简称A-Trans）：通过将多个小算子聚合为一个大算子，提升硬件利用率以优化性能，代价是暂时增加内存占用。</p><p>（2）中间变换（Interim Transformation 简称I-Trans）：利用代数等价性，为其他图变换创造机会。</p><p>作者发现一种新的中间变换–分裂变换（Split Transformation 简称S-Trans），它可以将一个大算子分裂为多个小算子，从而减少中间张量的形状规模，在降低硬件利用率的代价下有效减少内存占用。</p><h3 id="核心挑战">核心挑战</h3><p>（1）F-Trans带来的复杂度问题：一方面F-Trans会导致计算图规模急速增长，这会阻碍后续优化，另一方面F-Trans本身的搜索空间极为庞大，因为几乎可应用与计算图中的所有子图</p><p>（2）图变换与图调度的关联性问题: 图变换设计内存与性能之间的权衡（如A-Trans与S-Trans），而图调度则关注计算与内存的平衡。这使得图变换与图调度的协调变得至关重要，以实现最优的内存优化效果。</p><h4 id="第一个挑战">第一个挑战</h4><p>为了应对第一个挑战，作者提出了MAGIS，一个通过协调图变换与图调度的DNN内存优化框架。</p><p>针对F-Trans的复杂度问题，提出了分裂层次树（Fission Hierarchy Tree），用于表示F-Trans后的计算图结构，并且无需将计算图实际转换为复杂结构。</p><p>这种设计在一定程度上限制了搜索空间，但它显著降低了优化复杂度，使后续的变换与调度更易搜索到更优解。</p><p>此外作者提出了解析方法（analytic methods）,用于筛选适合F-Trans的子图，从而构建轻量级FTree。</p><h4 id="第二个挑战">第二个挑战</h4><p>为了应对第二个挑战，作者的核心目标是降低每次图变换步骤后图调度的复杂度</p><p>（1）将<strong>重计算</strong>与<strong>换入换出</strong>这两种调度技术拆解为<strong>图变换</strong>与<strong>重排序</strong>两个环节。<br>其中重计算与换入换出是以性能换内存的关键调度技术，而重排序是“无性能损耗的内存优化”调度方法。<br>这样的处理使得<strong>内存-性能权衡</strong>完全转移到图变换阶段，调度阶段仅需要关注重排序以实现内存优化。</p><p>（2）设计增量调度算法，以降低每次图变换步骤后的图调度复杂度。</p><h3 id="作者的贡献">作者的贡献</h3><p>（1）设计并实现了MAGIS，一个通过协调图变换与图调度的DNN内存优化框架。<br>（2）将图裂变变换形式化，基于层次树对其进行表示，并通过图分析缩减其搜索空间。<br>（3）提出了能高效协同图变换与图调度的增量调度算法，以降低每次图变换步骤后的图调度复杂度。</p><p>作者实验表明：MAGIS 能将原始峰值内存优化至 15%到50%，且延迟开销不超过 10%；与最先进方法相比，在相同延迟约束下，MAGIS 可将峰值内存进一步优化至这些方法的 15%到85%；在相同内存约束下，MAGIS 的速度比它们快 1.25 倍，在 “内存 - 延迟” 双目标优化中实现了更优的帕累托边界（Pareto boundary）。</p><h2 id="动机">动机</h2><p>合理的图变换同样能提升计算图的内存利用效率，通过拆分算子，可以在<strong>增加算子调用次数，降低硬件利用率</strong>的代价下，减少峰值内存占用。借助图变换，深度神经网络的内存优化效果能得到显著增强。</p><p>图 2 (a) 展示了一种在 DNN 训练或 “含长跳跃连接（long skip-connections）的 DNN”[23, 44, 73, 75] 中常见的简化图结构。该结构的峰值内存占用为 1056（单位可理解为 “数据类型字节数归一化后的张量大小”）—— 这是因为在计算第 33 个算子时，有 33 个大小为 32 的张量同时处于 “存活状态”，远超 100 的内存限制。</p><p>在图 2 (b) 中，尽管仅通过图调度（将暂时不用的张量换入外部存储）可将内存占用控制在 100，但数据传输过程会导致显著的延迟增加。</p><p>然而，如图 2 (d) 所示，当引入图变换后，不仅能节省更多内存，还可通过 “异步换入换出（asynchronous swapping）” 隐藏数据传输延迟。在此场景下，尽管硬件利用率有所下降，但延迟损失可通过异步换入换出带来的效率提升得到补偿。</p><p>作者将上述的变换命名为分裂变换，它是聚合变换的对偶形式，通过拆分算子有效优化内存占用。</p><p>但是现有基于“规则的子图替换”的图变换方法无法直接用于F-Trans，主要原因有：</p><p>（1）F-Trans会导致计算图规模急速增长，这会阻碍后续优化。<br>（2）F-Trans本身的搜索空间极为庞大，因为几乎可应用与计算图中的所有子图。</p><p>此外将图变换与图调度相协同，对于通过图变换实现内存优化至关重要。<br>（1）过细粒度的算子拆分，会导致高昂的性能代价<br>（2）将图调度与图变换性能，共同平衡各自的内存-性能权衡，不仅能降低内存占用，而且实现更短的延迟。</p><h2 id="系统框架">系统框架</h2><h3 id="m-state">M-State</h3><p>存储优化过程中的所有状态信息，包括计算图、分裂层次树和最优调度方案，以及模拟与硬件profiling结果，其中F-Tree用于表示分裂变换的层次化搜索空间。</p><p>当节点标记为 n = 1时，代表该节点对应“可进行F-Trans的潜在子图与维度候选”<br>当节点标记为 n &gt; 1时，代表该节点对应“已通过F-Trans沿某一维度拆分为n个部分的子图”</p><h3 id="m-analyzer">M-Analyzer</h3><p>通过根据计算图构建分裂层次树，生成分裂变换的搜索空间</p><h3 id="m-optimizer">M-Optimizer</h3><p>协调图变换与图调度，实现延迟与内存的联合优化</p><h3 id="m-rules">M-Rules</h3><p>为M-Optimizer提供各类变换规则</p><p>（1）现有研究中使用的TASO规则<br>（2）F-Tree突变规则（用于操作 F-Tree，以反映 F-Trans 在计算图上的实际应用）<br>（3）“基于调度的规则”（由图调度技术拆解而来，如重计算、换入换出对应的变换规则）</p><h2 id="m-analyzer">M-Analyzer</h2><p>本节首先介绍维度图（D-Graph），并基于它定义分裂变换（F-Trans）。随后定义F-Tree（分裂层次树）作为F-Trans优化空间/状态的抽象表示，并给出一种轻量级F-Tree构建算法，该算法仅针对基于支配树和内存热点筛选出的子图考虑F-Trans</p><h3 id="维度图">维度图</h3><p>F-Trans的本质是沿着子图的某一个维度，拆分该子图，因此提出维度图(D-Graph来识别计算图中的图级维度)</p><p>给定计算图G，其中算子\v \in V(G)\的输出张量包含\s_v\个维度，其计算过程涉及\r_v\个归约轴（reduce-axes）。基于此，我们定义维度图\D = D(G)\如下：<br>（1）节点定义：对于每个算子(v \in V(G))，以及索引(i = -r_v, \dots, -2, -1, 1, 2, \dots, s_v)，存在节点(\langle v, i \rangle \in V(D))。（注：正索引(1,2,\dots,s_v)对应输出张量的维度；负索引(-1,-2,\dots,-r_v)对应计算过程中的归约轴）</p><p>（2）边定义：若u的第i个维度与v的第j个维度对应同一空间轴（spatial-axis），则维度图中存在边((\langle u, i \rangle, \langle v, j \rangle) \in E(D))；若u的第i个维度对应v计算过程中的第j个归约轴，则维度图中存在边((\langle u, i \rangle, \langle v, -j \rangle) \in E(D))。</p><p>示例：<br><img src="image-1.png" alt="alt text"></p><h3 id="f-trans">F-Trans</h3><p>计算图G的分裂变换F-Trans定义为三元组f = (S,D,n)其中：<br>（1）S⊆V(G)，待拆分的子图算子集合<br>（2）D：维度图，用于指定子图G[S]的拆分维度<br>（3）n∈N，代表F-Trans将S中的算子沿D中的维度拆分为n个部分</p><p>F-Trans 需满足以下三大约束条件（确保拆分后计算结果与原图等价，且无逻辑冲突）：<br>（1）弱连通性（Weakly Connected）：子图G[S]是弱连通的。（注：弱连通指忽略边的方向后，子图内所有算子通过依赖关系连成一个整体，无孤立算子）；</p><p>（2）凸性（Convex）：子图(G[S])满足凸性，即(G.\text{inps}(S) ∩ \bigcup_{v∈G.\text{outs}(S)} G.\text{des}(v) = ∅)。（注：(G.\text{inps}(S))是子图S的外部输入张量，(\bigcup G.\text{des}(v))是子图S输出张量的所有后代算子；该约束意为 “子图的外部输入张量不会被子图输出的后代算子使用”，避免拆分后输入张量被提前释放）；</p><p>（3）无冗余计算（No Redundant Computation）：拆分后的图无冗余计算，需满足两个条件：对所有(v ∈ S)，存在唯一整数i，使得(\langle v, i \rangle ∈ V(D))（即每个待拆分算子仅沿D指定的一个维度拆分，避免多维度拆分导致的冗余）；对所有((u, v) ∈ E(G[S]))（子图内的算子依赖边），存在整数(i, j)，使得(\langle u, i \rangle, \langle v, j \rangle ∈ E(D))（即子图内算子的依赖关系在维度图中存在对应边，确保拆分后依赖链不中断）。</p><p>给定计算图G的F-Trans f = (S,D,n),拆分后的结果图包含n个子图G[s]的拆分部分，对于拆分部分的输入与输出，需按以下规则处理：</p><p>（1）输入张量处理：对于任意的u∈G.input(S)(子图S的外部输入)<br>1.若存在正整数i使得(\langle u, i \rangle ∈ V(D))（即u需沿D指定的维度拆分），则u会被 “切片（sliced）” 为(𝑛)份，每个拆分部分使用其中一份；</p><p>2.若不存在上述i（即u无需拆分，如模型权重），则u被所有拆分部分共享</p><p>（2）输出张量处理：对于任意的v∈G.output(S)(子图S的外部输出)<br>1.若存在负整数i使得(\langle v, i \rangle ∈ V(D))（即v需沿D指定的维度拆分），则v会被 “合并（merged）” 所有拆分部分的对应输出得到。<br>2.若不存在上述i（即v是归约结果，如梯度），则v通过归约所有拆分部分的输出得到（如求和、求平均)</p><h3 id="分裂层次树">分裂层次树</h3><p>直接将分裂变换应用于计算图会显著增加图的复杂度，尤其是当分裂数量n较大时。由于每次F-Trans会将图拆分为若干个同构子图，所以只需要保存其中一个子图即可。</p><p>为此不直接修改原始计算图，而是构建分裂层次树(Fission Hierarchy Tree)，F-Tree中的每个树节点记录一个F-Trans三元组（S,D,N），对于任意树节点f = (S,D,N)及其父节点f’ = （S’,D’,n’）满足S⊆ 𝑆′（即子节点的待拆分算子集合是父节点集合的子集）</p><p>图 3 展示了一个 F-Tree 实例：左侧计算图中每个虚线框包围的子图对应 F-Tree 的一个节点，节点旁的𝑛值为分裂数量。当𝑛 = 1 时，该节点表示 “可进行分裂的候选子图”；当𝑛 &gt; 1 时，该节点表示 “已通过 F-Trans 拆分为𝑛个部分的子图”。</p><p>然而，计算图𝐺上 F-Trans 的搜索空间仍然很大 —— 由于几乎所有凸子图都可作为分裂候选，搜索空间规模可达𝑂(2^|V (G)|²)。事实上，随意应用 F-Trans 并不能保证峰值内存降低，只有当 F-Trans 针对包含内存热点（memory hot-spots）的子图时（§2.1），才能实现有效的内存节省。</p><h4 id="内存热点分析">内存热点分析</h4><p>对于计算图G的分裂变换F-Trans f = (S,D,n),设内存热点为H,子图S的外部输入为I = G.inps(S)。</p><p>M0和Mf分别表示F-Trans前后的峰值内存使用量。由于执行拆分后的子图时，输入I需驻留内存，Mf应将I中所有张量的大小v∈I |v|求和考虑在内，与S之外的内存热点大小合并在一起。</p><p><img src="image-2.png" alt="alt text"></p><p>要是内存热点减少量更大，需要满足至少两个条件：S包含更多的内存热点，且I的内存消耗更小。</p><p>为了最小化F-Trans的输入内存占用，可以选择一个节点，并将其支配的子图作为分裂候选，确保该子图仅有一个入口节点。</p><h4 id="内存热度">内存热度</h4><p>表示一个节点支配的子图中所有热点的总大小，给定计算图G及其支配树T = T(G)，以及内存热点H，节点v的支配热度定义为：H∩T.des(v)是被V支配的内存热点<br>heat(v) = w∈H∩T.des(v) |w|求和。</p><p>在此基础上，为每个节点v分配一个评分（Score），用于估计对v支配的子图应用F-Trans后的潜在内存峰值减少量–第一项是内存热点的减少量，第二项是F-Trans后每个拆分部分执行时需驻留的输入节点大小，通常设n=2，以确保将子图拆分为两部分也能产生收益。</p><p>score(v) = (1-1/n)heat(v) - u∈G.inps（T.des(v)）\H |u|求和。</p><h3 id="构建f-tree算法">构建F-Tree算法</h3><p>核心思想：将具有不同评分的节点划分到不同区间–评分越高，意味着F-Trans的峰值内存减少量越大，但可能伴随着更大的延迟开销。超参数L控制区间数量和F-Tree的最大层级</p><p>该算法输入计算图G和最大层级L，具体步骤如下：</p><p>（1）迭代维度的D（G）的联通分量。<br>（2）提取子图G’及其支配树T。<br>（3）计算节点评分<br>（4）得到最大评分Smax之后，将区间[0,1]等分为L个区间，每个区间的宽度为1/L。<br>（5）根据归一化分配s[v]/Smax，在不同区间中选择节点<br>（6）从这些节点支配的子图中生成分裂候选<br>（7）最终基于这些子图构建F-Tree</p><h2 id="m-rules">M-Rules</h2><p>由算法构建的初始F-Tree中，所有树节点f = (S,D,n)的n值均为1，这类节点被称作未激活节点。</p><p>其对应的子图尚未执行F-Trans；n&gt;1的节点称为已激活节点，表示其对应的子图已执行F-Trans，并拆分为n个部分。</p><h3 id="裂变规则">裂变规则</h3><p>F-Tree突变规则的核心作用是修改F-Tree节点的n值，从而间接在计算图上应用F-Trans。这类规则有四：<br>（1）激活规则：激活F-Tree中未激活的节点或“无已激活祖先的已激活节点的父节点”<br>（2）提升规则：禁用“无已激活祖先的已激活节点”，并激活其对应的父节点。<br>（3）禁用规则：禁用“无已激活后代节点的已激活节点”<br>（4）突变规则：将已激活节点的分裂数量n增大到“能整除对应维度长度的下一个数值”</p><p>借助M-Analyzer与上述规则，可以将F-Trans解耦为“优化前阶段的F-Tree构建”与“优化中阶段的F-Tree突变”，两大环节。优化过程会优先激活叶节点，再逐步向靠近根节点的方向靠近。</p><p>这是因为对靠近根节点的节点应用分裂，会对内存与延迟产生更大影响；而从叶节点开始操作，能实现更小的突变步长与更平滑的搜索过程。</p><h3 id="调度规则">调度规则</h3><p>额外引入两个算子，存储(Store)和加载（Load），表示图调度的换入换出行为。</p><p>（1）重计算规则：将算子A的多个消费者之一B分离出来，使其使用重计算的算子A’（即重新执行A生成结果供B使用。<br>（2）去重计算规则：重计算规则的逆操作，将两个同类型、同输入的算子A和A’合并为单个算子。<br>（3）换入换出规则：在算子A与其消费者B之间插入Store和Load算子，表示A的输出先被换出到外部存储，待B需要时再换入。<br>（4）去换入换出规则：换入换出规则的逆操作，移除两个算子之间的Store和Load算子。</p><p>借助上述规则，图调度可拆解为图变换和重排序两个环节</p><p>（1）变换阶段：决定哪些算子需要重计算/换入换出；<br>（2）重排序阶段：决定何时执行换入换出算子，以最小化内存峰值。</p><p>由此，内存与延迟的权衡决策可转移至图变换阶段，而图调度阶段仅需处理 “重排序”（通常不影响总执行延迟）。这种拆解使 “每次图变换后的调度工作” 大幅简化。<br>启发式策略：由于重计算规则和换入换出规则几乎可应用于任何算子，可能导致搜索空间过大、优化速度减慢。因此，在实际子图模式匹配过程中，可选择性应用这两类规则，过滤掉 “不包含内存热点的子图”。</p><h2 id="m-optimizer">M-Optimizer</h2><p>包含增量调度–利用突变子图的信息和先前的调度结果，为变换后的图生成最优调度<br>顶层搜索算法–基于内存和延迟对M状态，进行优先级排序，并利用M-Rules对当前最优的M状态进行变换，以生成新的M状态。</p><h3 id="增量调度">增量调度</h3><p>要获取计算图的内存占用与性能数据，需执行图调度。然而每次图变换都进行全量图调度开销极高，为解决这一个问题，作者设计了增量调度算法–基于先前的调度结果与上一次图变换影响的子图范围，确定需重新调度的图子集。</p><p>（1）通过GetRescheduleInterval函数，获取原始图中需重新调度的算子序列。<br>（2）在新图中，为该算子序列找到对应的子图Snew。<br>（3）调用GraphPartition函数，将Snew划分为多个可独立调度的子图<br>（4）采用现有研究中基于动态规划的算法，对每个子图执行调度。<br>（5）合并各子图的调度结果，形成新图的完整调度，并于原始图的调度结果整合。</p><p>GetRescheduleInterval是算法2的核心步骤，其目标是“找到原始调度中需要重新调度的区间”该区间的选择需平衡优化质量与时间成本。</p><p>（1）区间过小：导致重新调度的结构次优甚至错误<br>（2）区间过大：会增加重新调度的时间开销，失去增量的意义。</p><p>为解决这一问题，作者引入节点的窄腰值，对于计算图G的节点v∈V(G)，其窄腰值定义为：</p><p>(\text{nw}(v) = |V(G)| - |G.\text{anc}(v)| - |G.\text{des}(v)| - 1)</p><p>窄腰值的核心作用是衡量与给定节点v无关的节点数量</p><p>（1）nw(v)越低：说明依赖v的节点和v依赖的节点越多，v是拓扑排序问题中合适分割点。<br>（2）分割逻辑：所有依赖v的节点需在v之后调度，所有v依赖的节点需在v之前调度 —— 这为调度问题提供了 “天然划分”，确保分割后的子图可独立优化；<br>(3) 优化质量保证：若分别对v的祖先和v的后代找到最优调度，最终峰值内存可保证不超过(M_{\text{opt}} + \sum_{v \in V(G) \setminus G.\text{anc}(v) \setminus G.\text{des}(v)} |v|)<br>(4)完全独立条件：若nw(v) = 0,则计算图的调度问题可在v处·拆分为两个完全独立的子问题，子图调度结果互不影响。</p><p>作者基于窄腰值设计了启发式算法，用于选择边界窄腰值尽可能小的调度区间。其中常数20、10、4是实际场景中验证有效的经验超参数。</p><p>GraphPartition函数的核心思路是：以nw(v)≤1的节点作为分割点，将给定途中的每个联通分量划分为多个可独立调度的子图。</p><h3 id="顶层搜索算法">顶层搜索算法</h3><p>MAGIS采用贪心搜索算法，对计算图进行优化，支持两种优化模式</p><p>（1）给定内存限制，优化延迟<br>（2）给定延迟限制，优化内存</p><p>第一种搜索流程的输入包括：计算图G、给定的内存限制M、F-Tree最大层级L，具体步骤如下：</p><p>（1）对输入图执行调度与分析，生成初始M-State<br>（2）构建用于存储M-State的优先级队列，队列优先级由BetterThan函数决定：<br>-若两个M-State均满足内存限制M，则优先比较延迟<br>-若不满足内存限制，则优先比较内存</p><ul><li>注：比较采用字典序（lexicographical order），即((a, b) &lt; (c, d))表示 “若(a &lt; c)，则整体 更小；若(a = c)，则比较(b &lt; d)”（(a/c)为延迟，(b/d)为内存）。</li></ul><p>（3）迭代执行以下步骤：</p><ol><li>从优先级队列中弹出当前最优的M-State μ</li><li>调用Analyze函数，若μ中先前的突变子图未受F-Trans影响，则更新μ中的F-Tree</li><li>应用M-Rules，生成一系列新的M-State μ’</li><li>对新生成的μ’执行增量调度，评估其延迟与内存。</li><li>若μ’在放松条件下不劣于当前最优状态μbest，则将μ’加入游侠牛队列。</li></ol><p>避免冗余搜索：借鉴魏斯费勒 - 莱曼测试（Weisfeiler-Lehman Test） [48] 的思想，对计算图进行哈希（第 5-8 行、第 12-14 行），其中 “⊕” 表示字节拼接操作（将图结构与状态信息拼接生成唯一哈希值），相同哈希的 M-State 视为 “结构重复”，不重复入队；</p><p>性能测量优化：为降低性能测量开销，实现带有 “算子性能缓存” 的模拟器 —— 该缓存保存算子的实际执行延迟，模拟器通过调度信息计算全图的整体性能（延迟）与内存占用。</p><p>需特别说明：当考虑异步换入换出（asynchronous swapping） 时，涉及 Store/Load 算子的重排序会对延迟产生轻微影响。为应对这一问题，我们的重排序策略是：尽可能早地放置 Store 算子（尽早释放内存），同时尽可能晚地放置 Load 算子（确保数据传输延迟刚好被隐藏）。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存优化 </tag>
            
            <tag> 图调度 </tag>
            
            <tag> 图优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133克隆图</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/133%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>133克隆图</h1><h2 id="题目描述">题目描述</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。<br>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><p>class Node{<br>int val;<br>List<Node> neighbors;<br>}</p><h2 id="测试用例格式">测试用例格式</h2><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（val = 1），第二个节点值为2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。<br>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为1）。你必须返回给定节点的拷贝作为对克隆图的引用。</p><h2 id="解题思路">解题思路</h2><p>要解决无向连通图的深拷贝问题，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。</p><p>核心思路是创建每个节点的副本，并正确复制节点之间的连接关系</p><h3 id="核心思路">核心思路</h3><p>（1）使用DFS遍历图的每个节点<br>（2）使用哈希表map存储每个节点的原值和复制值，避免重复复制<br>（3）递归地复制每个节点的邻居</p><h3 id="实现步骤">实现步骤</h3><p>（1）首先处理空节点的情况<br>（2）在哈希表中寻找目标节点，若有则直接返回其复制值<br>（3）若没有则先复制当前节点，将其存储到哈希表中<br>（4）递归地复制当前节点的邻居</p><h3 id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(node)!=map.<span class="built_in">end</span>()) <span class="keyword">return</span> map[node];</span><br><span class="line">        Node* clone=<span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        map[node]=clone;</span><br><span class="line">        <span class="keyword">for</span>(Node* n:node-&gt;neighbors)&#123;</span><br><span class="line">            clone-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><p>时间复杂度：O(N)，其中 N 是图中节点的数量。每个节点只会被访问一次。<br>空间复杂度：O(N)，其中 N 是图中节点的数量。哈希表和递归栈的空间复杂度均为 O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134加油站</title>
      <link href="/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2025/09/09/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/134%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1>134加油站</h1><h2 id="题目描述">题目描述</h2><p>在一条环路上有n个加油站，其中第i个加油站有汽油gas[i]升。<br>假设你有一辆容量无限的汽车，从第i个加油站开往第i+1个加油站需要消耗汽油cost[i]升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组gas和cost，如果你可以按顺序环绕环路行驶一周，则返回出发时加油站的编号，否则返回-1。</p><p>如果存在解，保证他是唯一的。</p><h2 id="题目分析">题目分析</h2><p>（1）注意到若总花费大于总油量，则一定不存在解。<br>（2）存在线性解法寻找具体的起始点：<br>a.从第一个起始点开始，逐渐累积油量，若油量小于0，则从下一个加油站开始。<br>b.重置当前油量<br>c.遍历结束时，当前的起始点即为解。</p><h2 id="有效性分析">有效性分析</h2><p>（1）为什么要从下一个加油站开始？<br>（2）若从第i个加油站开始，到第j个加油站油量小于0，则从第i+1个加油站开始到第j个加油站油量也一定小于0。<br>（3）因为这过程中存在这油量累积现象。</p><h2 id="代码思路">代码思路</h2><p>（1）初始化总油量，当前油量和起始点为0<br>（2）遍历每一个加油站，更新总油量，当前油量。<br>（3）若当前油量小于0，<br>a.更新起始点为下一个加油站<br>b.重置当前油量<br>（4）遍历结束后，判断总油量是否大于等于0，若大于等于0，则返回起始点，否则返回-1。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    pubilc:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas,vector&lt;<span class="type">int</span>&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> totalRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> currentRank = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                totalRank+=gas[i]-cost[i];</span><br><span class="line">                currentRank+=gas[i]-cost[i];</span><br><span class="line">                <span class="keyword">if</span>(currentRank&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    start = i<span class="number">+1</span>;</span><br><span class="line">                    currentRank = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalRank&gt;=<span class="number">0</span>?start:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>时间复杂度：O(n)，遍历所有的加油站一次<br>空间复杂度：O(1)，只使用了常数个变量</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/09/hello-world/"/>
      <url>/2025/09/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂QKV</title>
      <link href="/2023/08/22/transformer/QKV/"/>
      <url>/2023/08/22/transformer/QKV/</url>
      
        <content type="html"><![CDATA[<h1>QKV：Transformer注意力机制的核心范式</h1><h2 id="qkv的起源与本质">QKV的起源与本质</h2><p>QKV（Query-Key-Value，查询-键-值）并非独立存在的结构，而是Transformer模型为实现<strong>结构化注意力交互</strong>而设计的核心组件。其本质是对Transformer输入向量（词嵌入与位置编码的融合表示）进行三次独立线性变换，从而将输入的单一语义表征拆分为三种功能差异化的向量，为后续注意力权重的计算与信息聚合提供范式支撑。</p><h2 id="qkv的前置输入：transformer的基础表征">QKV的前置输入：Transformer的基础表征</h2><p>Transformer处理的是固定长度的离散序列（如文本中的词汇、图像中的patch），需先将序列元素转化为连续的高维向量，该过程由<strong>词嵌入</strong>与<strong>位置编码</strong>两步完成，最终形成QKV的生成基础——输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>。</p><h3 id="词嵌入-word-embedding">词嵌入（Word Embedding）</h3><p>词嵌入的核心作用是将离散的符号化Token（如文本中的单词“apple”）映射至连续的低维实数向量空间，生成具有语义区分度的表征。其数学定义为：设序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，模型维度（即嵌入向量维度）为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则词嵌入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>V</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">E \in \mathbb{R}^{V \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>为词汇表大小）通过查表操作与Token的独热编码（One-Hot Encoding）相乘，得到词嵌入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>m</mi><mi>b</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Emb \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。<br>该向量不仅能捕捉Token的固有语义（如“苹果”与“水果”的语义关联性），还可通过预训练（如Word2Vec、BERT预训练嵌入）引入通用语言知识，为后续QKV的语义交互奠定基础。</p><h3 id="位置编码-positional-encoding">位置编码（Positional Encoding）</h3><p>由于Transformer无循环或卷积结构，无法天然捕捉序列的时序/位置信息，因此需通过<strong>位置编码</strong>将位置特征注入词嵌入。位置编码需满足两个核心性质：1）不同位置对应不同编码向量；2）位置编码的差值仅与Token间的相对距离相关（平移不变性）。<br>常见的位置编码实现包括<strong>正弦-余弦编码</strong>与<strong>可学习位置编码</strong>：</p><ul><li>正弦-余弦编码（固定式）：对第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>个位置、第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>维的编码值，定义为：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>i</mi><mtext> 为偶数</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若 </mtext><mi>i</mi><mtext> 为奇数</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">PE_{pos,i} = \begin{cases} \sin\left(\frac{pos}{10000^{2i/d_{\text{model}}}}\right) &amp; \text{若} \ i \ 为偶数 \\\cos\left(\frac{pos}{10000^{2(i-1)/d_{\text{model}}}}\right) &amp; \text{若} \ i \ 为奇数 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.00501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.564755em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932071428571429em;"><span style="top:-2.893207142857143em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43524499999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.564755em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8932071428571429em;"><span style="top:-2.893207142857143em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43524499999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace"> </span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">偶</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">若</span></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace"> </span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">奇</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>该编码无需训练，可直接生成与词嵌入同维度的位置编码矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">PE \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>。</li><li>可学习位置编码（参数化）：通过训练一个可学习矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mi>θ</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">PE_{\theta} \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，使模型自主学习适配任务的位置特征。</li></ul><h3 id="最终输入向量x">最终输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></h3><p>词嵌入与位置编码通过元素级加法融合，形成Transformer的基础输入向量：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>E</mi><mi>m</mi><mi>b</mi><mo>+</mo><mi>P</mi><mi>E</mi><mo separator="true">,</mo><mspace width="1em"/><mi>X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup></mrow><annotation encoding="application/x-tex">X = Emb + PE, \quad X \in \mathbb{R}^{L \times d_{\text{model}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>该向量同时包含Token的语义信息与位置信息，是QKV生成的唯一数据源。</p><h2 id="qkv的生成：线性变换与功能分化">QKV的生成：线性变换与功能分化</h2><p>输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>通过三个独立的<strong>线性变换层</strong>（无非线性激活函数）生成Q、K、V，三者的维度设计与参数学习均服务于注意力机制的“查询-匹配-聚合”逻辑。</p><h3 id="核心定义与数学表达">核心定义与数学表达</h3><p>设注意力头数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>（多头注意力的基础参数），为使每头注意力的计算复杂度可控，通常令Q与K的维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mtext>model</mtext></msub><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">d_k = \frac{d_{\text{model}}}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2469679999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9019679999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，V的维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>v</mi></msub><mo>=</mo><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_v = d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（简化后续矩阵运算）。三个线性变换的数学表达如下：</p><table><thead><tr><th>向量类型</th><th>计算公式</th><th>参数矩阵</th><th>输出维度</th><th>核心功能</th></tr></thead><tbody><tr><td>Query（Q）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">Q = X \cdot W_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_q \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">Q \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“查询方”，引导注意力聚焦方向</td></tr><tr><td>Key（K）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">K = X \cdot W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_k \in \mathbb{R}^{d_{\text{model}} \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K \in \mathbb{R}^{L \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“匹配方”，提供语义匹配特征</td></tr><tr><td>Value（V）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>X</mi><mo>⋅</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">V = X \cdot W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>v</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">W_v \in \mathbb{R}^{d_{\text{model}} \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>L</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V \in \mathbb{R}^{L \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td>作为“信息方”，承载待聚合的语义信息</td></tr></tbody></table><h3 id="关键特性">关键特性</h3><ul><li><strong>参数独立性</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_q, W_k, W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为三个完全独立的可学习参数矩阵，模型可通过训练自主优化三者的语义表征，实现Q的“查询能力”、K的“匹配能力”与V的“信息传递能力”的差异化优化。</li><li><strong>维度一致性</strong>：Q与K的维度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，确保二者可通过点积计算相似度；V的维度与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一致，简化注意力输出与后续层的维度衔接。</li></ul><h2 id="qkv的作用：注意力机制的完整流程">QKV的作用：注意力机制的完整流程</h2><p>QKV的核心价值在于支撑<strong>缩放点积注意力（Scaled Dot-Product Attention）</strong> 的计算，该过程可分为“分数计算-缩放-掩码-权重分配与信息聚合”四步，最终输出融合全局上下文的注意力向量。</p><h3 id="步骤1：注意力分数计算-query与key的匹配">步骤1：注意力分数计算（Query与Key的匹配）</h3><p>注意力分数衡量“每个Query与每个Key的语义相关度”，通过Q与K的转置矩阵点积实现。设查询序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">L_q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>、键序列长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">L_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（自注意力中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>=</mo><msub><mi>L</mi><mi>k</mi></msub><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L_q = L_k = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），则分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>L</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">S \in \mathbb{R}^{L_q \times L_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.841331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.841331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>的计算式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">S = Q \cdot K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>矩阵中元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个Query（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">Q_i \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）与第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个Key（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>j</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">K_j \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）的语义匹配度，值越大表示二者关联越强。</p><h3 id="步骤2：注意力缩放-缓解梯度饱和">步骤2：注意力缩放（缓解梯度饱和）</h3><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>较大时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">Q \cdot K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的元素值会随<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>增大而显著增大（若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>的元素服从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{N}(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>分布，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的方差为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）。过大的输入会导致softmax函数进入<strong>梯度饱和区</strong>（输出趋近于0或1），梯度趋近于0，模型训练停滞。<br>为解决该问题，需对分数矩阵进行缩放，使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的方差归一化为1：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>scaled</mtext></msub><mo>=</mo><mfrac><mi>S</mi><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo>=</mo><mfrac><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">S_{\text{scaled}} = \frac{S}{\sqrt{d_k}} = \frac{Q \cdot K^T}{\sqrt{d_k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">scaled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29033em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="步骤3：掩码操作-约束注意力范围">步骤3：掩码操作（约束注意力范围）</h3><p>掩码（Mask）是可选但关键的步骤，用于屏蔽无效或需限制的注意力交互，常见类型包括：</p><ul><li><strong>因果掩码（Causal Mask）</strong>：主要用于Transformer解码器，通过将分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>scaled</mtext></msub></mrow><annotation encoding="application/x-tex">S_{\text{scaled}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">scaled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中“未来位置”的元素设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>，使当前Query无法关注后续Token（如文本生成中避免“偷看”未来词）。</li><li><strong>填充掩码（Padding Mask）</strong>：用于屏蔽序列中的无效填充Token（如为统一序列长度而添加的“[PAD]”），通过将填充位置对应的分数设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>，避免模型对无意义信息分配注意力。</li></ul><h3 id="步骤4：softmax归一化与信息聚合">步骤4：Softmax归一化与信息聚合</h3><ol><li><strong>权重归一化</strong>：对掩码后的分数矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mtext>masked</mtext></msub></mrow><annotation encoding="application/x-tex">S_{\text{masked}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应用softmax函数，将分数转化为求和为1的注意力权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>L</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">A \in \mathbb{R}^{L_q \times L_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.841331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.841331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，表示每个Key对Query的贡献占比：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mtext>Softmax</mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mtext>masked</mtext></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"/><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mtext>masked</mtext><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>L</mi><mi>k</mi></msub></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mtext>masked</mtext><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">A = \text{Softmax}(S_{\text{masked}}), \quad A_{i,j} = \frac{\exp(S_{\text{masked},i,j})}{\sum_{t=1}^{L_k} \exp(S_{\text{masked},i,t})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord">Softmax</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.597941em;vertical-align:-1.170941em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">masked</span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.170941em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><strong>信息聚合</strong>：将注意力权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>与Value矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>（设长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">L_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，自注意力中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>v</mi></msub><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L_v = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>）相乘，得到最终的注意力输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>L</mi><mi>q</mi></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">O \in \mathbb{R}^{L_q \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，每个Query对应一个融合全局相关信息的向量：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mi>A</mi><mo>⋅</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">O = A \cdot V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></span></p>该过程实现了“按语义相关性加权聚合信息”的核心目标，是Transformer捕捉全局依赖的关键。</li></ol><h2 id="为什么需要qkv：从-单向量复用-到-三阶交互">为什么需要QKV：从“单向量复用”到“三阶交互”</h2><p>QKV的设计源于对早期注意力机制（如Bahdanau注意力、Luong注意力）的优化，核心是解决“单向量复用”范式的灵活性不足问题。</p><h3 id="早期注意力机制的局限">早期注意力机制的局限</h3><p>早期注意力采用“输入向量复用”模式，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>K</mi><mo>=</mo><mi>V</mi><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Q=K=V=X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>为输入向量），该模式存在两大缺陷：</p><ol><li><strong>功能耦合</strong>：同一向量需同时承担“查询引导”“匹配判断”“信息传递”三种功能，无法针对性优化某一环节的表征能力；</li><li><strong>场景受限</strong>：仅能建模输入自身的单一关联（如文本序列内部的依赖），无法适配跨模态（如文本-图像匹配）、跨序列（如编码器-解码器交互）等复杂任务——此类任务需“查询来自源模态/序列，键与值来自目标模态/序列”的灵活交互模式。</li></ol><h3 id="qkv的优势：三阶交互范式">QKV的优势：三阶交互范式</h3><p>QKV通过“分离式线性变换”构建<strong>查询-键-值三阶交互范式</strong>，实现三大突破：</p><ol><li><strong>功能解耦</strong>：Q专注于“what to look for”（需要什么信息），K专注于“what to match”（提供匹配特征），V专注于“what to provide”（传递有用信息），三者可通过独立参数优化适配不同功能需求；</li><li><strong>场景泛化</strong>：支持“Q与K/V来源分离”（如交叉注意力中Q来自解码器，K/V来自编码器），可直接应用于机器翻译、图文检索、语音识别等跨模态/跨序列任务；</li><li><strong>细粒度关联</strong>：通过独立优化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">W_q, W_k, W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，模型可捕捉更细粒度的语义关联（如Q侧重“动作”，K侧重“实体”，V侧重“属性”），提升表征的丰富性。</li></ol><h2 id="qkv对transformer的贡献：支撑全局依赖与并行计算">QKV对Transformer的贡献：支撑全局依赖与并行计算</h2><p>QKV是Transformer实现“全局依赖捕捉”与“并行化计算”两大核心能力的载体，其作用通过<strong>自注意力</strong>与<strong>交叉注意力</strong>两种模式体现。</p><h3 id="自注意力-self-attention-：捕捉序列内部全局依赖">自注意力（Self-Attention）：捕捉序列内部全局依赖</h3><p>自注意力中，Q、K、V均来源于<strong>同一输入序列</strong>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>q</mi></msub><mo separator="true">,</mo><mi>K</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>V</mi><mo>=</mo><mi>X</mi><msub><mi>W</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">Q=X W_q, K=X W_k, V=X W_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>为单一序列的输入向量），其贡献在于：</p><ol><li><strong>全局依赖捕捉</strong>：每个Token可直接与序列中所有其他Token计算注意力，无需像RNN那样按顺序迭代，突破了“局部依赖优先”的限制；</li><li><strong>并行化效率</strong>：注意力分数计算、权重归一化、信息聚合均为矩阵运算，可通过GPU并行加速，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（远低于RNN的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msubsup><mi>d</mi><mtext>model</mtext><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_{\text{model}}^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.2831079999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），显著提升长序列处理效率。</li></ol><h3 id="交叉注意力-cross-attention-：实现跨序列-模态信息交互">交叉注意力（Cross-Attention）：实现跨序列/模态信息交互</h3><p>交叉注意力中，Q与K/V来源于<strong>不同序列/模态</strong>（如机器翻译中，Q来自解码器当前步输出，K/V来自编码器的源文本序列），其贡献在于：</p><ol><li><strong>跨域语义对齐</strong>：建立源序列（如英文）与目标序列（如中文）的语义关联，是编码器-解码器架构实现翻译、摘要等任务的核心；</li><li><strong>模态融合</strong>：在跨模态任务中（如图文生成），Q来自文本序列（需生成的描述），K/V来自图像的patch序列，可实现“文本查询引导图像信息聚合”，生成与图像内容匹配的文本。</li></ol><h2 id="qkv的核心问题：复杂度与长序列挑战">QKV的核心问题：复杂度与长序列挑战</h2><p>尽管QKV是Transformer的核心，但随序列长度增长，其固有的计算特性会引发一系列问题，限制模型在长序列任务（如文档级NLP、高分辨率图像生成）中的应用。</p><h3 id="计算复杂度高：平方级增长瓶颈">计算复杂度高：平方级增长瓶颈</h3><p>QKV的时间复杂度与空间复杂度均随序列长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>呈<strong>平方级增长</strong>：</p><ul><li>时间复杂度：注意力分数计算（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）+ 权重-Value相乘（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），总复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><msub><mi>d</mi><mtext>model</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2 d_{\text{model}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（因<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub><mo>=</mo><mi>h</mi><msub><mi>d</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}} = h d_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）；</li><li>空间复杂度：需存储Q（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）、K（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）、V（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）及分数矩阵（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>），当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">L=10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>时，分数矩阵的元素数可达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，远超普通GPU的内存承载能力。</li></ul><h3 id="长距离稀释：注意力权重分散">长距离稀释：注意力权重分散</h3><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>增大时，softmax输出的注意力权重会<strong>均匀分散</strong>到大量Key上，导致“长距离且语义相关的Key”无法获得足够权重——该现象称为“长距离依赖稀释”。其本质是：注意力权重的分布熵随<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>增大而升高，单个Query的注意力被“无关Key”稀释，无法聚焦于核心信息。</p><h3 id="信息冗余：q-k-v表征相关性过高">信息冗余：Q-K-V表征相关性过高</h3><p>尽管Q、K、V由独立参数生成，但三者均源于同一输入向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>的线性变换，导致其语义表征存在<strong>高度相关性</strong>。这种冗余不仅增加了模型的参数总量（三个矩阵而非一个），还可能使模型对噪声特征过度拟合（如Q与K的相关性过高，导致匹配分数偏差），降低泛化能力。</p><h3 id="异常值敏感：匹配分数失衡">异常值敏感：匹配分数失衡</h3><p>Q与K的点积运算对<strong>异常值</strong>（如词嵌入初始化偏差、噪声导致的极大/极小元素）高度敏感：若K中某一向量存在异常值，其与所有Q的匹配分数会被异常放大，导致softmax权重向该K倾斜，模型过度关注无关信息，忽略核心语义。</p><h2 id="qkv问题的解决方案：从效率优化到表征增强">QKV问题的解决方案：从效率优化到表征增强</h2><p>针对QKV的上述问题，学界提出了一系列优化方案，可分为“计算复杂度优化”“长距离稀释缓解”“冗余与异常值处理”三类。</p><h3 id="降低计算复杂度：稀疏化与低秩近似">降低计算复杂度：稀疏化与低秩近似</h3><h4 id="稀疏注意力-sparse-attention">稀疏注意力（Sparse Attention）</h4><p>核心思路：<strong>限制Q与K的交互范围</strong>，将全量注意力（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>L</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）转化为稀疏交互，典型方案包括：</p><ul><li>局部稀疏注意力：每个Q仅与自身周围固定窗口内的K交互（如窗口大小为5，Q仅关注左右各2个K），复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mo>⋅</mo><mi>W</mi><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L \cdot W \cdot d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>为窗口大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>≪</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">W \ll L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），代表模型为Longformer；</li><li>全局稀疏注意力：通过规则或采样选取部分“关键K”与Q交互，如Reformer的LSH（Locality-Sensitive Hashing）注意力——将相似的Q-K映射至同一哈希桶，仅在桶内计算注意力，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>log</mi><mo>⁡</mo><mi>L</mi><mo>⋅</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L \log L \cdot d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul><h4 id="低秩近似-low-rank-approximation">低秩近似（Low-Rank Approximation）</h4><p>核心思路：假设KV矩阵具有<strong>低秩结构</strong>，通过矩阵分解或投影降低维度，典型方案包括：</p><ul><li>Linformer：对K、V分别施加线性投影（投影维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>≪</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">E \ll L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>），将K转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>E</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">K&#x27; \in \mathbb{R}^{E \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，V转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>E</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">V&#x27; \in \mathbb{R}^{E \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，注意力计算变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>⋅</mo><msup><mi>K</mi><mrow><mo mathvariant="normal">′</mo><mi>T</mi></mrow></msup><mo>⋅</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">Q \cdot K&#x27;^T \cdot V&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>E</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L E d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>；</li><li>Performer：将点积注意力转化为基于正交集函数的核注意力（如随机傅里叶特征映射），通过低秩近似模拟全量注意力效果，复杂度降至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><msub><mi>d</mi><mi>k</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(L d_k \log d_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ul><h3 id="缓解长距离稀释：强化远距离关联">缓解长距离稀释：强化远距离关联</h3><h4 id="相对位置编码-relative-positional-encoding">相对位置编码（Relative Positional Encoding）</h4><p>传统位置编码仅注入绝对位置信息，无法区分Q-K的相对距离。相对位置编码通过在注意力分数中引入<strong>Q-K相对距离向量</strong>，直接建模位置依赖，代表方案为Transformer-XL：<br>修正后的注意力分数为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>Q</mi><mi>i</mi></msub><mo>+</mo><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mi>K</mi><mi>j</mi><mi>T</mi></msubsup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">S_{i,j} = \frac{(Q_i + R_{i-j}) \cdot K_j^T}{\sqrt{d_k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5561030000000002em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.626103em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mi>j</mi></mrow></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">R_{i-j} \in \mathbb{R}^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>为Q的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个位置与K的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个位置的相对位置向量，模型可通过该向量为“远距离但语义相关的Q-K”分配更高权重。</p><h4 id="记忆机制-memory-mechanism">记忆机制（Memory Mechanism）</h4><p>核心思路：<strong>缓存历史序列的KV信息</strong>，使当前Q可与历史KV交互，突破固定序列长度限制，代表方案为Transformer-XL与Recurrent Transformer：</p><ul><li>Transformer-XL：将前一段序列的KV缓存为“记忆单元”（Memory Cache），当前段Q在计算注意力时，同时与当前KV和记忆KV交互，相当于“记住”了更早的序列信息；</li><li>Recurrent Transformer：将KV缓存设计为循环门控单元（如LSTM的门控机制），动态更新记忆内容，优先保留长距离关键信息。</li></ul><h4 id="核函数注意力-kernel-attention">核函数注意力（Kernel Attention）</h4><p>通过将点积注意力替换为<strong>非线性核函数</strong>，增强对远距离Q-K语义关联的捕捉能力，典型核函数为径向基函数（RBF）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><msub><mi>Q</mi><mi>i</mi></msub><mo>−</mo><msub><mi>K</mi><mi>j</mi></msub><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">S_{i,j} = \exp\left(-\frac{\|Q_i - K_j\|^2}{2\sigma^2}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.441138em;vertical-align:-0.95003em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911079999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∥</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>为可学习的核宽度参数。该函数通过欧式距离的非线性映射，使语义相近但位置较远的Q-K仍能获得较高分数，缓解长距离稀释。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自注意力机制</title>
      <link href="/2023/08/22/transformer/self-attenion/"/>
      <url>/2023/08/22/transformer/self-attenion/</url>
      
        <content type="html"><![CDATA[<h1>自注意力机制</h1><h2 id="自注意力机制公式">自注意力机制公式</h2><p>self-attention = Softmax(QK^T / sqrt(d_k))*V</p><h3 id="为什么要对qk-t进行缩放">为什么要对QK^T进行缩放</h3><p>（1）这样可以对数值进行缩放，避免QK^T的数值过大，导致Softmax函数的输出结果接近于0，从而影响模型的训练。<br>（2）在模型训练时QK^T的数值范围分布更加均匀，避免梯度消失和梯度爆炸的问题。</p><h3 id="self-attention一定要这样表达吗？有无其他的计算方式">self-attention一定要这样表达吗？有无其他的计算方式</h3><p>不需要，self-attention公式只要起到相同的作用即可，下面是不同的变体：<br>（1）Linformer:对K和V做低秩投影：用E、F将K,V从n乘dk压缩到k乘d_k;注意力分数计算变为QK^T * E * F^T / sqrt(d_k),再与F^T * V加权。<br>（2）Performer:利用正定核函数（如RBF核）将Softmax注意力近似为：Softmax(QK^T/sqrt(d_k))约等于R(Q)*R(K)^T。直接计算R(Q) * R(K)^T避免全量计算。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>softmax</title>
      <link href="/2023/08/22/transformer/softmax/"/>
      <url>/2023/08/22/transformer/softmax/</url>
      
        <content type="html"><![CDATA[<h1>Softmax公式</h1><p>输入向量为x = [x1, x2, x3, …, xn]<br>输出为：</p><p>Softmax(x) = exp(x_i) / sum(exp(x_j))</p><h1>Softmax的作用</h1><p>Softmax函数的作用是将一个向量映射到一个概率分布上，使得每一个元素的取值都在0到1之间，并且所有元素之和为1,在这过程中会放大元素之间的差异</p><p>（1）分类任务中的概率输出：在图像任务中，模型最后的输出的Logits没有实际意义，需要通过Softmax函数将其转换为概率分布，才能进行分类。<br>（2）交叉熵损失：CrossEntropyLoss = Softmax+NLLLoss,其中，NLLLoss = -log(Softmax(x_i))，这样可以直接计算出模型的预测概率与真实标签的差异。</p><h1>Softmax的问题</h1><p>（1）数值溢出\下溢问题：当输入向量的元素值很大时，exp(x_i)会溢出，导致计算结果为NaN；当元素值很小时，exp(x_i)会下溢，导致计算结果为0。<br>（2）独热问题：当Softmax的输出接近独热向量时，交叉熵损失的数值会集中在独热向量上，这会导致模型过度自信，无法关注错误类别的梯度，即梯度稀疏。<br>（3）异常值敏感问题：Softmax的输入向量中存在异常值的话，会扭曲整个计算过程中的概率分布，导致梯度集中在异常值对应的位置，这会影响模型的训练。</p><h1>Softmax的问题解决方案</h1><p>（1）数值溢出\下溢问题：通过减少输入向量中的最大值避免溢出，log(sum(exp(x_j))) = max(x)+log(sum(exp(x_j-max(x)))),此时x_j-max(x)&lt;0,exp(x_j-max(x))&lt;1,彻底避免了数值溢出。<br>（2）独热问题：将真实热标签输出进行平滑处理，迫使模型的输出更平均<br>（3）异常值敏感问题：对输入进行预处理</p><h1>Softmax函数的变体</h1><p>(1) LogSoftmax，直接对Softmax的结果取对数，LogSoftmax(x) = log(exp(x) / sum(exp(x))) = x - log(sum(exp(x)))。这样做的好处是可以解决下溢的问题<br>(2) 温度缩放Softmax：在Softmax函数中，引入一个温度系数T，Softmax(x) = exp(x/T)/sum(exp(x/T))。当T=1时，退化为标准Softmax函数，T&gt;1时，输出的分布会更加平均，T&lt;1时输出被放大，输出会更加尖锐。<br>(3) 稀疏Softmax：通过L1正则化，强制Softmax的输出部分元素非0，其余元素皆为0，这样可以增强模型的可解释性</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416分割等和子集</title>
      <link href="/2023/08/10/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>/2023/08/10/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/416%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>416分割等和子集</h1><h2 id="题目描述">题目描述</h2><p>给你一个只包含正整数的非空数值nums,请你判断是否可以将这个数组分为两个子集，使其元素和相等。</p><h2 id="问题分析">问题分析</h2><p>(1)若一个数组nums可以被分为两个子集，那么数组和必定是偶数。<br>(2)问题可以转化为，是否存在一个子集，它的元素和是数组和的一半，这是典型的子集和target问题。</p><h2 id="解题核心与思路">解题核心与思路</h2><p>这是典型的背包问题：<br>（1）每个元素可以选择一次<br>（2）背包容量为数组和的一半<br>（3）是否存在一个子集，它的元素和等于背包容量<br>转化为动态规划问题：<br>（1）dp[i]表示是否可以用数组中的元素组成和为i的子集。<br>（2）初始化dp[0] = true，表示和为0的子集总是存在的。<br>（3）迭代数组nums中的元素n，再从target反向遍历到n,更新dp[j] = dp[j]||dp[j-n]。</p><h2 id="解题代码">解题代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;target)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target<span class="number">+1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=n;j--)&#123;</span><br><span class="line">                dp[j] = dp[j]||dp[j-n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>(1)时间复杂度:O(n*target),其中n是数组的长度，target是数组和的一半。<br>(2)空间复杂度:O(target),使用了一个长度为target+1的数组dp。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 01背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算子开发-add</title>
      <link href="/2023/08/01/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/add/"/>
      <url>/2023/08/01/%E7%AE%97%E5%AD%90%E5%BC%80%E5%8F%91/add/</url>
      
        <content type="html"><![CDATA[<h1>算子开发-add</h1><p>在深度学习框架或数值计算引擎中，<strong>Add（加法）算子</strong>是最基础、最常用的计算单元之一。它看似简单，却需要兼顾输入兼容性（如张量广播）、数据类型安全、内存稳定性等核心问题。本文将详细拆解Add算子的实现逻辑，从需求分析到代码落地，剖析基础算子开发的关键设计思路。</p><h2 id="开发背景与核心需求">开发背景与核心需求</h2><p>Add算子的核心功能是实现两个张量（或标量）的逐元素加法，但在实际框架中，其需满足以下工程化需求：</p><ul><li><strong>输入合法性校验</strong>：避免空指针、输入数量不足（至少2个输入）、形状/数据类型信息缺失等问题导致崩溃；</li><li><strong>张量广播支持</strong>：兼容不同维度的输入（如<code>[2,3]</code>与<code>[3]</code>相加），按广播规则推导输出形状；</li><li><strong>数据类型安全</strong>：仅支持框架适配的数值类型（如<code>float32</code>/<code>float64</code>/<code>int32</code>/<code>int64</code>），拒绝非法类型；</li><li><strong>内存安全</strong>：避免内存泄漏、野指针访问，确保动态分配的资源（如<code>Var</code>、<code>Schedule</code>）正确释放；</li><li><strong>符号维度管理</strong>：支持动态维度（如<code>-1</code>表示未知维度），并通过约束保证输出维度的合法性。</li></ul><h2 id="核心设计思路">核心设计思路</h2><p>在具体实现前，需梳理Add算子的核心流程以确保逻辑闭环：</p><ol><li><strong>前置校验</strong>：先执行安全检查（空指针、输入数量），再进行合法性校验（形状/类型完整性）；</li><li><strong>形状处理</strong>：统一空形状（标量）为<code>[1]</code>，按广播规则计算输出形状；</li><li><strong>符号化构建</strong>：生成输入/输出的符号维度表达式，为框架后续优化（如编译优化、内存规划）提供元信息；</li><li><strong>计算逻辑实现</strong>：创建循环变量、构建输入索引、生成加法表达式，最终封装为可执行的算子节点；</li><li><strong>资源管理</strong>：确保动态分配的内存（如<code>Var</code>、<code>ConnectOperatorToGraphParams</code>）正确释放，避免泄漏。</li></ol><h2 id="代码核心逻辑解析">代码核心逻辑解析</h2><p>以下结合代码逐模块拆解实现细节，每一步均对应上述设计思路的落地。</p><h3 id="基础安全校验：规避运行时崩溃风险">基础安全校验：规避运行时崩溃风险</h3><p>任何算子的首要环节是<strong>安全防护</strong>，以避免非法输入导致的内存访问错误。代码开篇即执行两层关键校验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础安全检查：避免空指针访问</span></span><br><span class="line"><span class="keyword">if</span> (!func_params) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;func_params pointer is null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Node* node = func_params-&gt;node;</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Node pointer is null in func_params.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>空指针校验</strong>：<code>func_params</code>（算子参数容器）和<code>node</code>（算子节点）为核心入参，若为<code>null</code>则直接抛出异常，避免后续<code>-&gt;</code>访问导致崩溃；</li><li><strong>异常类型选择</strong>：使用<code>std::invalid_argument</code>而非通用异常，明确告知调用者“输入参数非法”，便于问题定位。</li></ul><h3 id="输入输出合法性校验：符合算子语义">输入输出合法性校验：符合算子语义</h3><p>Add算子的语义要求“至少2个输入、1个输出”，且必须包含形状和数据类型信息，这是确保算子正常计算的前提：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入输出数量校验：加法算子需至少2个输入和1个输出</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;_inputs_name.<span class="built_in">size</span>() &lt; <span class="number">2</span> || node-&gt;_outputs_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Add operator requires two inputs and one output.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形状和数据类型完整性校验：确保输入输出的形状与类型信息完整</span></span><br><span class="line"><span class="keyword">if</span> (func_params-&gt;input_shapes.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">    func_params-&gt;input_data_types.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">    func_params-&gt;output_data_types.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Add requires complete input/output shapes and data types.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数量校验</strong>：输入不足2个或无输出时，直接拒绝计算（例如仅传入1个输入无法执行加法）；</li><li><strong>信息完整性</strong>：若输入形状（<code>input_shapes</code>）或数据类型（<code>input_data_types</code>）缺失，后续无法推导输出形状和执行计算，因此必须校验。</li></ul><h3 id="形状预处理：统一维度处理逻辑">形状预处理：统一维度处理逻辑</h3><p>标量（无形状）和张量在维度处理上易出现不一致，因此需先进行<strong>形状统一</strong>，再推导广播后的输出形状。</p><h4 id="空形状转-1-：标量张量化">空形状转[1]：标量张量化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入形状调整：空形状统一转为[1]，保证维度处理一致性，计算输入张量秩</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_a = func_params-&gt;input_shapes[<span class="number">0</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_a = raw_shape_a.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_a;</span><br><span class="line"><span class="type">int</span> rank_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_b = func_params-&gt;input_shapes[<span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_b = raw_shape_b.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_b;</span><br><span class="line"><span class="type">int</span> rank_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_b.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><ul><li><strong>设计意图</strong>：标量（如<code>5</code>）可视为“1维、长度为1”的张量（<code>[5]</code>），使后续广播逻辑无需单独处理标量，简化代码；</li><li><strong>秩（rank）计算</strong>：张量的“秩”即维度数（如<code>[2,3]</code>的秩为2），后续广播需基于秩对比。</li></ul><h4 id="广播形状推导：兼容不同维度输入">广播形状推导：兼容不同维度输入</h4><p>广播是Add算子支持灵活输入的核心，代码严格遵循<strong>张量广播规则</strong>（低维张量向高维对齐，维度长度为1时可扩展）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导广播后输出形状：按张量广播规则计算最大兼容维度</span></span><br><span class="line"><span class="type">size_t</span> max_rank = std::<span class="built_in">max</span>(&#123;<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b), <span class="built_in">size_t</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">broadcasted_shape</span><span class="params">(max_rank, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">    <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前维度值，超出输入秩范围时按1处理</span></span><br><span class="line">    <span class="type">int</span> dim_a = (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? adjusted_shape_a[idx_a] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dim_b = (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? adjusted_shape_b[idx_b] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广播规则判断：兼容维度或动态维度（-1）可广播，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (dim_a == dim_b || dim_a == <span class="number">1</span> || dim_b == <span class="number">1</span>) &#123;</span><br><span class="line">        broadcasted_shape[i] = std::<span class="built_in">max</span>(dim_a, dim_b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dim_a == <span class="number">-1</span> || dim_b == <span class="number">-1</span>) &#123;</span><br><span class="line">        broadcasted_shape[i] = (dim_a != <span class="number">-1</span>) ? dim_a : dim_b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Cannot broadcast A dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_a) + <span class="string">&quot; and B dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_b) + <span class="string">&quot; at position &quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; in node &quot;</span> + node_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>广播逻辑拆解</strong>：<ol><li>确定最大秩（<code>max_rank</code>）：例如输入A（秩2：<code>[2,3]</code>）和输入B（秩1：<code>[3]</code>），最大秩为2；</li><li>维度对齐：从最低维（右数第一位）开始对比，低维张量的“缺失维度”视为1（如B的第0维对应A的第1维，B的第1维视为1）；</li><li>维度兼容性判断：<ul><li>若两个维度相等（如<code>3</code>和<code>3</code>）或有一个为1（如<code>2</code>和<code>1</code>），则可广播为较大值（如<code>3</code>、<code>2</code>）；</li><li>若存在动态维度（<code>-1</code>，表示运行时确定），则优先取已知维度值；</li><li>若均不满足（如<code>2</code>和<code>3</code>），则抛出异常，避免非法计算。</li></ul></li></ol></li></ul><h3 id="符号维度构建：为框架优化提供元信息">符号维度构建：为框架优化提供元信息</h3><p>在编译型框架中，算子需提供<strong>符号化的维度信息</strong>（而非仅数值），用于后续的内存规划、循环展开等优化。代码中通过<code>Var</code>（符号变量）和<code>ScalarExpr</code>（符号表达式）实现这一功能。</p><h4 id="输入符号维度生成">输入符号维度生成</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义符号维度：生成输入维度符号表达式，收集待约束变量</span></span><br><span class="line">std::vector&lt;ScalarExpr&gt; exprs_a, exprs_b, output_dims;</span><br><span class="line">std::vector&lt;Var*&gt; vars_to_constrain;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成输入A的符号维度表达式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">    exprs_a.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_a_name, is_const_a, adjusted_shape_a[i], i, vars_to_constrain));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成输入B的符号维度表达式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">    exprs_b.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_b_name, is_const_b, adjusted_shape_b[i], i, vars_to_constrain));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>make_dim</code>功能</strong>：为每个输入维度创建符号表达式（如<code>A_dim0</code>、<code>B_dim1</code>），并收集需要后续约束的变量（<code>vars_to_constrain</code>）；</li><li><strong>常量标记（<code>is_const_a</code>）</strong>：若输入是常量张量（如<code>[5,6]</code>），其维度为固定值，符号表达式直接绑定常量，避免冗余计算。</li></ul><h4 id="输出符号维度生成">输出符号维度生成</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成输出维度符号变量：为广播后形状创建对应的符号变量并加入约束列表</span></span><br><span class="line">std::vector&lt;Var*&gt; output_dim_vars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; broadcasted_shape.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::string var_name = output_name + <span class="string">&quot;_dim&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">    Var* var = <span class="built_in">new</span> (std::nothrow) <span class="built_in">Var</span>(var_name, <span class="string">&quot;int32&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!var) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    output_dim_vars.<span class="built_in">push_back</span>(var);</span><br><span class="line">    output_dims.<span class="built_in">push_back</span>(<span class="built_in">ScalarExpr</span>(var));</span><br><span class="line">    vars_to_constrain.<span class="built_in">push_back</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>动态内存安全</strong>：使用<code>new (std::nothrow)</code>分配<code>Var</code>，若内存不足则抛出<code>std::bad_alloc</code>，避免野指针；</li><li><strong>输出维度约束</strong>：输出维度的符号变量（如<code>C_dim0</code>）后续会绑定到“输入维度的最大值”（见维度约束部分），确保与广播逻辑一致。</li></ul><h3 id="计算逻辑实现：从占位符到加法表达式">计算逻辑实现：从占位符到加法表达式</h3><p>此部分为算子的“核心计算体”，需完成输入占位符创建、循环变量生成、索引构建、加法表达式封装。</p><h4 id="输入张量占位符">输入张量占位符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输入张量占位符</span></span><br><span class="line">Expr A = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_placeholder</span>(input_a_name, dtype_a, <span class="built_in">Shape</span>(exprs_a)));</span><br><span class="line">Expr B = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_placeholder</span>(input_b_name, dtype_b, <span class="built_in">Shape</span>(exprs_b)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验输入张量创建结果</span></span><br><span class="line"><span class="keyword">if</span> (!A.<span class="built_in">get_tensor</span>() || !B.<span class="built_in">get_tensor</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create input placeholders.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>占位符作用</strong>：<code>create_tensor_by_placeholder</code>创建输入张量的“符号占位符”，不实际存储数据，仅用于描述张量的名称、类型、维度信息；</li><li><strong>结果校验</strong>：确保占位符创建成功，避免后续基于空张量计算。</li></ul><h4 id="循环变量：实现逐元素遍历">循环变量：实现逐元素遍历</h4><p>Add算子为逐元素计算，需按输出维度生成<strong>数据并行循环变量</strong>（<code>LoopVar</code>），用于遍历输出张量的每个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建输出循环变量：按广播后维度生成数据并行循环变量</span></span><br><span class="line"><span class="type">size_t</span> loop_rank = broadcasted_shape.<span class="built_in">size</span>();</span><br><span class="line">std::vector&lt;Expr&gt; loop_vars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop_rank; ++i) &#123;</span><br><span class="line">    std::string var_name = <span class="string">&quot;o&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">    LoopVar* lv = <span class="built_in">create_loopvar</span>(var_name, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), output_dims[i]), <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line">    <span class="keyword">if</span> (!lv) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create loop var &quot;</span> + var_name);</span><br><span class="line">    &#125;</span><br><span class="line">    loop_vars.<span class="built_in">push_back</span>(<span class="built_in">Expr</span>(lv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标量索引专用循环变量：用于常量1维张量的索引访问（范围0~1）</span></span><br><span class="line">LoopVar* zero_lv = <span class="built_in">create_loopvar</span>(<span class="string">&quot;zero_idx&quot;</span>, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), <span class="built_in">ScalarExpr</span>(<span class="number">1</span>)), <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line"><span class="keyword">if</span> (!zero_lv) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create zero loop variable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Expr zero_loop = <span class="built_in">Expr</span>(zero_lv);</span><br></pre></td></tr></table></figure><ul><li><strong>循环变量类型</strong>：<code>LoopVarType::DataPar</code>表示该循环可并行执行（如GPU的线程并行），为后续性能优化预留空间；</li><li><strong>专用零循环（<code>zero_loop</code>）</strong>：常量1维张量（如<code>[5]</code>）的索引固定为0，用<code>zero_loop</code>（范围<code>0~1</code>）访问，避免索引越界。</li></ul><h4 id="输入索引构建：匹配广播逻辑">输入索引构建：匹配广播逻辑</h4><p>广播后，输入张量的维度可能与输出不一致，需构建<strong>动态索引</strong>，确保每个输出元素能正确找到对应的输入元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建输入A索引表达式：根据广播规则和常量标记生成索引</span></span><br><span class="line">std::vector&lt;Expr&gt; index_a;</span><br><span class="line"><span class="type">int</span> rank_diff_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_const_a &amp;&amp; adjusted_shape_a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        index_a.<span class="built_in">push_back</span>(zero_loop);  <span class="comment">// 常量1维用专用索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> output_dim_idx = i + rank_diff_a;</span><br><span class="line">        <span class="comment">// 索引在循环变量范围内则使用循环变量，否则用专用索引</span></span><br><span class="line">        <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp; output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建输入B索引表达式：逻辑同输入A</span></span><br><span class="line">std::vector&lt;Expr&gt; index_b;</span><br><span class="line"><span class="comment">// ...（逻辑与index_a一致，略）</span></span><br></pre></td></tr></table></figure><ul><li><strong>索引逻辑示例</strong>：<ul><li>输入A（<code>[2,3]</code>，秩2），输入B（<code>[3]</code>，秩1），输出秩2；</li><li>对B的索引：<code>rank_diff_b = 2-1=1</code>，B的第0维对应输出的第1维，因此<code>index_b = [loop_vars[1]]</code>；</li><li>若B是常量1维（如<code>[5]</code>），则<code>index_b = [zero_loop]</code>，始终取第0个元素。</li></ul></li></ul><h4 id="加法表达式与输出张量">加法表达式与输出张量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建加法计算表达式</span></span><br><span class="line">Expr expr_a = A[index_a];</span><br><span class="line">Expr expr_b = B[index_b];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验加法支持的数据类型：仅支持float32/float64/int32/int64</span></span><br><span class="line"><span class="keyword">if</span> ((dtype_a != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int64&quot;</span>) ||</span><br><span class="line">    (dtype_b != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int64&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unsupported dtype for add: A=&quot;</span> + dtype_a + <span class="string">&quot;, B=&quot;</span> + dtype_b);</span><br><span class="line">&#125;</span><br><span class="line">Expr compute_body = expr_a + expr_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建输出计算张量：基于循环变量和计算表达式生成输出张量</span></span><br><span class="line">Expr C = <span class="built_in">Expr</span>(<span class="built_in">create_tensor_by_compute</span>(output_name, output_dtype, <span class="built_in">Shape</span>(output_dims), Expr::<span class="built_in">assign</span>(loop_vars, compute_body)));</span><br><span class="line"><span class="keyword">if</span> (!C.<span class="built_in">get_tensor</span>() || !C.<span class="built_in">get_tensor</span>()-&gt;op) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create output compute tensor.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数据类型校验</strong>：仅支持四种常用数值类型，避免不支持的类型（如<code>bool</code>、<code>uint8</code>）导致计算错误；</li><li><strong><code>create_tensor_by_compute</code></strong>：将“循环变量遍历”和“加法表达式”封装为输出张量的计算逻辑，即“对每个循环变量对应的位置，执行<code>expr_a + expr_b</code>并赋值给输出”。</li></ul><h3 id="算子封装与图连接：融入框架计算流">算子封装与图连接：融入框架计算流</h3><p>算子逻辑实现后，需封装为框架可识别的<code>OperatorFunc</code>和<code>OperatorGraphFuncNode</code>，并连接到全局计算图（TIR）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建调度器与算子实例：封装计算逻辑与调度信息</span></span><br><span class="line">Schedule* schedule = <span class="built_in">create_schedule</span>(C.<span class="built_in">get_tensor</span>()-&gt;op);</span><br><span class="line"><span class="keyword">if</span> (!schedule) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create schedule.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存安全分配：避免内存分配失败导致的资源泄漏</span></span><br><span class="line">OperatorFunc* add_func = <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorFunc</span>(node_name, schedule);</span><br><span class="line">OperatorGraphFuncNode* add_node = <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorGraphFuncNode</span>(node_name, <span class="string">&quot;params_none&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!add_func || !add_node) &#123;</span><br><span class="line">    <span class="keyword">delete</span> add_func;</span><br><span class="line">    <span class="keyword">delete</span> add_node;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将算子添加到TIR计算图</span></span><br><span class="line">tir.<span class="built_in">add_operator</span>(add_node, add_func);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配图连接参数：封装算子连接所需的元信息</span></span><br><span class="line">ConnectOperatorToGraphParams* connect_params = <span class="built_in">new</span> (std::nothrow) <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line"><span class="keyword">if</span> (!connect_params) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line">connect_params-&gt;node_name = node_name;</span><br><span class="line">connect_params-&gt;output_datatype = output_dtype;</span><br><span class="line">connect_params-&gt;output_name = output_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立算子与计算图的连接</span></span><br><span class="line"><span class="built_in">connect_operator_to_graph</span>(tir, connect_params, add_node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放临时资源：避免内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span> connect_params;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Schedule</code>作用</strong>：调度器用于定义算子的执行策略（如循环顺序、并行方式），是框架性能优化的关键入口；</li><li><strong>资源泄漏防护</strong>：<ul><li>分配<code>add_func</code>和<code>add_node</code>后，若任一为<code>null</code>，立即释放已分配资源，再抛出异常；</li><li>临时变量<code>connect_params</code>使用后手动<code>delete</code>，避免内存泄漏。</li></ul></li></ul><h3 id="维度约束：确保符号变量合法性">维度约束：确保符号变量合法性</h3><p>最后，需为符号变量（输入和输出维度）添加<strong>取值约束</strong>，确保运行时维度在合法范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束输出维度变量：将输出维度绑定为输入维度的最大值，并设置有效范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_dim_vars.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    Var* var = output_dim_vars[i];</span><br><span class="line">    <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">    <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">    ScalarExpr dim_a_expr = (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? exprs_a[idx_a] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line">    ScalarExpr dim_b_expr = (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? exprs_b[idx_b] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    add_func-&gt;parameter_assign_expr[var] = ScalarExpr::<span class="built_in">simple_max</span>(dim_a_expr, dim_b_expr);</span><br><span class="line">    add_func-&gt;unknown_var_bound[var] = <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">    add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束输入符号变量：设置输入相关符号变量的有效范围（排除输出维度变量）</span></span><br><span class="line"><span class="keyword">for</span> (Var* var : vars_to_constrain) &#123;</span><br><span class="line">    <span class="comment">// ...（略：跳过输出维度变量，为输入变量设置1~MAX_VALID_RANGE的约束）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>输出维度约束</strong>：将输出维度的符号变量绑定为“输入维度的最大值”（与广播逻辑一致），同时限制取值范围为<code>1~MAX_VALID_RANGE</code>（避免0或负数维度）；</li><li><strong>输入维度约束</strong>：确保输入维度为合法正数，避免无效形状（如<code>[0,3]</code>）。</li></ul><h2 id="算子开发的关键亮点">算子开发的关键亮点</h2><p>回顾整个实现，该Add算子有三个核心亮点，亦是基础算子开发的通用经验：</p><ol><li><strong>全链路安全校验</strong>：从空指针、输入数量、形状完整性，到数据类型、索引数量，每一步均有校验，最大程度降低运行时崩溃风险；</li><li><strong>灵活的广播支持</strong>：严格遵循张量广播规则，兼容标量、不同秩张量，同时支持动态维度（<code>-1</code>），适配复杂场景；</li><li><strong>内存安全设计</strong>：所有动态分配的资源（<code>Var</code>、<code>OperatorFunc</code>、<code>connect_params</code>）均有释放逻辑，杜绝内存泄漏。</li></ol><h2 id="总结与后续优化">总结与后续优化</h2><p>Add算子作为基础计算单元，其开发重点不在于“加法逻辑本身”，而在于<strong>工程化兼容性和稳定性</strong>。本文通过“安全校验→形状处理→符号构建→计算实现→图连接”的流程，完成了一个健壮的Add算子开发。</p><p>后续可从两个方向优化：</p><ul><li><strong>扩展数据类型</strong>：支持<code>uint8</code>、<code>float16</code>等更多类型，适配端侧推理场景；</li><li><strong>性能优化</strong>：通过<code>Schedule</code>添加向量化（如SIMD）、循环展开等优化，提升大规模张量加法的计算效率。</li></ul><p>基础算子是框架的“基石”，唯有打磨好每个细节，才能支撑上层复杂模型的稳定运行。希望本文的拆解能为算子开发提供参考。</p><h2 id="完整代码">完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include.hpp&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALID_RANGE = MAX_INF;</span><br><span class="line"><span class="function">OperatorGraphFuncNode* <span class="title">create_add_operator</span><span class="params">(TIR&amp; tir, FuncParams* func_params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础安全检查：避免空指针访问</span></span><br><span class="line">    <span class="keyword">if</span> (!func_params) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;func_params pointer is null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node = func_params-&gt;node;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Node pointer is null in func_params.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入输出数量校验：加法算子需至少2个输入和1个输出</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_inputs_name.<span class="built_in">size</span>() &lt; <span class="number">2</span> || node-&gt;_outputs_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">            <span class="string">&quot;Add operator requires two inputs and one output.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形状和数据类型完整性校验：确保输入输出的形状与类型信息完整</span></span><br><span class="line">    <span class="keyword">if</span> (func_params-&gt;input_shapes.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">        func_params-&gt;input_data_types.<span class="built_in">size</span>() &lt; <span class="number">2</span> ||</span><br><span class="line">        func_params-&gt;output_data_types.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">            <span class="string">&quot;Add requires complete input/output shapes and data types.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义核心变量：节点名、输入输出张量名</span></span><br><span class="line">    std::string node_name = node-&gt;_simple_name;</span><br><span class="line">    std::string input_a_name = node-&gt;_inputs_name[<span class="number">0</span>];</span><br><span class="line">    std::string input_b_name = node-&gt;_inputs_name[<span class="number">1</span>];</span><br><span class="line">    std::string output_name = node-&gt;_outputs_name[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入输出数据类型</span></span><br><span class="line">    std::string dtype_a = func_params-&gt;input_data_types[<span class="number">0</span>];</span><br><span class="line">    std::string dtype_b = func_params-&gt;input_data_types[<span class="number">1</span>];</span><br><span class="line">    std::string output_dtype = func_params-&gt;output_data_types[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记输入张量是否为常量</span></span><br><span class="line">    <span class="type">bool</span> is_const_a = <span class="built_in">is_constant_tensor</span>(input_a_name);</span><br><span class="line">    <span class="type">bool</span> is_const_b = <span class="built_in">is_constant_tensor</span>(input_b_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入形状调整：空形状统一转为[1]，保证维度处理一致性，计算输入张量秩</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_a = func_params-&gt;input_shapes[<span class="number">0</span>];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_a =</span><br><span class="line">        raw_shape_a.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_a;</span><br><span class="line">    <span class="type">int</span> rank_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; raw_shape_b = func_params-&gt;input_shapes[<span class="number">1</span>];</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; adjusted_shape_b =</span><br><span class="line">        raw_shape_b.<span class="built_in">empty</span>() ? std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125; : raw_shape_b;</span><br><span class="line">    <span class="type">int</span> rank_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(adjusted_shape_b.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推导广播后输出形状：按张量广播规则计算最大兼容维度</span></span><br><span class="line">    <span class="type">size_t</span> max_rank = std::<span class="built_in">max</span>(</span><br><span class="line">        &#123;<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b), <span class="built_in">size_t</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">broadcasted_shape</span><span class="params">(max_rank, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">        <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前维度值，超出输入秩范围时按1处理</span></span><br><span class="line">        <span class="type">int</span> dim_a =</span><br><span class="line">            (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? adjusted_shape_a[idx_a] : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dim_b =</span><br><span class="line">            (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? adjusted_shape_b[idx_b] : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播规则判断：兼容维度或动态维度（-1）可广播，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (dim_a == dim_b || dim_a == <span class="number">1</span> || dim_b == <span class="number">1</span>) &#123;</span><br><span class="line">            broadcasted_shape[i] = std::<span class="built_in">max</span>(dim_a, dim_b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dim_a == <span class="number">-1</span> || dim_b == <span class="number">-1</span>) &#123;</span><br><span class="line">            broadcasted_shape[i] = (dim_a != <span class="number">-1</span>) ? dim_a : dim_b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(</span><br><span class="line">                <span class="string">&quot;Cannot broadcast A dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_a) +</span><br><span class="line">                <span class="string">&quot; and B dim &quot;</span> + std::<span class="built_in">to_string</span>(dim_b) + <span class="string">&quot; at position &quot;</span> +</span><br><span class="line">                std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; in node &quot;</span> + node_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符号维度：生成输入维度符号表达式，收集待约束变量</span></span><br><span class="line">    std::vector&lt;ScalarExpr&gt; exprs_a, exprs_b, output_dims;</span><br><span class="line">    std::vector&lt;Var*&gt; vars_to_constrain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输入A的符号维度表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">        exprs_a.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_a_name, is_const_a,</span><br><span class="line">                                   adjusted_shape_a[i], i, vars_to_constrain));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输入B的符号维度表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">        exprs_b.<span class="built_in">push_back</span>(<span class="built_in">make_dim</span>(input_b_name, is_const_b,</span><br><span class="line">                                   adjusted_shape_b[i], i, vars_to_constrain));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输出维度符号变量：为广播后形状创建对应的符号变量并加入约束列表</span></span><br><span class="line">    std::vector&lt;Var*&gt; output_dim_vars;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; broadcasted_shape.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::string var_name = output_name + <span class="string">&quot;_dim&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        Var* var = <span class="built_in">new</span> (std::nothrow) <span class="built_in">Var</span>(var_name, <span class="string">&quot;int32&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!var) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        output_dim_vars.<span class="built_in">push_back</span>(var);</span><br><span class="line">        output_dims.<span class="built_in">push_back</span>(<span class="built_in">ScalarExpr</span>(var));</span><br><span class="line">        vars_to_constrain.<span class="built_in">push_back</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输入张量占位符</span></span><br><span class="line">    Expr A = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_placeholder</span>(input_a_name, dtype_a, <span class="built_in">Shape</span>(exprs_a)));</span><br><span class="line">    Expr B = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_placeholder</span>(input_b_name, dtype_b, <span class="built_in">Shape</span>(exprs_b)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验输入张量创建结果</span></span><br><span class="line">    <span class="keyword">if</span> (!A.<span class="built_in">get_tensor</span>() || !B.<span class="built_in">get_tensor</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create input placeholders.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出循环变量：按广播后维度生成数据并行循环变量</span></span><br><span class="line">    <span class="type">size_t</span> loop_rank = broadcasted_shape.<span class="built_in">size</span>();</span><br><span class="line">    std::vector&lt;Expr&gt; loop_vars;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop_rank; ++i) &#123;</span><br><span class="line">        std::string var_name = <span class="string">&quot;o&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        LoopVar* lv = <span class="built_in">create_loopvar</span>(var_name, <span class="string">&quot;int32&quot;</span>,</span><br><span class="line">                                     <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), output_dims[i]), <span class="string">&quot;&quot;</span>,</span><br><span class="line">                                     LoopVarType::DataPar);</span><br><span class="line">        <span class="keyword">if</span> (!lv) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create loop var &quot;</span> + var_name);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_vars.<span class="built_in">push_back</span>(<span class="built_in">Expr</span>(lv));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标量索引专用循环变量：用于常量1维张量的索引访问（范围0~1）</span></span><br><span class="line">    LoopVar* zero_lv =</span><br><span class="line">        <span class="built_in">create_loopvar</span>(<span class="string">&quot;zero_idx&quot;</span>, <span class="string">&quot;int32&quot;</span>, <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">0</span>), <span class="built_in">ScalarExpr</span>(<span class="number">1</span>)),</span><br><span class="line">                       <span class="string">&quot;&quot;</span>, LoopVarType::DataPar);</span><br><span class="line">    <span class="keyword">if</span> (!zero_lv) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create zero loop variable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Expr zero_loop = <span class="built_in">Expr</span>(zero_lv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输入A索引表达式：根据广播规则和常量标记生成索引</span></span><br><span class="line">    std::vector&lt;Expr&gt; index_a;</span><br><span class="line">    <span class="type">int</span> rank_diff_a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_const_a &amp;&amp; adjusted_shape_a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            index_a.<span class="built_in">push_back</span>(zero_loop);  <span class="comment">// 常量1维用专用索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> output_dim_idx = i + rank_diff_a;</span><br><span class="line">            <span class="comment">// 索引在循环变量范围内则使用循环变量，否则用专用索引</span></span><br><span class="line">            <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">                index_a.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index_a.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建输入B索引表达式：逻辑同输入A</span></span><br><span class="line">    std::vector&lt;Expr&gt; index_b;</span><br><span class="line">    <span class="type">int</span> rank_diff_b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank) - rank_b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rank_b; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_const_b &amp;&amp; adjusted_shape_b[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            index_b.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> output_dim_idx = i + rank_diff_b;</span><br><span class="line">            <span class="keyword">if</span> (output_dim_idx &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                output_dim_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(loop_rank)) &#123;</span><br><span class="line">                index_b.<span class="built_in">push_back</span>(loop_vars[output_dim_idx]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index_b.<span class="built_in">push_back</span>(zero_loop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引数量校验：确保索引数量与输入张量维度匹配</span></span><br><span class="line">    <span class="keyword">if</span> (index_a.<span class="built_in">size</span>() != <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_a)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;A index count mismatch: expected &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(rank_a) + <span class="string">&quot;, got &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(index_a.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index_b.<span class="built_in">size</span>() != <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rank_b)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;B index count mismatch: expected &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(rank_b) + <span class="string">&quot;, got &quot;</span> +</span><br><span class="line">                                 std::<span class="built_in">to_string</span>(index_b.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建加法计算表达式</span></span><br><span class="line">    Expr expr_a = A[index_a];</span><br><span class="line">    Expr expr_b = B[index_b];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验加法支持的数据类型：仅支持float32/float64/int32/int64</span></span><br><span class="line">    <span class="keyword">if</span> ((dtype_a != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_a != <span class="string">&quot;int32&quot;</span> &amp;&amp;</span><br><span class="line">         dtype_a != <span class="string">&quot;int64&quot;</span>) ||</span><br><span class="line">        (dtype_b != <span class="string">&quot;float32&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;float64&quot;</span> &amp;&amp; dtype_b != <span class="string">&quot;int32&quot;</span> &amp;&amp;</span><br><span class="line">         dtype_b != <span class="string">&quot;int64&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unsupported dtype for add: A=&quot;</span> + dtype_a +</span><br><span class="line">                                    <span class="string">&quot;, B=&quot;</span> + dtype_b);</span><br><span class="line">    &#125;</span><br><span class="line">    Expr compute_body = expr_a + expr_b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出计算张量：基于循环变量和计算表达式生成输出张量</span></span><br><span class="line">    Expr C = <span class="built_in">Expr</span>(</span><br><span class="line">        <span class="built_in">create_tensor_by_compute</span>(output_name, output_dtype, <span class="built_in">Shape</span>(output_dims),</span><br><span class="line">                                 Expr::<span class="built_in">assign</span>(loop_vars, compute_body)));</span><br><span class="line">    <span class="keyword">if</span> (!C.<span class="built_in">get_tensor</span>() || !C.<span class="built_in">get_tensor</span>()-&gt;op) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create output compute tensor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调度器与算子实例：封装计算逻辑与调度信息</span></span><br><span class="line">    Schedule* schedule = <span class="built_in">create_schedule</span>(C.<span class="built_in">get_tensor</span>()-&gt;op);</span><br><span class="line">    <span class="keyword">if</span> (!schedule) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to create schedule.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存安全分配：避免内存分配失败导致的资源泄漏</span></span><br><span class="line">    OperatorFunc* add_func =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorFunc</span>(node_name, schedule);</span><br><span class="line">    OperatorGraphFuncNode* add_node =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">OperatorGraphFuncNode</span>(node_name, <span class="string">&quot;params_none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!add_func || !add_node) &#123;</span><br><span class="line">        <span class="keyword">delete</span> add_func;</span><br><span class="line">        <span class="keyword">delete</span> add_node;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束输出维度变量：将输出维度绑定为输入维度的最大值，并设置有效范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_dim_vars.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Var* var = output_dim_vars[i];</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx_a = rank_a - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line">        <span class="type">int</span> idx_b = rank_b - <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(max_rank) + i;</span><br><span class="line"></span><br><span class="line">        ScalarExpr dim_a_expr =</span><br><span class="line">            (idx_a &gt;= <span class="number">0</span> &amp;&amp; idx_a &lt; rank_a) ? exprs_a[idx_a] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line">        ScalarExpr dim_b_expr =</span><br><span class="line">            (idx_b &gt;= <span class="number">0</span> &amp;&amp; idx_b &lt; rank_b) ? exprs_b[idx_b] : <span class="built_in">ScalarExpr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        add_func-&gt;parameter_assign_expr[var] =</span><br><span class="line">            ScalarExpr::<span class="built_in">simple_max</span>(dim_a_expr, dim_b_expr);</span><br><span class="line">        add_func-&gt;unknown_var_bound[var] =</span><br><span class="line">            <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">        add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束输入符号变量：设置输入相关符号变量的有效范围（排除输出维度变量）</span></span><br><span class="line">    <span class="keyword">for</span> (Var* var : vars_to_constrain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过已处理的输出维度变量</span></span><br><span class="line">        <span class="type">bool</span> is_output_dim = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Var* output_var : output_dim_vars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var == output_var) &#123;</span><br><span class="line">                is_output_dim = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_output_dim) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 约束输入相关的符号变量</span></span><br><span class="line">        <span class="keyword">if</span> (var-&gt;name.<span class="built_in">find</span>(input_a_name) != std::string::npos ||</span><br><span class="line">            var-&gt;name.<span class="built_in">find</span>(input_b_name) != std::string::npos) &#123;</span><br><span class="line">            add_func-&gt;unknown_var_bound[var] =</span><br><span class="line">                <span class="built_in">Range</span>(<span class="built_in">ScalarExpr</span>(<span class="number">1</span>), <span class="built_in">ScalarExpr</span>(MAX_VALID_RANGE));</span><br><span class="line">            add_func-&gt;is_parameter[var] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将算子添加到TIR计算图</span></span><br><span class="line">    tir.<span class="built_in">add_operator</span>(add_node, add_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配图连接参数：封装算子连接所需的元信息</span></span><br><span class="line">    ConnectOperatorToGraphParams* connect_params =</span><br><span class="line">        <span class="built_in">new</span> (std::nothrow) <span class="built_in">ConnectOperatorToGraphParams</span>();</span><br><span class="line">    <span class="keyword">if</span> (!connect_params) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    connect_params-&gt;node_name = node_name;</span><br><span class="line">    connect_params-&gt;output_datatype = output_dtype;</span><br><span class="line">    connect_params-&gt;output_name = output_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立算子与计算图的连接</span></span><br><span class="line">    <span class="built_in">connect_operator_to_graph</span>(tir, connect_params, add_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放临时资源：避免内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span> connect_params;</span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Add Schedule:\n&quot; &lt;&lt; schedule-&gt;to_str() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Add Kernel:\n&quot; &lt;&lt; add_func-&gt;to_c_kernel_program() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> add_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算子开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算子开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>474.一和零</title>
      <link href="/2023/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/474%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
      <url>/2023/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/474%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1>474.一和零</h1><h2 id="题目描述">题目描述</h2><p>给你一个二进制字符串strs和两个整数m和n.</p><p>请你找出并返回strs的最大子集的长度，该子集中最多含有m个0和n个1.</p><p>如果x的所有元素也都是y的元素，那么x就是y的子集</p><h2 id="问题分析">问题分析</h2><p>这是一个典型的二维01背包问题<br>(1)字符串数组中的每一个字符串就是一个物品<br>(2)物品有两个重量，分别是字符串中的0的个数和1的个数<br>(3)背包有两个限制，分别是0的个数不超过m，1的个数不超过n<br>(4)每个物品的价值都是1.</p><h2 id="解题核心与思路">解题核心与思路</h2><p>将题目转化为动态规划<br>(1)dp[i][j]表示最多有i个0和j个1的strs的最大子集的长度。<br>(2)初始化dp数组为0<br>(3)遍历strs数组中的每一个字符串，对于每一个字符串计算他的0和1的个数。<br>(4)从后向前遍历，更新dp[i][j] = max(dp[i][j],dp[i-zero][j-one]+1)。</p><h2 id="解题代码">解题代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:strs)&#123;</span><br><span class="line">            <span class="type">int</span> countM = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> countN = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    countM++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    countN++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=countM;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=countN;j--)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],(dp[i-countM][j-countN]<span class="number">+1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>（1）时间复杂度：O(lmn+ls)<br>其中l是字符串数组的长度，m和n分别是0和1的个数，s是字符串的平均长度。<br>（2）空间复杂度：O(mn)</p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 01二维背包 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
